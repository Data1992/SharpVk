{
  "ANativeWindow": "",
  "char": "",
  "Display": "",
  "DWORD": "",
  "float": "",
  "HANDLE": "",
  "HINSTANCE": "",
  "HWND": "",
  "int": "",
  "int32_t": "",
  "LPCWSTR": "",
  "MirConnection": "",
  "MirSurface": "",
  "PFN_vkAllocationFunction": "Application-defined memory allocation function.",
  "PFN_vkAllocationFunction.alignment": "pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.",
  "PFN_vkAllocationFunction.allocationScope": "pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described <<memory-host-allocation-scope,here>>.",
  "PFN_vkAllocationFunction.pUserData": "pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.",
  "PFN_vkAllocationFunction.size": "pname:size is the size in bytes of the requested allocation.",
  "PFN_vkDebugReportCallbackEXT": "Application-defined debug report callback function.",
  "PFN_vkDebugReportCallbackEXT.flags": "pname:flags indicates the ename:VkDebugReportFlagBitsEXT that triggered this callback.",
  "PFN_vkDebugReportCallbackEXT.location": "pname:location is a component (layer, driver, loader) defined value that indicates the _location_ of the trigger. This is an optional value.",
  "PFN_vkDebugReportCallbackEXT.messageCode": "pname:messageCode is a layer-defined value indicating what test triggered this callback.",
  "PFN_vkDebugReportCallbackEXT.object": "pname:object gives the object where the issue was detected. pname:object may be ename:VK_NULL_HANDLE if there is no object associated with the event.",
  "PFN_vkDebugReportCallbackEXT.objectType": "pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of object being used or created at the time the event was triggered.",
  "PFN_vkDebugReportCallbackEXT.pLayerPrefix": "pname:pLayerPrefix is the abbreviation of the component making the callback. pname:pLayerPrefix is only valid for the duration of the callback.",
  "PFN_vkDebugReportCallbackEXT.pMessage": "pname:pMessage is a null-terminated string detailing the trigger conditions. pname:pMessage is only valid for the duration of the callback.",
  "PFN_vkDebugReportCallbackEXT.pUserData": "pname:pUserData is the user data given when the DebugReportCallback was created.",
  "PFN_vkFreeFunction": "Application-defined memory free function.",
  "PFN_vkFreeFunction.pMemory": "pname:pMemory is the allocation to be freed.",
  "PFN_vkFreeFunction.pUserData": "pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.",
  "PFN_vkInternalAllocationNotification": "Application-defined memory allocation notification function.",
  "PFN_vkInternalAllocationNotification.allocationScope": "pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described <<memory-host-allocation-scope,here>>.",
  "PFN_vkInternalAllocationNotification.allocationType": "pname:allocationType is the requested type of an allocation.",
  "PFN_vkInternalAllocationNotification.pUserData": "pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.",
  "PFN_vkInternalAllocationNotification.size": "pname:size is the requested size of an allocation.",
  "PFN_vkInternalFreeNotification": "Application-defined memory free notification function.",
  "PFN_vkInternalFreeNotification.allocationScope": "pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described <<memory-host-allocation-scope,here>>.",
  "PFN_vkInternalFreeNotification.allocationType": "pname:allocationType is the requested type of an allocation.",
  "PFN_vkInternalFreeNotification.pUserData": "pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.",
  "PFN_vkInternalFreeNotification.size": "pname:size is the requested size of an allocation.",
  "PFN_vkReallocationFunction": "Application-defined memory reallocation function.",
  "PFN_vkReallocationFunction.alignment": "pname:alignment is the requested alignment of the allocation in bytes and must: be a power of two.",
  "PFN_vkReallocationFunction.allocationScope": "pname:allocationScope is a elink:VkSystemAllocationScope value specifying the allocation scope of the lifetime of the allocation, as described <<memory-host-allocation-scope,here>>.",
  "PFN_vkReallocationFunction.pOriginal": "pname:pOriginal must: be either `NULL` or a pointer previously returned by pname:pfnReallocation or pname:pfnAllocation of the same allocator.",
  "PFN_vkReallocationFunction.pUserData": "pname:pUserData is the value specified for slink:VkAllocationCallbacks::pname:pUserData in the allocator specified by the application.",
  "PFN_vkReallocationFunction.size": "pname:size is the size in bytes of the requested allocation.",
  "PFN_vkVoidFunction": "Dummy function pointer type returned by queries.",
  "RROutput": "",
  "SECURITY_ATTRIBUTES": "",
  "size_t": "",
  "uint32_t": "",
  "uint64_t": "",
  "uint8_t": "",
  "VisualID": "",
  "VkAccessFlagBits": "Bitmask specifying memory access types that will participate in a memory dependency.",
  "VkAccessFlags": "",
  "VkAccessFlags.__none": "",
  "VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT": "",
  "VkAccessFlags.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX": "",
  "VkAccessFlags.VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX": "",
  "VkAccessFlags.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_HOST_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_HOST_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_INDEX_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_INDIRECT_COMMAND_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_MEMORY_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_MEMORY_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_SHADER_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_SHADER_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_TRANSFER_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_TRANSFER_WRITE_BIT": "",
  "VkAccessFlags.VK_ACCESS_UNIFORM_READ_BIT": "",
  "VkAccessFlags.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT": "",
  "vkAcquireNextImage2KHX": "Retrieve the index of the next available presentable image.",
  "vkAcquireNextImage2KHX.device": "",
  "vkAcquireNextImage2KHX.pAcquireInfo": "",
  "vkAcquireNextImage2KHX.pImageIndex": "",
  "VkAcquireNextImageInfoKHX": "Structure specifying parameters of the acquire.",
  "VkAcquireNextImageInfoKHX.deviceMask": "pname:deviceMask is a mask of physical devices for which the swapchain image will be ready to use when the semaphore or fence is signaled.",
  "VkAcquireNextImageInfoKHX.fence": "pname:fence is code:VK_NULL_HANDLE or a fence to signal.",
  "VkAcquireNextImageInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkAcquireNextImageInfoKHX.semaphore": "pname:semaphore is code:VK_NULL_HANDLE or a semaphore to signal.",
  "VkAcquireNextImageInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkAcquireNextImageInfoKHX.swapchain": "pname:swapchain is the swapchain from which an image is being acquired.",
  "VkAcquireNextImageInfoKHX.timeout": "pname:timeout indicates how long the function waits, in nanoseconds, if no image is available.",
  "vkAcquireNextImageKHR": "Retrieve the index of the next available presentable image.",
  "vkAcquireNextImageKHR.device": "",
  "vkAcquireNextImageKHR.fence": "",
  "vkAcquireNextImageKHR.pImageIndex": "",
  "vkAcquireNextImageKHR.semaphore": "",
  "vkAcquireNextImageKHR.swapchain": "",
  "vkAcquireNextImageKHR.timeout": "",
  "vkAcquireXlibDisplayEXT": "Acquire access to a VkDisplayKHR using Xlib.",
  "vkAcquireXlibDisplayEXT.display": "",
  "vkAcquireXlibDisplayEXT.dpy": "",
  "vkAcquireXlibDisplayEXT.physicalDevice": "",
  "vkAllocateCommandBuffers": "Allocate command buffers from an existing command pool.",
  "vkAllocateCommandBuffers.device": "",
  "vkAllocateCommandBuffers.pAllocateInfo": "",
  "vkAllocateCommandBuffers.pCommandBuffers": "",
  "vkAllocateDescriptorSets": "Allocate one or more descriptor sets.",
  "vkAllocateDescriptorSets.device": "",
  "vkAllocateDescriptorSets.pAllocateInfo": "",
  "vkAllocateDescriptorSets.pDescriptorSets": "",
  "vkAllocateMemory": "Allocate GPU memory.",
  "vkAllocateMemory.device": "",
  "vkAllocateMemory.pAllocateInfo": "",
  "vkAllocateMemory.pAllocator": "",
  "vkAllocateMemory.pMemory": "",
  "VkAllocationCallbacks": "Structure containing callback function pointers for memory allocation.",
  "VkAllocationCallbacks.pfnAllocation": "pname:pfnAllocation is a pointer to an application-defined memory allocation function of type tlink:PFN_vkAllocationFunction.",
  "VkAllocationCallbacks.pfnFree": "pname:pfnFree is a pointer to an application-defined memory free function of type tlink:PFN_vkFreeFunction.",
  "VkAllocationCallbacks.pfnInternalAllocation": "pname:pfnInternalAllocation is a pointer to an application-defined function that is called by the implementation when the implementation makes internal allocations, and it is of type tlink:PFN_vkInternalAllocationNotification.",
  "VkAllocationCallbacks.pfnInternalFree": "pname:pfnInternalFree is a pointer to an application-defined function that is called by the implementation when the implementation frees internal allocations, and it is of type tlink:PFN_vkInternalFreeNotification.",
  "VkAllocationCallbacks.pfnReallocation": "pname:pfnReallocation is a pointer to an application-defined memory reallocation function of type tlink:PFN_vkReallocationFunction.",
  "VkAllocationCallbacks.pUserData": "pname:pUserData is a value to be interpreted by the implementation of the callbacks. When any of the callbacks in sname:VkAllocationCallbacks are called, the Vulkan implementation will pass this value as the first parameter to the callback. This value can: vary each time an allocator is passed into a command, even when the same object takes an allocator in multiple commands.",
  "VkAndroidSurfaceCreateFlagsKHR": "",
  "VkAndroidSurfaceCreateFlagsKHR.__none": "",
  "VkAndroidSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Android surface object.",
  "VkAndroidSurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkAndroidSurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkAndroidSurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkAndroidSurfaceCreateInfoKHR.window": "pname:window is a pointer to the code:ANativeWindow to associate the surface with.",
  "VkApplicationInfo": "Structure specifying application info.",
  "VkApplicationInfo.apiVersion": "pname:apiVersion is the version of the Vulkan API against which the application expects to run, encoded as described in the <<fundamentals-versionnum,API Version Numbers and Semantics>> section. If pname:apiVersion is 0 the implementation must: ignore it, otherwise if the implementation does not support the requested pname:apiVersion it must: return ename:VK_ERROR_INCOMPATIBLE_DRIVER. The patch version number specified in pname:apiVersion is ignored when creating an instance object. Only the major and minor versions of the instance must: match those requested in pname:apiVersion.",
  "VkApplicationInfo.applicationVersion": "pname:applicationVersion is an unsigned integer variable containing the developer-supplied version number of the application.",
  "VkApplicationInfo.engineVersion": "pname:engineVersion is an unsigned integer variable containing the developer-supplied version number of the engine used to create the application.",
  "VkApplicationInfo.pApplicationName": "pname:pApplicationName is a pointer to a null-terminated UTF-8 string containing the name of the application.",
  "VkApplicationInfo.pEngineName": "pname:pEngineName is a pointer to a null-terminated UTF-8 string containing the name of the engine (if any) used to create the application.",
  "VkApplicationInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkApplicationInfo.sType": "pname:sType is the type of this structure.",
  "VkAttachmentDescription": "Structure specifying an attachment description.",
  "VkAttachmentDescription.finalLayout": "",
  "VkAttachmentDescription.flags": "pname:flags is a bitmask describing additional properties of the attachment. Bits which can: be set include: + --",
  "VkAttachmentDescription.format": "",
  "VkAttachmentDescription.initialLayout": "",
  "VkAttachmentDescription.loadOp": "",
  "VkAttachmentDescription.samples": "",
  "VkAttachmentDescription.stencilLoadOp": "",
  "VkAttachmentDescription.stencilStoreOp": "",
  "VkAttachmentDescription.storeOp": "",
  "VkAttachmentDescriptionFlagBits": "Bitmask specifying additional properties of an attachment.",
  "VkAttachmentDescriptionFlags": "",
  "VkAttachmentDescriptionFlags.__none": "",
  "VkAttachmentDescriptionFlags.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT": "",
  "VkAttachmentLoadOp": "Specify how contents of an attachment are treated at the beginning of a subpass.",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_CLEAR": "",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_DONT_CARE": "",
  "VkAttachmentLoadOp.VK_ATTACHMENT_LOAD_OP_LOAD": "",
  "VkAttachmentReference": "Structure specifying an attachment reference.",
  "VkAttachmentReference.attachment": "pname:attachment is the index of the attachment of the render pass, and corresponds to the index of the corresponding element in the pname:pAttachments array of the sname:VkRenderPassCreateInfo structure. If any color or depth/stencil attachments are ename:VK_ATTACHMENT_UNUSED, then no writes occur for those attachments.",
  "VkAttachmentReference.layout": "pname:layout is a elink:VkImageLayout value specifying the layout the attachment uses during the subpass.",
  "VkAttachmentStoreOp": "Specify how contents of an attachment are treated at the end of a subpass.",
  "VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_DONT_CARE": "",
  "VkAttachmentStoreOp.VK_ATTACHMENT_STORE_OP_STORE": "",
  "vkBeginCommandBuffer": "Start recording a command buffer.",
  "vkBeginCommandBuffer.commandBuffer": "",
  "vkBeginCommandBuffer.pBeginInfo": "",
  "vkBindBufferMemory": "Bind device memory to a buffer object.",
  "vkBindBufferMemory.buffer": "",
  "vkBindBufferMemory.device": "",
  "vkBindBufferMemory.memory": "",
  "vkBindBufferMemory.memoryOffset": "",
  "vkBindBufferMemory2KHX": "Bind device memory to buffer objects.",
  "vkBindBufferMemory2KHX.bindInfoCount": "",
  "vkBindBufferMemory2KHX.device": "",
  "vkBindBufferMemory2KHX.pBindInfos": "",
  "VkBindBufferMemoryInfoKHX": "Structure specifying how to bind a buffer to memory.",
  "VkBindBufferMemoryInfoKHX.buffer": "pname:buffer is the buffer to be attached to memory.",
  "VkBindBufferMemoryInfoKHX.deviceIndexCount": "pname:deviceIndexCount is the number of elements in pname:pDeviceIndices.",
  "VkBindBufferMemoryInfoKHX.memory": "pname:memory is a sname:VkDeviceMemory object describing the device memory to attach.",
  "VkBindBufferMemoryInfoKHX.memoryOffset": "pname:memoryOffset is the start offset of the region of pname:memory which is to be bound to the buffer. The number of bytes returned in the sname:VkMemoryRequirements::pname:size member in pname:memory, starting from pname:memoryOffset bytes, will be bound to the specified buffer.",
  "VkBindBufferMemoryInfoKHX.pDeviceIndices": "pname:pDeviceIndices is a pointer to an array of device indices.",
  "VkBindBufferMemoryInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBindBufferMemoryInfoKHX.sType": "pname:sType is the type of this structure.",
  "vkBindImageMemory": "Bind device memory to an image object.",
  "vkBindImageMemory.device": "",
  "vkBindImageMemory.image": "",
  "vkBindImageMemory.memory": "",
  "vkBindImageMemory.memoryOffset": "",
  "vkBindImageMemory2KHX": "Bind device memory to image objects.",
  "vkBindImageMemory2KHX.bindInfoCount": "",
  "vkBindImageMemory2KHX.device": "",
  "vkBindImageMemory2KHX.pBindInfos": "",
  "VkBindImageMemoryInfoKHX": "Structure specifying how to bind an image to memory.",
  "VkBindImageMemoryInfoKHX.deviceIndexCount": "pname:deviceIndexCount is the number of elements in pname:pDeviceIndices.",
  "VkBindImageMemoryInfoKHX.image": "pname:image is the image to be attached to memory.",
  "VkBindImageMemoryInfoKHX.memory": "pname:memory is a sname:VkDeviceMemory object describing the device memory to attach.",
  "VkBindImageMemoryInfoKHX.memoryOffset": "pname:memoryOffset is the start offset of the region of pname:memory which is to be bound to the image. If pname:SFRRectCount is zero, the number of bytes returned in the sname:VkMemoryRequirements::pname:size member in pname:memory, starting from pname:memoryOffset bytes, will be bound to the specified image.",
  "VkBindImageMemoryInfoKHX.pDeviceIndices": "pname:pDeviceIndices is a pointer to an array of device indices.",
  "VkBindImageMemoryInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBindImageMemoryInfoKHX.pSFRRects": "pname:pSFRRects is a pointer to an array of rectangles describing which regions of the image are attached to each instance of memory.",
  "VkBindImageMemoryInfoKHX.SFRRectCount": "pname:SFRRectCount is the number of elements in pname:pSFRRects.",
  "VkBindImageMemoryInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkBindImageMemorySwapchainInfoKHX": "Structure specifying swapchain image memory to bind to.",
  "VkBindImageMemorySwapchainInfoKHX.imageIndex": "pname:imageIndex is an image index within pname:swapchain.",
  "VkBindImageMemorySwapchainInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBindImageMemorySwapchainInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkBindImageMemorySwapchainInfoKHX.swapchain": "pname:swapchain is dlink:VK_NULL_HANDLE or a swapchain handle.",
  "VkBindSparseInfo": "Structure specifying a sparse binding operation.",
  "VkBindSparseInfo.bufferBindCount": "pname:bufferBindCount is the number of sparse buffer bindings to perform in the batch.",
  "VkBindSparseInfo.imageBindCount": "pname:imageBindCount is the number of sparse image bindings to perform.",
  "VkBindSparseInfo.imageOpaqueBindCount": "pname:imageOpaqueBindCount is the number of opaque sparse image bindings to perform.",
  "VkBindSparseInfo.pBufferBinds": "pname:pBufferBinds is a pointer to an array of slink:VkSparseBufferMemoryBindInfo structures.",
  "VkBindSparseInfo.pImageBinds": "pname:pImageBinds is a pointer to an array of slink:VkSparseImageMemoryBindInfo structures, indicating sparse image bindings to perform.",
  "VkBindSparseInfo.pImageOpaqueBinds": "pname:pImageOpaqueBinds is a pointer to an array of slink:VkSparseImageOpaqueMemoryBindInfo structures, indicating opaque sparse image bindings to perform.",
  "VkBindSparseInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBindSparseInfo.pSignalSemaphores": "pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the sparse binding operations for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.",
  "VkBindSparseInfo.pWaitSemaphores": "pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait on before the sparse binding operations for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.",
  "VkBindSparseInfo.signalSemaphoreCount": "pname:signalSemaphoreCount is the number of semaphores to be signaled once the sparse binding operations specified by the structure have completed execution.",
  "VkBindSparseInfo.sType": "pname:sType is the type of this structure.",
  "VkBindSparseInfo.waitSemaphoreCount": "pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the sparse binding operations for the batch.",
  "VkBlendFactor": "Framebuffer blending factors.",
  "VkBlendFactor.VK_BLEND_FACTOR_CONSTANT_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_CONSTANT_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_DST_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_DST_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_ALPHA_SATURATE": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC1_ALPHA": "",
  "VkBlendFactor.VK_BLEND_FACTOR_SRC1_COLOR": "",
  "VkBlendFactor.VK_BLEND_FACTOR_ZERO": "",
  "VkBlendOp": "Framebuffer blending operations.",
  "VkBlendOp.VK_BLEND_OP_ADD": "",
  "VkBlendOp.VK_BLEND_OP_BLUE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_COLORBURN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_COLORDODGE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_CONTRAST_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DARKEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DIFFERENCE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_ATOP_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_IN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_OUT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_DST_OVER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_EXCLUSION_EXT": "",
  "VkBlendOp.VK_BLEND_OP_GREEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HARDLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HARDMIX_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_COLOR_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_HUE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_LUMINOSITY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_HSL_SATURATION_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_OVG_EXT": "",
  "VkBlendOp.VK_BLEND_OP_INVERT_RGB_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LIGHTEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARBURN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARDODGE_EXT": "",
  "VkBlendOp.VK_BLEND_OP_LINEARLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MAX": "",
  "VkBlendOp.VK_BLEND_OP_MIN": "",
  "VkBlendOp.VK_BLEND_OP_MINUS_CLAMPED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MINUS_EXT": "",
  "VkBlendOp.VK_BLEND_OP_MULTIPLY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_OVERLAY_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PINLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_CLAMPED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_DARKER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_PLUS_EXT": "",
  "VkBlendOp.VK_BLEND_OP_RED_EXT": "",
  "VkBlendOp.VK_BLEND_OP_REVERSE_SUBTRACT": "",
  "VkBlendOp.VK_BLEND_OP_SCREEN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SOFTLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_ATOP_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_IN_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_OUT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SRC_OVER_EXT": "",
  "VkBlendOp.VK_BLEND_OP_SUBTRACT": "",
  "VkBlendOp.VK_BLEND_OP_VIVIDLIGHT_EXT": "",
  "VkBlendOp.VK_BLEND_OP_XOR_EXT": "",
  "VkBlendOp.VK_BLEND_OP_ZERO_EXT": "",
  "VkBlendOverlapEXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_CONJOINT_EXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_DISJOINT_EXT": "",
  "VkBlendOverlapEXT.VK_BLEND_OVERLAP_UNCORRELATED_EXT": "",
  "VkBool32": "Vulkan boolean type.",
  "VkBorderColor": "Specify border color used for texture lookups.",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE": "",
  "VkBorderColor.VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_OPAQUE_BLACK": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_OPAQUE_WHITE": "",
  "VkBorderColor.VK_BORDER_COLOR_INT_TRANSPARENT_BLACK": "",
  "VkBuffer": "Opaque handle to a buffer object.",
  "VkBufferCopy": "Structure specifying a buffer copy operation.",
  "VkBufferCopy.dstOffset": "pname:dstOffset is the starting offset in bytes from the start of pname:dstBuffer.",
  "VkBufferCopy.size": "pname:size is the number of bytes to copy.",
  "VkBufferCopy.srcOffset": "pname:srcOffset is the starting offset in bytes from the start of pname:srcBuffer.",
  "VkBufferCreateFlagBits": "Bitmask specifying additional parameters of a buffer.",
  "VkBufferCreateFlags": "",
  "VkBufferCreateFlags.__none": "",
  "VkBufferCreateFlags.VK_BUFFER_CREATE_SPARSE_ALIASED_BIT": "",
  "VkBufferCreateFlags.VK_BUFFER_CREATE_SPARSE_BINDING_BIT": "",
  "VkBufferCreateFlags.VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT": "",
  "VkBufferCreateInfo": "Structure specifying the parameters of a newly created buffer object.",
  "VkBufferCreateInfo.flags": "pname:flags is a bitmask describing additional parameters of the buffer. See elink:VkBufferCreateFlagBits below for a description of the supported bits.",
  "VkBufferCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBufferCreateInfo.pQueueFamilyIndices": "pname:pQueueFamilyIndices is a list of queue families that will access this buffer (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).",
  "VkBufferCreateInfo.queueFamilyIndexCount": "pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.",
  "VkBufferCreateInfo.sharingMode": "pname:sharingMode is the sharing mode of the buffer when it will be accessed by multiple queue families, see elink:VkSharingMode in the <<resources-sharing,Resource Sharing>> section below for supported values.",
  "VkBufferCreateInfo.size": "pname:size is the size in bytes of the buffer to be created.",
  "VkBufferCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkBufferCreateInfo.usage": "pname:usage is a bitmask describing the allowed usages of the buffer. See elink:VkBufferUsageFlagBits below for a description of the supported bits.",
  "VkBufferImageCopy": "Structure specifying a buffer image copy operation.",
  "VkBufferImageCopy.bufferImageHeight": "",
  "VkBufferImageCopy.bufferOffset": "pname:bufferOffset is the offset in bytes from the start of the buffer object where the image data is copied from or to.",
  "VkBufferImageCopy.bufferRowLength": "pname:bufferRowLength and pname:bufferImageHeight specify the data in buffer memory as a subregion of a larger two- or three-dimensional image, and control the addressing calculations of data in buffer memory. If either of these values is zero, that aspect of the buffer memory is considered to be tightly packed according to the pname:imageExtent.",
  "VkBufferImageCopy.imageExtent": "pname:imageExtent is the size in texels of the image to copy in pname:width, pname:height and pname:depth.",
  "VkBufferImageCopy.imageOffset": "pname:imageOffset selects the initial x, y, z offsets in texels of the sub-region of the source or destination image data.",
  "VkBufferImageCopy.imageSubresource": "pname:imageSubresource is a slink:VkImageSubresourceLayers used to specify the specific image subresources of the image used for the source or destination image data.",
  "VkBufferMemoryBarrier": "Structure specifying a buffer memory barrier.",
  "VkBufferMemoryBarrier.buffer": "pname:buffer is a handle to the buffer whose backing memory is affected by the barrier.",
  "VkBufferMemoryBarrier.dstAccessMask": "pname:dstAccessMask defines a <<synchronization-access-masks, destination access mask>>.",
  "VkBufferMemoryBarrier.dstQueueFamilyIndex": "pname:dstQueueFamilyIndex is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.",
  "VkBufferMemoryBarrier.offset": "pname:offset is an offset in bytes into the backing memory for pname:buffer; this is relative to the base offset as bound to the buffer (see flink:vkBindBufferMemory).",
  "VkBufferMemoryBarrier.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBufferMemoryBarrier.size": "pname:size is a size in bytes of the affected area of backing memory for pname:buffer, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer.",
  "VkBufferMemoryBarrier.srcAccessMask": "pname:srcAccessMask defines a <<synchronization-access-masks, source access mask>>.",
  "VkBufferMemoryBarrier.srcQueueFamilyIndex": "pname:srcQueueFamilyIndex is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.",
  "VkBufferMemoryBarrier.sType": "pname:sType is the type of this structure.",
  "VkBufferMemoryRequirementsInfo2KHR": "",
  "VkBufferMemoryRequirementsInfo2KHR.buffer": "",
  "VkBufferMemoryRequirementsInfo2KHR.pNext": "",
  "VkBufferMemoryRequirementsInfo2KHR.sType": "",
  "VkBufferUsageFlagBits": "Bitmask specifying allowed usage of a buffer.",
  "VkBufferUsageFlags": "",
  "VkBufferUsageFlags.__none": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_INDEX_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_DST_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_TRANSFER_SRC_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT": "",
  "VkBufferUsageFlags.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT": "",
  "VkBufferView": "Opaque handle to a buffer view object.",
  "VkBufferViewCreateFlagBits": "",
  "VkBufferViewCreateFlags": "",
  "VkBufferViewCreateFlags.__none": "",
  "VkBufferViewCreateInfo": "Structure specifying parameters of a newly created buffer view.",
  "VkBufferViewCreateInfo.buffer": "pname:buffer is a sname:VkBuffer on which the view will be created.",
  "VkBufferViewCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkBufferViewCreateInfo.format": "pname:format is a elink:VkFormat describing the format of the data elements in the buffer.",
  "VkBufferViewCreateInfo.offset": "pname:offset is an offset in bytes from the base address of the buffer. Accesses to the buffer view from shaders use addressing that is relative to this starting offset.",
  "VkBufferViewCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkBufferViewCreateInfo.range": "pname:range is a size in bytes of the buffer view. If pname:range is equal to ename:VK_WHOLE_SIZE, the range from pname:offset to the end of the buffer is used. If ename:VK_WHOLE_SIZE is used and the remaining size of the buffer is not a multiple of the element size of pname:format, then the nearest smaller multiple is used.",
  "VkBufferViewCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkClearAttachment": "Structure specifying a clear attachment.",
  "VkClearAttachment.aspectMask": "pname:aspectMask is a mask selecting the color, depth and/or stencil aspects of the attachment to be cleared. pname:aspectMask can: include ename:VK_IMAGE_ASPECT_COLOR_BIT for color attachments, ename:VK_IMAGE_ASPECT_DEPTH_BIT for depth/stencil attachments with a depth component, and ename:VK_IMAGE_ASPECT_STENCIL_BIT for depth/stencil attachments with a stencil component. If the subpass's depth/stencil attachment is ename:VK_ATTACHMENT_UNUSED, then the clear has no effect.",
  "VkClearAttachment.clearValue": "pname:clearValue is the color or depth/stencil value to clear the attachment to, as described in <<clears-values,Clear Values>> below.",
  "VkClearAttachment.colorAttachment": "pname:colorAttachment is only meaningful if ename:VK_IMAGE_ASPECT_COLOR_BIT is set in pname:aspectMask, in which case it is an index to the pname:pColorAttachments array in the slink:VkSubpassDescription structure of the current subpass which selects the color attachment to clear. If pname:colorAttachment is ename:VK_ATTACHMENT_UNUSED then the clear has no effect.",
  "VkClearColorValue": "Structure specifying a clear color value.",
  "VkClearColorValue.float32": "pname:float32 are the color clear values when the format of the image or attachment is one of the formats in the <<features-formats-numericformat, Interpretation of Numeric Format>> table other than signed integer (etext:SINT) or unsigned integer (etext:UINT). Floating point values are automatically converted to the format of the image, with the clear value being treated as linear if the image is sRGB.",
  "VkClearColorValue.int32": "pname:int32 are the color clear values when the format of the image or attachment is signed integer (etext:SINT). Signed integer values are converted to the format of the image by casting to the smaller type (with negative 32-bit values mapping to negative values in the smaller type). If the integer clear value is not representable in the target type (e.g. would overflow in conversion to that type), the clear value is undefined.",
  "VkClearColorValue.uint32": "pname:uint32 are the color clear values when the format of the image or attachment is unsigned integer (etext:UINT). Unsigned integer values are converted to the format of the image by casting to the integer type with fewer bits.",
  "VkClearDepthStencilValue": "Structure specifying a clear depth stencil value.",
  "VkClearDepthStencilValue.depth": "pname:depth is the clear value for the depth aspect of the depth/stencil attachment. It is a floating-point value which is automatically converted to the attachment's format.",
  "VkClearDepthStencilValue.stencil": "pname:stencil is the clear value for the stencil aspect of the depth/stencil attachment. It is a 32-bit integer value which is converted to the attachment's format by taking the appropriate number of LSBs.",
  "VkClearRect": "Structure specifying a clear rectangle.",
  "VkClearRect.baseArrayLayer": "pname:baseArrayLayer is the first layer to be cleared.",
  "VkClearRect.layerCount": "pname:layerCount is the number of layers to clear.",
  "VkClearRect.rect": "pname:rect is the two-dimensional region to be cleared.",
  "VkClearValue": "Structure specifying a clear value.",
  "VkClearValue.color": "pname:color specifies the color image clear values to use when clearing a color image or attachment.",
  "VkClearValue.depthStencil": "pname:depthStencil specifies the depth and stencil clear values to use when clearing a depth/stencil image or attachment.",
  "vkCmdBeginQuery": "Begin a query.",
  "vkCmdBeginQuery.commandBuffer": "",
  "vkCmdBeginQuery.flags": "",
  "vkCmdBeginQuery.query": "",
  "vkCmdBeginQuery.queryPool": "",
  "vkCmdBeginRenderPass": "Begin a new render pass.",
  "vkCmdBeginRenderPass.commandBuffer": "",
  "vkCmdBeginRenderPass.contents": "",
  "vkCmdBeginRenderPass.pRenderPassBegin": "",
  "vkCmdBindDescriptorSets": "Binds descriptor sets to a command buffer.",
  "vkCmdBindDescriptorSets.commandBuffer": "",
  "vkCmdBindDescriptorSets.descriptorSetCount": "",
  "vkCmdBindDescriptorSets.dynamicOffsetCount": "",
  "vkCmdBindDescriptorSets.firstSet": "",
  "vkCmdBindDescriptorSets.layout": "",
  "vkCmdBindDescriptorSets.pDescriptorSets": "",
  "vkCmdBindDescriptorSets.pDynamicOffsets": "",
  "vkCmdBindDescriptorSets.pipelineBindPoint": "",
  "vkCmdBindIndexBuffer": "Bind an index buffer to a command buffer.",
  "vkCmdBindIndexBuffer.buffer": "",
  "vkCmdBindIndexBuffer.commandBuffer": "",
  "vkCmdBindIndexBuffer.indexType": "",
  "vkCmdBindIndexBuffer.offset": "",
  "vkCmdBindPipeline": "Bind a pipeline object to a command buffer.",
  "vkCmdBindPipeline.commandBuffer": "",
  "vkCmdBindPipeline.pipeline": "",
  "vkCmdBindPipeline.pipelineBindPoint": "",
  "vkCmdBindVertexBuffers": "Bind vertex buffers to a command buffer.",
  "vkCmdBindVertexBuffers.bindingCount": "",
  "vkCmdBindVertexBuffers.commandBuffer": "",
  "vkCmdBindVertexBuffers.firstBinding": "",
  "vkCmdBindVertexBuffers.pBuffers": "",
  "vkCmdBindVertexBuffers.pOffsets": "",
  "vkCmdBlitImage": "Copy regions of an image, potentially performing format conversion,.",
  "vkCmdBlitImage.commandBuffer": "",
  "vkCmdBlitImage.dstImage": "",
  "vkCmdBlitImage.dstImageLayout": "",
  "vkCmdBlitImage.filter": "",
  "vkCmdBlitImage.pRegions": "",
  "vkCmdBlitImage.regionCount": "",
  "vkCmdBlitImage.srcImage": "",
  "vkCmdBlitImage.srcImageLayout": "",
  "vkCmdClearAttachments": "Clear regions within currently bound framebuffer attachments.",
  "vkCmdClearAttachments.attachmentCount": "",
  "vkCmdClearAttachments.commandBuffer": "",
  "vkCmdClearAttachments.pAttachments": "",
  "vkCmdClearAttachments.pRects": "",
  "vkCmdClearAttachments.rectCount": "",
  "vkCmdClearColorImage": "Clear regions of a color image.",
  "vkCmdClearColorImage.commandBuffer": "",
  "vkCmdClearColorImage.image": "",
  "vkCmdClearColorImage.imageLayout": "",
  "vkCmdClearColorImage.pColor": "",
  "vkCmdClearColorImage.pRanges": "",
  "vkCmdClearColorImage.rangeCount": "",
  "vkCmdClearDepthStencilImage": "Fill regions of a combined depth/stencil image.",
  "vkCmdClearDepthStencilImage.commandBuffer": "",
  "vkCmdClearDepthStencilImage.image": "",
  "vkCmdClearDepthStencilImage.imageLayout": "",
  "vkCmdClearDepthStencilImage.pDepthStencil": "",
  "vkCmdClearDepthStencilImage.pRanges": "",
  "vkCmdClearDepthStencilImage.rangeCount": "",
  "vkCmdCopyBuffer": "Copy data between buffer regions.",
  "vkCmdCopyBuffer.commandBuffer": "",
  "vkCmdCopyBuffer.dstBuffer": "",
  "vkCmdCopyBuffer.pRegions": "",
  "vkCmdCopyBuffer.regionCount": "",
  "vkCmdCopyBuffer.srcBuffer": "",
  "vkCmdCopyBufferToImage": "Copy data from a buffer into an image.",
  "vkCmdCopyBufferToImage.commandBuffer": "",
  "vkCmdCopyBufferToImage.dstImage": "",
  "vkCmdCopyBufferToImage.dstImageLayout": "",
  "vkCmdCopyBufferToImage.pRegions": "",
  "vkCmdCopyBufferToImage.regionCount": "",
  "vkCmdCopyBufferToImage.srcBuffer": "",
  "vkCmdCopyImage": "Copy data between images.",
  "vkCmdCopyImage.commandBuffer": "",
  "vkCmdCopyImage.dstImage": "",
  "vkCmdCopyImage.dstImageLayout": "",
  "vkCmdCopyImage.pRegions": "",
  "vkCmdCopyImage.regionCount": "",
  "vkCmdCopyImage.srcImage": "",
  "vkCmdCopyImage.srcImageLayout": "",
  "vkCmdCopyImageToBuffer": "Copy image data into a buffer.",
  "vkCmdCopyImageToBuffer.commandBuffer": "",
  "vkCmdCopyImageToBuffer.dstBuffer": "",
  "vkCmdCopyImageToBuffer.pRegions": "",
  "vkCmdCopyImageToBuffer.regionCount": "",
  "vkCmdCopyImageToBuffer.srcImage": "",
  "vkCmdCopyImageToBuffer.srcImageLayout": "",
  "vkCmdCopyQueryPoolResults": "Copy the results of queries in a query pool to a buffer object.",
  "vkCmdCopyQueryPoolResults.commandBuffer": "",
  "vkCmdCopyQueryPoolResults.dstBuffer": "",
  "vkCmdCopyQueryPoolResults.dstOffset": "",
  "vkCmdCopyQueryPoolResults.firstQuery": "",
  "vkCmdCopyQueryPoolResults.flags": "",
  "vkCmdCopyQueryPoolResults.queryCount": "",
  "vkCmdCopyQueryPoolResults.queryPool": "",
  "vkCmdCopyQueryPoolResults.stride": "",
  "vkCmdDebugMarkerBeginEXT": "Open a command buffer marker region.",
  "vkCmdDebugMarkerBeginEXT.commandBuffer": "",
  "vkCmdDebugMarkerBeginEXT.pMarkerInfo": "",
  "vkCmdDebugMarkerEndEXT": "Close a command buffer marker region.",
  "vkCmdDebugMarkerEndEXT.commandBuffer": "",
  "vkCmdDebugMarkerInsertEXT": "Insert a marker label into a command buffer.",
  "vkCmdDebugMarkerInsertEXT.commandBuffer": "",
  "vkCmdDebugMarkerInsertEXT.pMarkerInfo": "",
  "vkCmdDispatch": "Dispatch compute work items.",
  "vkCmdDispatch.commandBuffer": "",
  "vkCmdDispatch.groupCountX": "",
  "vkCmdDispatch.groupCountY": "",
  "vkCmdDispatch.groupCountZ": "",
  "vkCmdDispatchBaseKHX": "Dispatch compute work items.",
  "vkCmdDispatchBaseKHX.baseGroupX": "",
  "vkCmdDispatchBaseKHX.baseGroupY": "",
  "vkCmdDispatchBaseKHX.baseGroupZ": "",
  "vkCmdDispatchBaseKHX.commandBuffer": "",
  "vkCmdDispatchBaseKHX.groupCountX": "",
  "vkCmdDispatchBaseKHX.groupCountY": "",
  "vkCmdDispatchBaseKHX.groupCountZ": "",
  "vkCmdDispatchIndirect": "Dispatch compute work items using indirect parameters.",
  "vkCmdDispatchIndirect.buffer": "",
  "vkCmdDispatchIndirect.commandBuffer": "",
  "vkCmdDispatchIndirect.offset": "",
  "vkCmdDraw": "Draw primitives.",
  "vkCmdDraw.commandBuffer": "",
  "vkCmdDraw.firstInstance": "",
  "vkCmdDraw.firstVertex": "",
  "vkCmdDraw.instanceCount": "",
  "vkCmdDraw.vertexCount": "",
  "vkCmdDrawIndexed": "Issue an indexed draw into a command buffer.",
  "vkCmdDrawIndexed.commandBuffer": "",
  "vkCmdDrawIndexed.firstIndex": "",
  "vkCmdDrawIndexed.firstInstance": "",
  "vkCmdDrawIndexed.indexCount": "",
  "vkCmdDrawIndexed.instanceCount": "",
  "vkCmdDrawIndexed.vertexOffset": "",
  "vkCmdDrawIndexedIndirect": "Perform an indexed indirect draw.",
  "vkCmdDrawIndexedIndirect.buffer": "",
  "vkCmdDrawIndexedIndirect.commandBuffer": "",
  "vkCmdDrawIndexedIndirect.drawCount": "",
  "vkCmdDrawIndexedIndirect.offset": "",
  "vkCmdDrawIndexedIndirect.stride": "",
  "vkCmdDrawIndexedIndirectCountAMD": "Perform an indexed indirect draw with the draw count sourced from a buffer.",
  "vkCmdDrawIndexedIndirectCountAMD.buffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.commandBuffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.countBuffer": "",
  "vkCmdDrawIndexedIndirectCountAMD.countBufferOffset": "",
  "vkCmdDrawIndexedIndirectCountAMD.maxDrawCount": "",
  "vkCmdDrawIndexedIndirectCountAMD.offset": "",
  "vkCmdDrawIndexedIndirectCountAMD.stride": "",
  "vkCmdDrawIndirect": "Issue an indirect draw into a command buffer.",
  "vkCmdDrawIndirect.buffer": "",
  "vkCmdDrawIndirect.commandBuffer": "",
  "vkCmdDrawIndirect.drawCount": "",
  "vkCmdDrawIndirect.offset": "",
  "vkCmdDrawIndirect.stride": "",
  "vkCmdDrawIndirectCountAMD": "Perform an indirect draw with the draw count sourced from a buffer.",
  "vkCmdDrawIndirectCountAMD.buffer": "",
  "vkCmdDrawIndirectCountAMD.commandBuffer": "",
  "vkCmdDrawIndirectCountAMD.countBuffer": "",
  "vkCmdDrawIndirectCountAMD.countBufferOffset": "",
  "vkCmdDrawIndirectCountAMD.maxDrawCount": "",
  "vkCmdDrawIndirectCountAMD.offset": "",
  "vkCmdDrawIndirectCountAMD.stride": "",
  "vkCmdEndQuery": "Ends a query.",
  "vkCmdEndQuery.commandBuffer": "",
  "vkCmdEndQuery.query": "",
  "vkCmdEndQuery.queryPool": "",
  "vkCmdEndRenderPass": "End the current render pass.",
  "vkCmdEndRenderPass.commandBuffer": "",
  "vkCmdExecuteCommands": "Execute a secondary command buffer from a primary command buffer.",
  "vkCmdExecuteCommands.commandBuffer": "",
  "vkCmdExecuteCommands.commandBufferCount": "",
  "vkCmdExecuteCommands.pCommandBuffers": "",
  "vkCmdFillBuffer": "Fill a region of a buffer with a fixed value.",
  "vkCmdFillBuffer.commandBuffer": "",
  "vkCmdFillBuffer.data": "",
  "vkCmdFillBuffer.dstBuffer": "",
  "vkCmdFillBuffer.dstOffset": "",
  "vkCmdFillBuffer.size": "",
  "vkCmdNextSubpass": "Transition to the next subpass of a render pass.",
  "vkCmdNextSubpass.commandBuffer": "",
  "vkCmdNextSubpass.contents": "",
  "vkCmdPipelineBarrier": "Insert a memory dependency.",
  "vkCmdPipelineBarrier.bufferMemoryBarrierCount": "",
  "vkCmdPipelineBarrier.commandBuffer": "",
  "vkCmdPipelineBarrier.dependencyFlags": "",
  "vkCmdPipelineBarrier.dstStageMask": "",
  "vkCmdPipelineBarrier.imageMemoryBarrierCount": "",
  "vkCmdPipelineBarrier.memoryBarrierCount": "",
  "vkCmdPipelineBarrier.pBufferMemoryBarriers": "",
  "vkCmdPipelineBarrier.pImageMemoryBarriers": "",
  "vkCmdPipelineBarrier.pMemoryBarriers": "",
  "vkCmdPipelineBarrier.srcStageMask": "",
  "VkCmdProcessCommandsInfoNVX": "Structure specifying parameters for the generation of commands.",
  "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout": "pname:indirectCommandsLayout is the sname:VkIndirectCommandsLayoutNVX that provides the command sequence to generate.",
  "VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount": "pname:indirectCommandsTokenCount defines the number of input tokens used.",
  "VkCmdProcessCommandsInfoNVX.maxSequencesCount": "pname:maxSequencesCount is the maximum number of sequences for which command buffer space will be reserved. If pname:sequencesCountBuffer is dlink:VK_NULL_HANDLE, this is also the actual number of sequences generated.",
  "VkCmdProcessCommandsInfoNVX.objectTable": "pname:objectTable is the sname:VkObjectTableNVX to be used for the generation process. Only registered objects at the time flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.",
  "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens": "pname:pIndirectCommandsTokens provides an array of slink:VkIndirectCommandsTokenNVX that reference the input data for each token command.",
  "VkCmdProcessCommandsInfoNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer": "pname:sequencesCountBuffer can: be sname:VkBuffer from which the actual amount of sequences is sourced from as ftext:uint32_t value.",
  "VkCmdProcessCommandsInfoNVX.sequencesCountOffset": "pname:sequencesCountOffset is the byte offset into pname:sequencesCountBuffer where the count value is stored.",
  "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer": "pname:sequencesIndexBuffer must: be set if pname:indirectCommandsLayout's ename:VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT is set and provides the used sequence indices as ftext:uint32_t array. Otherwise it must: be dlink:VK_NULL_HANDLE.",
  "VkCmdProcessCommandsInfoNVX.sequencesIndexOffset": "pname:sequencesIndexOffset is the byte offset into pname:sequencesIndexBuffer where the index values start.",
  "VkCmdProcessCommandsInfoNVX.sType": "pname:sType is the type of this structure.",
  "VkCmdProcessCommandsInfoNVX.targetCommandBuffer": "pname:targetCommandBuffer can: be the secondary sname:VkCommandBuffer in which the commands should be recorded. If pname:targetCommandBuffer is `NULL` an implicit reservation as well as execution takes place on the processing sname:VkCommandBuffer.",
  "vkCmdProcessCommandsNVX": "Performs the generation of commands on the device.",
  "vkCmdProcessCommandsNVX.commandBuffer": "",
  "vkCmdProcessCommandsNVX.pProcessCommandsInfo": "",
  "vkCmdPushConstants": "Update the values of push constants.",
  "vkCmdPushConstants.commandBuffer": "",
  "vkCmdPushConstants.layout": "",
  "vkCmdPushConstants.offset": "",
  "vkCmdPushConstants.pValues": "",
  "vkCmdPushConstants.size": "",
  "vkCmdPushConstants.stageFlags": "",
  "vkCmdPushDescriptorSetKHR": "Pushes descriptor updates into a command buffer.",
  "vkCmdPushDescriptorSetKHR.commandBuffer": "",
  "vkCmdPushDescriptorSetKHR.descriptorWriteCount": "",
  "vkCmdPushDescriptorSetKHR.layout": "",
  "vkCmdPushDescriptorSetKHR.pDescriptorWrites": "",
  "vkCmdPushDescriptorSetKHR.pipelineBindPoint": "",
  "vkCmdPushDescriptorSetKHR.set": "",
  "vkCmdPushDescriptorSetWithTemplateKHR": "Pushes descriptor updates into a command buffer using a descriptor update template.",
  "vkCmdPushDescriptorSetWithTemplateKHR.commandBuffer": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.descriptorUpdateTemplate": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.layout": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.pData": "",
  "vkCmdPushDescriptorSetWithTemplateKHR.set": "",
  "VkCmdReserveSpaceForCommandsInfoNVX": "Structure specifying parameters for the reservation of command buffer space.",
  "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout": "pname:indirectCommandsLayout is the sname:VkIndirectCommandsLayoutNVX that must: also be used at generation time.",
  "VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount": "pname:maxSequencesCount is the maximum number of sequences for which command buffer space will be reserved.",
  "VkCmdReserveSpaceForCommandsInfoNVX.objectTable": "pname:objectTable is the sname:VkObjectTableNVX to be used for the generation process. Only registered objects at the time flink:vkCmdReserveSpaceForCommandsNVX is called, will be taken into account for the reservation.",
  "VkCmdReserveSpaceForCommandsInfoNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCmdReserveSpaceForCommandsInfoNVX.sType": "pname:sType is the type of this structure.",
  "vkCmdReserveSpaceForCommandsNVX": "Perform a reservation of command buffer space.",
  "vkCmdReserveSpaceForCommandsNVX.commandBuffer": "",
  "vkCmdReserveSpaceForCommandsNVX.pReserveSpaceInfo": "",
  "vkCmdResetEvent": "Reset an event object to non-signaled state.",
  "vkCmdResetEvent.commandBuffer": "",
  "vkCmdResetEvent.event": "",
  "vkCmdResetEvent.stageMask": "",
  "vkCmdResetQueryPool": "Reset queries in a query pool.",
  "vkCmdResetQueryPool.commandBuffer": "",
  "vkCmdResetQueryPool.firstQuery": "",
  "vkCmdResetQueryPool.queryCount": "",
  "vkCmdResetQueryPool.queryPool": "",
  "vkCmdResolveImage": "Resolve regions of an image.",
  "vkCmdResolveImage.commandBuffer": "",
  "vkCmdResolveImage.dstImage": "",
  "vkCmdResolveImage.dstImageLayout": "",
  "vkCmdResolveImage.pRegions": "",
  "vkCmdResolveImage.regionCount": "",
  "vkCmdResolveImage.srcImage": "",
  "vkCmdResolveImage.srcImageLayout": "",
  "vkCmdSetBlendConstants": "Set the values of blend constants.",
  "vkCmdSetBlendConstants.blendConstants": "",
  "vkCmdSetBlendConstants.commandBuffer": "",
  "vkCmdSetDepthBias": "Set the depth bias dynamic state.",
  "vkCmdSetDepthBias.commandBuffer": "",
  "vkCmdSetDepthBias.depthBiasClamp": "",
  "vkCmdSetDepthBias.depthBiasConstantFactor": "",
  "vkCmdSetDepthBias.depthBiasSlopeFactor": "",
  "vkCmdSetDepthBounds": "Set the depth bounds test values for a command buffer.",
  "vkCmdSetDepthBounds.commandBuffer": "",
  "vkCmdSetDepthBounds.maxDepthBounds": "",
  "vkCmdSetDepthBounds.minDepthBounds": "",
  "vkCmdSetDeviceMaskKHX": "Modify device mask of a command buffer.",
  "vkCmdSetDeviceMaskKHX.commandBuffer": "",
  "vkCmdSetDeviceMaskKHX.deviceMask": "",
  "vkCmdSetDiscardRectangleEXT": "",
  "vkCmdSetDiscardRectangleEXT.commandBuffer": "",
  "vkCmdSetDiscardRectangleEXT.discardRectangleCount": "",
  "vkCmdSetDiscardRectangleEXT.firstDiscardRectangle": "",
  "vkCmdSetDiscardRectangleEXT.pDiscardRectangles": "",
  "vkCmdSetEvent": "Set an event object to signaled state.",
  "vkCmdSetEvent.commandBuffer": "",
  "vkCmdSetEvent.event": "",
  "vkCmdSetEvent.stageMask": "",
  "vkCmdSetLineWidth": "Set the dynamic line width state.",
  "vkCmdSetLineWidth.commandBuffer": "",
  "vkCmdSetLineWidth.lineWidth": "",
  "vkCmdSetScissor": "Set the dynamic scissor rectangles on a command buffer.",
  "vkCmdSetScissor.commandBuffer": "",
  "vkCmdSetScissor.firstScissor": "",
  "vkCmdSetScissor.pScissors": "",
  "vkCmdSetScissor.scissorCount": "",
  "vkCmdSetStencilCompareMask": "Set the stencil compare mask dynamic state.",
  "vkCmdSetStencilCompareMask.commandBuffer": "",
  "vkCmdSetStencilCompareMask.compareMask": "",
  "vkCmdSetStencilCompareMask.faceMask": "",
  "vkCmdSetStencilReference": "Set the stencil reference dynamic state.",
  "vkCmdSetStencilReference.commandBuffer": "",
  "vkCmdSetStencilReference.faceMask": "",
  "vkCmdSetStencilReference.reference": "",
  "vkCmdSetStencilWriteMask": "Set the stencil write mask dynamic state.",
  "vkCmdSetStencilWriteMask.commandBuffer": "",
  "vkCmdSetStencilWriteMask.faceMask": "",
  "vkCmdSetStencilWriteMask.writeMask": "",
  "vkCmdSetViewport": "Set the viewport on a command buffer.",
  "vkCmdSetViewport.commandBuffer": "",
  "vkCmdSetViewport.firstViewport": "",
  "vkCmdSetViewport.pViewports": "",
  "vkCmdSetViewport.viewportCount": "",
  "vkCmdSetViewportWScalingNV": "Set the viewport W scaling on a command buffer.",
  "vkCmdSetViewportWScalingNV.commandBuffer": "",
  "vkCmdSetViewportWScalingNV.firstViewport": "",
  "vkCmdSetViewportWScalingNV.pViewportWScalings": "",
  "vkCmdSetViewportWScalingNV.viewportCount": "",
  "vkCmdUpdateBuffer": "Update a buffer's contents from host memory.",
  "vkCmdUpdateBuffer.commandBuffer": "",
  "vkCmdUpdateBuffer.dataSize": "",
  "vkCmdUpdateBuffer.dstBuffer": "",
  "vkCmdUpdateBuffer.dstOffset": "",
  "vkCmdUpdateBuffer.pData": "",
  "vkCmdWaitEvents": "Wait for one or more events and insert a set of memory.",
  "vkCmdWaitEvents.bufferMemoryBarrierCount": "",
  "vkCmdWaitEvents.commandBuffer": "",
  "vkCmdWaitEvents.dstStageMask": "",
  "vkCmdWaitEvents.eventCount": "",
  "vkCmdWaitEvents.imageMemoryBarrierCount": "",
  "vkCmdWaitEvents.memoryBarrierCount": "",
  "vkCmdWaitEvents.pBufferMemoryBarriers": "",
  "vkCmdWaitEvents.pEvents": "",
  "vkCmdWaitEvents.pImageMemoryBarriers": "",
  "vkCmdWaitEvents.pMemoryBarriers": "",
  "vkCmdWaitEvents.srcStageMask": "",
  "vkCmdWriteTimestamp": "Write a device timestamp into a query object.",
  "vkCmdWriteTimestamp.commandBuffer": "",
  "vkCmdWriteTimestamp.pipelineStage": "",
  "vkCmdWriteTimestamp.query": "",
  "vkCmdWriteTimestamp.queryPool": "",
  "VkColorComponentFlagBits": "Bitmask controlling which components are written to the framebuffer.",
  "VkColorComponentFlags": "",
  "VkColorComponentFlags.__none": "",
  "VkColorComponentFlags.VK_COLOR_COMPONENT_A_BIT": "",
  "VkColorComponentFlags.VK_COLOR_COMPONENT_B_BIT": "",
  "VkColorComponentFlags.VK_COLOR_COMPONENT_G_BIT": "",
  "VkColorComponentFlags.VK_COLOR_COMPONENT_R_BIT": "",
  "VkColorSpaceKHR": "Supported color space of the presentation engine.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT": "* ename:VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT - supports the AdobeRGB color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT": "* ename:VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT - supports the AdobeRGB color space and applies the Gamma 2.2 OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT2020_LINEAR_EXT": "* ename:VK_COLOR_SPACE_BT2020_LINEAR_EXT - supports the BT2020 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT709_LINEAR_EXT": "* ename:VK_COLOR_SPACE_BT709_LINEAR_EXT - supports the BT709 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_BT709_NONLINEAR_EXT": "* ename:VK_COLOR_SPACE_BT709_NONLINEAR_EXT - supports the BT709 color space and applies the SMPTE 170M OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_LINEAR_EXT": "* ename:VK_COLOR_SPACE_DCI_P3_LINEAR_EXT - supports the DCI-P3 color space and applies a linear OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT": "* ename:VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT - supports the DCI-P3 color space and applies the Gamma 2.6 OETF.",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_DOLBYVISION_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_HLG_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_ST2084_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_PASS_THROUGH_EXT": "",
  "VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR": "ename:VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: The presentation engine supports the sRGB color space.",
  "VkCommandBuffer": "Opaque handle to a command buffer object.",
  "VkCommandBufferAllocateInfo": "Structure specifying the allocation parameters for command buffer object.",
  "VkCommandBufferAllocateInfo.commandBufferCount": "",
  "VkCommandBufferAllocateInfo.commandPool": "pname:commandPool is the command pool from which the command buffers are allocated.",
  "VkCommandBufferAllocateInfo.level": "pname:level determines whether the command buffers are primary or secondary command buffers. Possible values include: + --",
  "VkCommandBufferAllocateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCommandBufferAllocateInfo.sType": "pname:sType is the type of this structure.",
  "VkCommandBufferBeginInfo": "Structure specifying a command buffer begin operation.",
  "VkCommandBufferBeginInfo.flags": "pname:flags is a bitmask indicating usage behavior for the command buffer. Bits which can: be set include: + --",
  "VkCommandBufferBeginInfo.pInheritanceInfo": "",
  "VkCommandBufferBeginInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCommandBufferBeginInfo.sType": "pname:sType is the type of this structure.",
  "VkCommandBufferInheritanceInfo": "Structure specifying command buffer inheritance info.",
  "VkCommandBufferInheritanceInfo.framebuffer": "pname:framebuffer optionally refers to the sname:VkFramebuffer object that the sname:VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can: be dlink:VK_NULL_HANDLE if the framebuffer is not known, or if the sname:VkCommandBuffer will not be executed within a render pass instance. + [NOTE] .Note ==== Specifying the exact framebuffer that the secondary command buffer will be executed with may: result in better performance at command buffer execution time. ====",
  "VkCommandBufferInheritanceInfo.occlusionQueryEnable": "pname:occlusionQueryEnable indicates whether the command buffer can: be executed while an occlusion query is active in the primary command buffer. If this is ename:VK_TRUE, then this command buffer can: be executed whether the primary command buffer has an occlusion query active or not. If this is ename:VK_FALSE, then the primary command buffer must: not have an occlusion query active.",
  "VkCommandBufferInheritanceInfo.pipelineStatistics": "pname:pipelineStatistics indicates the set of pipeline statistics that can: be counted by an active query in the primary command buffer when this secondary command buffer is executed. If this value includes a given bit, then this command buffer can: be executed whether the primary command buffer has a pipeline statistics query active that includes this bit or not. If this value excludes a given bit, then the active pipeline statistics query must: not be from a query pool that counts that statistic.",
  "VkCommandBufferInheritanceInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCommandBufferInheritanceInfo.queryFlags": "pname:queryFlags indicates the query flags that can: be used by an active occlusion query in the primary command buffer when this secondary command buffer is executed. If this value includes the ename:VK_QUERY_CONTROL_PRECISE_BIT bit, then the active query can: return boolean results or actual sample counts. If this bit is not set, then the active query must: not use the ename:VK_QUERY_CONTROL_PRECISE_BIT bit.",
  "VkCommandBufferInheritanceInfo.renderPass": "pname:renderPass is a sname:VkRenderPass object defining which render passes the sname:VkCommandBuffer will be <<renderpass-compatibility, compatible>> with and can: be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:renderPass is ignored.",
  "VkCommandBufferInheritanceInfo.sType": "pname:sType is the type of this structure.",
  "VkCommandBufferInheritanceInfo.subpass": "pname:subpass is the index of the subpass within the render pass instance that the sname:VkCommandBuffer will be executed within. If the sname:VkCommandBuffer will not be executed within a render pass instance, pname:subpass is ignored.",
  "VkCommandBufferLevel": "Structure specifying a command buffer level.",
  "VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_PRIMARY": "",
  "VkCommandBufferLevel.VK_COMMAND_BUFFER_LEVEL_SECONDARY": "",
  "VkCommandBufferResetFlagBits": "Bitmask controlling behavior of a command buffer reset.",
  "VkCommandBufferResetFlags": "",
  "VkCommandBufferResetFlags.__none": "",
  "VkCommandBufferResetFlags.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT": "",
  "VkCommandBufferUsageFlagBits": "Bitmask specifying usage behavior for command buffer.",
  "VkCommandBufferUsageFlags": "",
  "VkCommandBufferUsageFlags.__none": "",
  "VkCommandBufferUsageFlags.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT": "",
  "VkCommandBufferUsageFlags.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT": "",
  "VkCommandBufferUsageFlags.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT": "",
  "VkCommandPool": "Opaque handle to a command pool object.",
  "VkCommandPoolCreateFlagBits": "Bitmask specifying usage behavior for a command pool.",
  "VkCommandPoolCreateFlags": "",
  "VkCommandPoolCreateFlags.__none": "",
  "VkCommandPoolCreateFlags.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT": "",
  "VkCommandPoolCreateFlags.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT": "",
  "VkCommandPoolCreateInfo": "Structure specifying parameters of a newly created command pool.",
  "VkCommandPoolCreateInfo.flags": "pname:flags is a bitmask indicating usage behavior for the pool and command buffers allocated from it. Bits which can: be set include: + --",
  "VkCommandPoolCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCommandPoolCreateInfo.queueFamilyIndex": "",
  "VkCommandPoolCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkCommandPoolResetFlagBits": "Bitmask controlling behavior of a command pool reset.",
  "VkCommandPoolResetFlags": "",
  "VkCommandPoolResetFlags.__none": "",
  "VkCommandPoolResetFlags.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT": "",
  "VkCommandPoolTrimFlagsKHR": "",
  "VkCommandPoolTrimFlagsKHR.__none": "",
  "VkCompareOp": "Stencil comparison function.",
  "VkCompareOp.VK_COMPARE_OP_ALWAYS": "ename:VK_COMPARE_OP_ALWAYS: the test always passes.",
  "VkCompareOp.VK_COMPARE_OP_EQUAL": "ename:VK_COMPARE_OP_EQUAL: the test passes when [eq]#R = S#.",
  "VkCompareOp.VK_COMPARE_OP_GREATER": "ename:VK_COMPARE_OP_GREATER: the test passes when [eq]#R > S#.",
  "VkCompareOp.VK_COMPARE_OP_GREATER_OR_EQUAL": "ename:VK_COMPARE_OP_GREATER_OR_EQUAL: the test passes when [eq]#R {geq} S#.",
  "VkCompareOp.VK_COMPARE_OP_LESS": "ename:VK_COMPARE_OP_LESS: the test passes when [eq]#R < S#.",
  "VkCompareOp.VK_COMPARE_OP_LESS_OR_EQUAL": "ename:VK_COMPARE_OP_LESS_OR_EQUAL: the test passes when [eq]#R {leq} S#.",
  "VkCompareOp.VK_COMPARE_OP_NEVER": "ename:VK_COMPARE_OP_NEVER: the test never passes.",
  "VkCompareOp.VK_COMPARE_OP_NOT_EQUAL": "ename:VK_COMPARE_OP_NOT_EQUAL: the test passes when [eq]#R {neq} S#.",
  "VkComponentMapping": "Structure specifying a color component mapping.",
  "VkComponentMapping.a": "pname:a determines the component value placed in the A component of the output vector.",
  "VkComponentMapping.b": "pname:b determines the component value placed in the B component of the output vector.",
  "VkComponentMapping.g": "pname:g determines the component value placed in the G component of the output vector.",
  "VkComponentMapping.r": "pname:r determines the component value placed in the R component of the output vector.",
  "VkComponentSwizzle": "Specify how a component is swizzled.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_A": "ename:VK_COMPONENT_SWIZZLE_A: the component is set to the value of the A component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_B": "ename:VK_COMPONENT_SWIZZLE_B: the component is set to the value of the B component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_G": "ename:VK_COMPONENT_SWIZZLE_G: the component is set to the value of the G component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_IDENTITY": "ename:VK_COMPONENT_SWIZZLE_IDENTITY: the component is set to the identity swizzle.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_ONE": "ename:VK_COMPONENT_SWIZZLE_ONE: the component is set to either 1 or 1.0 depending on whether the type of the image view format is integer or floating-point respectively, as determined by the <<features-formats-definition,Format Definition>> section for each elink:VkFormat.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_R": "ename:VK_COMPONENT_SWIZZLE_R: the component is set to the value of the R component of the image.",
  "VkComponentSwizzle.VK_COMPONENT_SWIZZLE_ZERO": "ename:VK_COMPONENT_SWIZZLE_ZERO: the component is set to zero.",
  "VkCompositeAlphaFlagBitsKHR": "Alpha compositing modes supported on a device.",
  "VkCompositeAlphaFlagsKHR": "",
  "VkCompositeAlphaFlagsKHR.__none": "",
  "VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR": "",
  "VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR": "",
  "VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR": "",
  "VkCompositeAlphaFlagsKHR.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR": "",
  "VkComputePipelineCreateInfo": "Structure specifying parameters of a newly created compute pipeline.",
  "VkComputePipelineCreateInfo.basePipelineHandle": "pname:basePipelineHandle is a pipeline to derive from",
  "VkComputePipelineCreateInfo.basePipelineIndex": "pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from",
  "VkComputePipelineCreateInfo.flags": "pname:flags provides options for pipeline creation, and is of type elink:VkPipelineCreateFlagBits.",
  "VkComputePipelineCreateInfo.layout": "pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.",
  "VkComputePipelineCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkComputePipelineCreateInfo.stage": "pname:stage is a slink:VkPipelineShaderStageCreateInfo describing the compute shader.",
  "VkComputePipelineCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkCopyDescriptorSet": "Structure specifying a copy descriptor set operation.",
  "VkCopyDescriptorSet.descriptorCount": "pname:descriptorCount is the number of descriptors to copy from the source to destination. If pname:descriptorCount is greater than the number of remaining array elements in the source or destination binding, those affect consecutive bindings in a manner similar to slink:VkWriteDescriptorSet above.",
  "VkCopyDescriptorSet.dstArrayElement": "",
  "VkCopyDescriptorSet.dstBinding": "",
  "VkCopyDescriptorSet.dstSet": "pname:dstSet, pname:dstBinding, and pname:dstArrayElement are the destination set, binding, and array element, respectively.",
  "VkCopyDescriptorSet.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkCopyDescriptorSet.srcArrayElement": "",
  "VkCopyDescriptorSet.srcBinding": "",
  "VkCopyDescriptorSet.srcSet": "pname:srcSet, pname:srcBinding, and pname:srcArrayElement are the source set, binding, and array element, respectively.",
  "VkCopyDescriptorSet.sType": "pname:sType is the type of this structure.",
  "VkCoverageModulationModeNV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_ALPHA_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_NONE_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_RGB_NV": "",
  "VkCoverageModulationModeNV.VK_COVERAGE_MODULATION_MODE_RGBA_NV": "",
  "vkCreateAndroidSurfaceKHR": "Create a slink:VkSurfaceKHR object for an Android native window.",
  "vkCreateAndroidSurfaceKHR.instance": "",
  "vkCreateAndroidSurfaceKHR.pAllocator": "",
  "vkCreateAndroidSurfaceKHR.pCreateInfo": "",
  "vkCreateAndroidSurfaceKHR.pSurface": "",
  "vkCreateBuffer": "Create a new buffer object.",
  "vkCreateBuffer.device": "",
  "vkCreateBuffer.pAllocator": "",
  "vkCreateBuffer.pBuffer": "",
  "vkCreateBuffer.pCreateInfo": "",
  "vkCreateBufferView": "Create a new buffer view object.",
  "vkCreateBufferView.device": "",
  "vkCreateBufferView.pAllocator": "",
  "vkCreateBufferView.pCreateInfo": "",
  "vkCreateBufferView.pView": "",
  "vkCreateCommandPool": "Create a new command pool object.",
  "vkCreateCommandPool.device": "",
  "vkCreateCommandPool.pAllocator": "",
  "vkCreateCommandPool.pCommandPool": "",
  "vkCreateCommandPool.pCreateInfo": "",
  "vkCreateComputePipelines": "Creates a new compute pipeline object.",
  "vkCreateComputePipelines.createInfoCount": "",
  "vkCreateComputePipelines.device": "",
  "vkCreateComputePipelines.pAllocator": "",
  "vkCreateComputePipelines.pCreateInfos": "",
  "vkCreateComputePipelines.pipelineCache": "",
  "vkCreateComputePipelines.pPipelines": "",
  "vkCreateDebugReportCallbackEXT": "Create a debug report callback object.",
  "vkCreateDebugReportCallbackEXT.instance": "",
  "vkCreateDebugReportCallbackEXT.pAllocator": "",
  "vkCreateDebugReportCallbackEXT.pCallback": "",
  "vkCreateDebugReportCallbackEXT.pCreateInfo": "",
  "vkCreateDescriptorPool": "Creates a descriptor pool object.",
  "vkCreateDescriptorPool.device": "",
  "vkCreateDescriptorPool.pAllocator": "",
  "vkCreateDescriptorPool.pCreateInfo": "",
  "vkCreateDescriptorPool.pDescriptorPool": "",
  "vkCreateDescriptorSetLayout": "Create a new descriptor set layout.",
  "vkCreateDescriptorSetLayout.device": "",
  "vkCreateDescriptorSetLayout.pAllocator": "",
  "vkCreateDescriptorSetLayout.pCreateInfo": "",
  "vkCreateDescriptorSetLayout.pSetLayout": "",
  "vkCreateDescriptorUpdateTemplateKHR": "Create a new descriptor update template.",
  "vkCreateDescriptorUpdateTemplateKHR.device": "",
  "vkCreateDescriptorUpdateTemplateKHR.pAllocator": "",
  "vkCreateDescriptorUpdateTemplateKHR.pCreateInfo": "",
  "vkCreateDescriptorUpdateTemplateKHR.pDescriptorUpdateTemplate": "",
  "vkCreateDevice": "Create a new device instance.",
  "vkCreateDevice.pAllocator": "",
  "vkCreateDevice.pCreateInfo": "",
  "vkCreateDevice.pDevice": "",
  "vkCreateDevice.physicalDevice": "",
  "vkCreateDisplayModeKHR": "Create a display mode.",
  "vkCreateDisplayModeKHR.display": "",
  "vkCreateDisplayModeKHR.pAllocator": "",
  "vkCreateDisplayModeKHR.pCreateInfo": "",
  "vkCreateDisplayModeKHR.physicalDevice": "",
  "vkCreateDisplayModeKHR.pMode": "",
  "vkCreateDisplayPlaneSurfaceKHR": "Create a slink:VkSurfaceKHR structure representing a display plane and mode.",
  "vkCreateDisplayPlaneSurfaceKHR.instance": "",
  "vkCreateDisplayPlaneSurfaceKHR.pAllocator": "",
  "vkCreateDisplayPlaneSurfaceKHR.pCreateInfo": "",
  "vkCreateDisplayPlaneSurfaceKHR.pSurface": "",
  "vkCreateEvent": "Create a new event object.",
  "vkCreateEvent.device": "",
  "vkCreateEvent.pAllocator": "",
  "vkCreateEvent.pCreateInfo": "",
  "vkCreateEvent.pEvent": "",
  "vkCreateFence": "Create a new fence object.",
  "vkCreateFence.device": "",
  "vkCreateFence.pAllocator": "",
  "vkCreateFence.pCreateInfo": "",
  "vkCreateFence.pFence": "",
  "vkCreateFramebuffer": "Create a new framebuffer object.",
  "vkCreateFramebuffer.device": "",
  "vkCreateFramebuffer.pAllocator": "",
  "vkCreateFramebuffer.pCreateInfo": "",
  "vkCreateFramebuffer.pFramebuffer": "",
  "vkCreateGraphicsPipelines": "Create graphics pipelines.",
  "vkCreateGraphicsPipelines.createInfoCount": "",
  "vkCreateGraphicsPipelines.device": "",
  "vkCreateGraphicsPipelines.pAllocator": "",
  "vkCreateGraphicsPipelines.pCreateInfos": "",
  "vkCreateGraphicsPipelines.pipelineCache": "",
  "vkCreateGraphicsPipelines.pPipelines": "",
  "vkCreateImage": "Create a new image object.",
  "vkCreateImage.device": "",
  "vkCreateImage.pAllocator": "",
  "vkCreateImage.pCreateInfo": "",
  "vkCreateImage.pImage": "",
  "vkCreateImageView": "Create an image view from an existing image.",
  "vkCreateImageView.device": "",
  "vkCreateImageView.pAllocator": "",
  "vkCreateImageView.pCreateInfo": "",
  "vkCreateImageView.pView": "",
  "vkCreateIndirectCommandsLayoutNVX": "",
  "vkCreateIndirectCommandsLayoutNVX.device": "",
  "vkCreateIndirectCommandsLayoutNVX.pAllocator": "",
  "vkCreateIndirectCommandsLayoutNVX.pCreateInfo": "",
  "vkCreateIndirectCommandsLayoutNVX.pIndirectCommandsLayout": "",
  "vkCreateInstance": "Create a new Vulkan instance.",
  "vkCreateInstance.pAllocator": "",
  "vkCreateInstance.pCreateInfo": "",
  "vkCreateInstance.pInstance": "",
  "vkCreateIOSSurfaceMVK": "Create a slink:VkSurfaceKHR object for an iOS UIView.",
  "vkCreateIOSSurfaceMVK.instance": "",
  "vkCreateIOSSurfaceMVK.pAllocator": "",
  "vkCreateIOSSurfaceMVK.pCreateInfo": "",
  "vkCreateIOSSurfaceMVK.pSurface": "",
  "vkCreateMacOSSurfaceMVK": "Create a slink:VkSurfaceKHR object for a macOS NSView.",
  "vkCreateMacOSSurfaceMVK.instance": "",
  "vkCreateMacOSSurfaceMVK.pAllocator": "",
  "vkCreateMacOSSurfaceMVK.pCreateInfo": "",
  "vkCreateMacOSSurfaceMVK.pSurface": "",
  "vkCreateMirSurfaceKHR": "Create a slink:VkSurfaceKHR object for a Mir window.",
  "vkCreateMirSurfaceKHR.instance": "",
  "vkCreateMirSurfaceKHR.pAllocator": "",
  "vkCreateMirSurfaceKHR.pCreateInfo": "",
  "vkCreateMirSurfaceKHR.pSurface": "",
  "vkCreateObjectTableNVX": "",
  "vkCreateObjectTableNVX.device": "",
  "vkCreateObjectTableNVX.pAllocator": "",
  "vkCreateObjectTableNVX.pCreateInfo": "",
  "vkCreateObjectTableNVX.pObjectTable": "",
  "vkCreatePipelineCache": "Creates a new pipeline cache.",
  "vkCreatePipelineCache.device": "",
  "vkCreatePipelineCache.pAllocator": "",
  "vkCreatePipelineCache.pCreateInfo": "",
  "vkCreatePipelineCache.pPipelineCache": "",
  "vkCreatePipelineLayout": "Creates a new pipeline layout object.",
  "vkCreatePipelineLayout.device": "",
  "vkCreatePipelineLayout.pAllocator": "",
  "vkCreatePipelineLayout.pCreateInfo": "",
  "vkCreatePipelineLayout.pPipelineLayout": "",
  "vkCreateQueryPool": "Create a new query pool object.",
  "vkCreateQueryPool.device": "",
  "vkCreateQueryPool.pAllocator": "",
  "vkCreateQueryPool.pCreateInfo": "",
  "vkCreateQueryPool.pQueryPool": "",
  "vkCreateRenderPass": "Create a new render pass object.",
  "vkCreateRenderPass.device": "",
  "vkCreateRenderPass.pAllocator": "",
  "vkCreateRenderPass.pCreateInfo": "",
  "vkCreateRenderPass.pRenderPass": "",
  "vkCreateSampler": "Create a new sampler object.",
  "vkCreateSampler.device": "",
  "vkCreateSampler.pAllocator": "",
  "vkCreateSampler.pCreateInfo": "",
  "vkCreateSampler.pSampler": "",
  "vkCreateSemaphore": "Create a new queue semaphore object.",
  "vkCreateSemaphore.device": "",
  "vkCreateSemaphore.pAllocator": "",
  "vkCreateSemaphore.pCreateInfo": "",
  "vkCreateSemaphore.pSemaphore": "",
  "vkCreateShaderModule": "Creates a new shader module object.",
  "vkCreateShaderModule.device": "",
  "vkCreateShaderModule.pAllocator": "",
  "vkCreateShaderModule.pCreateInfo": "",
  "vkCreateShaderModule.pShaderModule": "",
  "vkCreateSharedSwapchainsKHR": "Create multiple swapchains that share presentable images.",
  "vkCreateSharedSwapchainsKHR.device": "",
  "vkCreateSharedSwapchainsKHR.pAllocator": "",
  "vkCreateSharedSwapchainsKHR.pCreateInfos": "",
  "vkCreateSharedSwapchainsKHR.pSwapchains": "",
  "vkCreateSharedSwapchainsKHR.swapchainCount": "",
  "vkCreateSwapchainKHR": "Create a swapchain.",
  "vkCreateSwapchainKHR.device": "",
  "vkCreateSwapchainKHR.pAllocator": "",
  "vkCreateSwapchainKHR.pCreateInfo": "",
  "vkCreateSwapchainKHR.pSwapchain": "",
  "vkCreateViSurfaceNN": "Create a slink:VkSurfaceKHR object for a VI layer.",
  "vkCreateViSurfaceNN.instance": "",
  "vkCreateViSurfaceNN.pAllocator": "",
  "vkCreateViSurfaceNN.pCreateInfo": "",
  "vkCreateViSurfaceNN.pSurface": "",
  "vkCreateWaylandSurfaceKHR": "Create a slink:VkSurfaceKHR object for a Wayland window.",
  "vkCreateWaylandSurfaceKHR.instance": "",
  "vkCreateWaylandSurfaceKHR.pAllocator": "",
  "vkCreateWaylandSurfaceKHR.pCreateInfo": "",
  "vkCreateWaylandSurfaceKHR.pSurface": "",
  "vkCreateWin32SurfaceKHR": "Create a slink:VkSurfaceKHR object for an Win32 native window.",
  "vkCreateWin32SurfaceKHR.instance": "",
  "vkCreateWin32SurfaceKHR.pAllocator": "",
  "vkCreateWin32SurfaceKHR.pCreateInfo": "",
  "vkCreateWin32SurfaceKHR.pSurface": "",
  "vkCreateXcbSurfaceKHR": "Create a slink:VkSurfaceKHR object for a X11 window, using the XCB client-side library.",
  "vkCreateXcbSurfaceKHR.instance": "",
  "vkCreateXcbSurfaceKHR.pAllocator": "",
  "vkCreateXcbSurfaceKHR.pCreateInfo": "",
  "vkCreateXcbSurfaceKHR.pSurface": "",
  "vkCreateXlibSurfaceKHR": "Create a slink:VkSurfaceKHR object for an X11 window, using the Xlib client-side library.",
  "vkCreateXlibSurfaceKHR.instance": "",
  "vkCreateXlibSurfaceKHR.pAllocator": "",
  "vkCreateXlibSurfaceKHR.pCreateInfo": "",
  "vkCreateXlibSurfaceKHR.pSurface": "",
  "VkCullModeFlagBits": "Bitmask controlling triangle culling.",
  "VkCullModeFlags": "",
  "VkCullModeFlags.VK_CULL_MODE_BACK_BIT": "",
  "VkCullModeFlags.VK_CULL_MODE_FRONT_AND_BACK": "",
  "VkCullModeFlags.VK_CULL_MODE_FRONT_BIT": "",
  "VkCullModeFlags.VK_CULL_MODE_NONE": "",
  "VkD3D12FenceSubmitInfoKHR": "",
  "VkD3D12FenceSubmitInfoKHR.pNext": "",
  "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues": "",
  "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues": "",
  "VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount": "",
  "VkD3D12FenceSubmitInfoKHR.sType": "",
  "VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount": "",
  "VkDebugMarkerMarkerInfoEXT": "Specify parameters of a command buffer marker region.",
  "VkDebugMarkerMarkerInfoEXT.color": "pname:color is an optional RGBA color value that can be associated with the marker. A particular implementation may: choose to ignore this color value. The values contain RGBA values in order, in the range 0.0 to 1.0. If all elements in pname:color are set to 0.0 then it is ignored.",
  "VkDebugMarkerMarkerInfoEXT.pMarkerName": "pname:pMarkerName is a pointer to a null-terminated UTF-8 string that contains the name of the marker.",
  "VkDebugMarkerMarkerInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDebugMarkerMarkerInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDebugMarkerObjectNameInfoEXT": "Specify parameters of a name to give to an object.",
  "VkDebugMarkerObjectNameInfoEXT.object": "pname:object is the object to be named.",
  "VkDebugMarkerObjectNameInfoEXT.objectType": "pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.",
  "VkDebugMarkerObjectNameInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDebugMarkerObjectNameInfoEXT.pObjectName": "pname:pObjectName is a null-terminated UTF-8 string specifying the name to apply to pname:object.",
  "VkDebugMarkerObjectNameInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDebugMarkerObjectTagInfoEXT": "Specify parameters of a tag to attach to an object.",
  "VkDebugMarkerObjectTagInfoEXT.object": "pname:object is the object to be tagged.",
  "VkDebugMarkerObjectTagInfoEXT.objectType": "pname:objectType is a elink:VkDebugReportObjectTypeEXT specifying the type of the object to be named.",
  "VkDebugMarkerObjectTagInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDebugMarkerObjectTagInfoEXT.pTag": "pname:pTag is an array of pname:tagSize bytes containing the data to be associated with the object.",
  "VkDebugMarkerObjectTagInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDebugMarkerObjectTagInfoEXT.tagName": "pname:tagName is a numerical identifier of the tag.",
  "VkDebugMarkerObjectTagInfoEXT.tagSize": "pname:tagSize is the number of bytes of data to attach to the object.",
  "vkDebugMarkerSetObjectNameEXT": "Give a user-friendly name to an object.",
  "vkDebugMarkerSetObjectNameEXT.device": "",
  "vkDebugMarkerSetObjectNameEXT.pNameInfo": "",
  "vkDebugMarkerSetObjectTagEXT": "Attach arbitrary data to an object.",
  "vkDebugMarkerSetObjectTagEXT.device": "",
  "vkDebugMarkerSetObjectTagEXT.pTagInfo": "",
  "VkDebugReportCallbackCreateInfoEXT": "Structure specifying parameters of a newly created debug report callback.",
  "VkDebugReportCallbackCreateInfoEXT.flags": "pname:flags indicate which event(s) will cause this callback to be called. Flags are interpreted as bitmasks and multiple may be set. Bits which can: be set include: + --",
  "VkDebugReportCallbackCreateInfoEXT.pfnCallback": "",
  "VkDebugReportCallbackCreateInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDebugReportCallbackCreateInfoEXT.pUserData": "",
  "VkDebugReportCallbackCreateInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDebugReportCallbackEXT": "",
  "VkDebugReportFlagBitsEXT": "Bitmask specifying events which cause a debug report callback.",
  "VkDebugReportFlagsEXT": "",
  "VkDebugReportFlagsEXT.__none": "",
  "VkDebugReportFlagsEXT.VK_DEBUG_REPORT_DEBUG_BIT_EXT": "",
  "VkDebugReportFlagsEXT.VK_DEBUG_REPORT_ERROR_BIT_EXT": "",
  "VkDebugReportFlagsEXT.VK_DEBUG_REPORT_INFORMATION_BIT_EXT": "",
  "VkDebugReportFlagsEXT.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT": "",
  "VkDebugReportFlagsEXT.VK_DEBUG_REPORT_WARNING_BIT_EXT": "",
  "vkDebugReportMessageEXT": "",
  "vkDebugReportMessageEXT.flags": "",
  "vkDebugReportMessageEXT.instance": "",
  "vkDebugReportMessageEXT.location": "",
  "vkDebugReportMessageEXT.messageCode": "",
  "vkDebugReportMessageEXT.object": "",
  "vkDebugReportMessageEXT.objectType": "",
  "vkDebugReportMessageEXT.pLayerPrefix": "",
  "vkDebugReportMessageEXT.pMessage": "",
  "VkDebugReportObjectTypeEXT": "Specify the type of an object handle.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT is a sname:VkBuffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT is a sname:VkBufferView.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT is a sname:VkCommandBuffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT is a sname:VkCommandPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT": "",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT is a sname:VkDescriptorPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT is a sname:VkDescriptorSet.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT is a sname:VkDescriptorSetLayout.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT": "",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT is a sname:VkDevice.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT is a sname:VkDeviceMemory.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT is a sname:VkDisplayKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT is a sname:VkDisplayModeKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT is a sname:VkEvent.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT is a sname:VkFence.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT is a sname:VkFramebuffer.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT is a sname:VkImage.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT is a sname:VkImageView.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT is a sname:VkIndirectCommandsLayoutNVX.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT is a sname:VkInstance.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT is a sname:VkObjectTableNVX.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT is a sname:VkPhysicalDevice.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT is a sname:VkPipelineCache.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT is a sname:VkPipeline.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT is a sname:VkPipelineLayout.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT is a sname:VkQueryPool.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT is a sname:VkQueue.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT is a sname:VkRenderPass.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT is a sname:VkSampler.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT is a sname:VkSemaphore.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT is a sname:VkShaderModule.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT is a sname:VkSurfaceKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT is a sname:VkSwapchainKHR.",
  "VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT": "ename:VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT is an unknown object.",
  "VkDedicatedAllocationBufferCreateInfoNV": "Specify that a buffer is bound to a dedicated memory resource.",
  "VkDedicatedAllocationBufferCreateInfoNV.dedicatedAllocation": "pname:dedicatedAllocation indicates whether the buffer will have a dedicated allocation bound to it.",
  "VkDedicatedAllocationBufferCreateInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDedicatedAllocationBufferCreateInfoNV.sType": "pname:sType is the type of this structure.",
  "VkDedicatedAllocationImageCreateInfoNV": "Specify that an image is bound to a dedicated memory resource.",
  "VkDedicatedAllocationImageCreateInfoNV.dedicatedAllocation": "pname:dedicatedAllocation indicates whether the image will have a dedicated allocation bound to it.",
  "VkDedicatedAllocationImageCreateInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDedicatedAllocationImageCreateInfoNV.sType": "pname:sType is the type of this structure.",
  "VkDedicatedAllocationMemoryAllocateInfoNV": "Specify a dedicated memory allocation resource.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.buffer": "pname:buffer is sname:VK_NULL_HANDLE or a handle of a buffer which this memory will be bound to.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.image": "pname:image is sname:VK_NULL_HANDLE or a handle of an image which this memory will be bound to.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDedicatedAllocationMemoryAllocateInfoNV.sType": "pname:sType is the type of this structure.",
  "VkDependencyFlagBits": "Bitmask specifying how execution and memory dependencies are formed.",
  "VkDependencyFlags": "",
  "VkDependencyFlags.__none": "",
  "VkDependencyFlags.VK_DEPENDENCY_BY_REGION_BIT": "",
  "VkDependencyFlags.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX": "",
  "VkDependencyFlags.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX": "",
  "VkDescriptorBufferInfo": "Structure specifying descriptor buffer info.",
  "VkDescriptorBufferInfo.buffer": "pname:buffer is the buffer resource.",
  "VkDescriptorBufferInfo.offset": "pname:offset is the offset in bytes from the start of pname:buffer. Access to buffer memory via this descriptor uses addressing that is relative to this starting offset.",
  "VkDescriptorBufferInfo.range": "pname:range is the size in bytes that is used for this descriptor update, or ename:VK_WHOLE_SIZE to use the range from pname:offset to the end of the buffer. + -- [NOTE] .Note ==== When using ename:VK_WHOLE_SIZE, the effective range must: not be larger than the maximum range for the descriptor type (<<features-limits-maxUniformBufferRange, maxUniformBufferRange>> or <<features-limits-maxStorageBufferRange, maxStorageBufferRange>>). This means that ename:VK_WHOLE_SIZE is not typically useful in the common case where uniform buffer descriptors are suballocated from a buffer that is much larger than pname:maxUniformBufferRange. ==== -- + For ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC and ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC descriptor types, pname:offset is the base offset from which the dynamic offset is applied and pname:range is the static size used for all dynamic offsets.",
  "VkDescriptorImageInfo": "Structure specifying descriptor image info.",
  "VkDescriptorImageInfo.imageLayout": "pname:imageLayout is the layout that the image will be in at the time this descriptor is accessed. pname:imageLayout is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.",
  "VkDescriptorImageInfo.imageView": "pname:imageView is an image view handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.",
  "VkDescriptorImageInfo.sampler": "pname:sampler is a sampler handle, and is used in descriptor updates for types ename:VK_DESCRIPTOR_TYPE_SAMPLER and ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers.",
  "VkDescriptorPool": "Opaque handle to a descriptor pool object.",
  "VkDescriptorPoolCreateFlagBits": "Bitmask specifying certain supported operations on a descriptor pool.",
  "VkDescriptorPoolCreateFlags": "",
  "VkDescriptorPoolCreateFlags.__none": "",
  "VkDescriptorPoolCreateFlags.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT": "",
  "VkDescriptorPoolCreateInfo": "Structure specifying parameters of a newly created descriptor pool.",
  "VkDescriptorPoolCreateInfo.flags": "pname:flags specifies certain supported operations on the pool. Bits which can: be set include: + --",
  "VkDescriptorPoolCreateInfo.maxSets": "",
  "VkDescriptorPoolCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDescriptorPoolCreateInfo.poolSizeCount": "",
  "VkDescriptorPoolCreateInfo.pPoolSizes": "",
  "VkDescriptorPoolCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkDescriptorPoolResetFlags": "",
  "VkDescriptorPoolResetFlags.__none": "",
  "VkDescriptorPoolSize": "Structure specifying descriptor pool size.",
  "VkDescriptorPoolSize.descriptorCount": "pname:descriptorCount is the number of descriptors of that type to allocate.",
  "VkDescriptorPoolSize.type": "pname:type is the type of descriptor.",
  "VkDescriptorSet": "Opaque handle to a descriptor set object.",
  "VkDescriptorSetAllocateInfo": "Structure specifying the allocation parameters for descriptor sets.",
  "VkDescriptorSetAllocateInfo.descriptorPool": "pname:descriptorPool is the pool which the sets will be allocated from.",
  "VkDescriptorSetAllocateInfo.descriptorSetCount": "pname:descriptorSetCount determines the number of descriptor sets to be allocated from the pool.",
  "VkDescriptorSetAllocateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDescriptorSetAllocateInfo.pSetLayouts": "pname:pSetLayouts is an array of descriptor set layouts, with each member specifying how the corresponding descriptor set is allocated.",
  "VkDescriptorSetAllocateInfo.sType": "pname:sType is the type of this structure.",
  "VkDescriptorSetLayout": "Opaque handle to a descriptor set layout object.",
  "VkDescriptorSetLayoutBinding": "Structure specifying a descriptor set layout binding.",
  "VkDescriptorSetLayoutBinding.binding": "pname:binding is the binding number of this entry and corresponds to a resource of the same binding number in the shader stages.",
  "VkDescriptorSetLayoutBinding.descriptorCount": "pname:descriptorCount is the number of descriptors contained in the binding, accessed in a shader as an array. If pname:descriptorCount is zero this binding entry is reserved and the resource must: not be accessed from any stage via this binding within any pipeline using the set layout.",
  "VkDescriptorSetLayoutBinding.descriptorType": "pname:descriptorType is a elink:VkDescriptorType specifying which type of resource descriptors are used for this binding.",
  "VkDescriptorSetLayoutBinding.pImmutableSamplers": "pname:pImmutableSamplers affects initialization of samplers. If pname:descriptorType specifies a ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER type descriptor, then pname:pImmutableSamplers can: be used to initialize a set of _immutable samplers_. Immutable samplers are permanently bound into the set layout; later binding a sampler into an immutable sampler slot in a descriptor set is not allowed. If pname:pImmutableSamplers is not `NULL`, then it is considered to be a pointer to an array of sampler handles that will be consumed by the set layout and used for the corresponding binding. If pname:pImmutableSamplers is `NULL`, then the sampler slots are dynamic and sampler handles must: be bound into descriptor sets using this layout. If pname:descriptorType is not one of these descriptor types, then pname:pImmutableSamplers is ignored.",
  "VkDescriptorSetLayoutBinding.stageFlags": "pname:stageFlags member is a bitmask of elink:VkShaderStageFlagBits specifying which pipeline shader stages can: access a resource for this binding. ename:VK_SHADER_STAGE_ALL is a shorthand specifying that all defined shader stages, including any additional stages defined by extensions, can: access the resource. + -- If a shader stage is not included in pname:stageFlags, then a resource must: not be accessed from that stage via this binding within any pipeline using the set layout. There are no limitations on what combinations of stages can: be used by a descriptor binding, and in particular a binding can: be used by both graphics stages and the compute stage. --",
  "VkDescriptorSetLayoutCreateFlagBits": "Bitmask specifying descriptor set layout properties.",
  "VkDescriptorSetLayoutCreateFlags": "",
  "VkDescriptorSetLayoutCreateFlags.__none": "",
  "VkDescriptorSetLayoutCreateFlags.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR": "",
  "VkDescriptorSetLayoutCreateInfo": "Structure specifying parameters of a newly created descriptor set layout.",
  "VkDescriptorSetLayoutCreateInfo.bindingCount": "",
  "VkDescriptorSetLayoutCreateInfo.flags": "pname:flags provides options for descriptor set layout creation, and is of type elink:VkDescriptorSetLayoutCreateFlags. Bits which can: be set include: + --",
  "VkDescriptorSetLayoutCreateInfo.pBindings": "",
  "VkDescriptorSetLayoutCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDescriptorSetLayoutCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkDescriptorType": "Specifies the type of a descriptor in a descriptor set.",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_SAMPLER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_IMAGE": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC": "",
  "VkDescriptorType.VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER": "",
  "VkDescriptorUpdateTemplateCreateFlagsKHR": "",
  "VkDescriptorUpdateTemplateCreateFlagsKHR.__none": "",
  "VkDescriptorUpdateTemplateCreateInfoKHR": "Structure specifying parameters of a newly created descriptor update template.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout": "pname:descriptorSetLayout is the descriptor set layout the parameter update template will be used with. All descriptor sets which are going to be updated through the newly created descriptor update template must: be created with this layout. pname:descriptorSetLayout is the descriptor set layout used to build the descriptor update template. All descriptor sets which are going to be updated through the newly created descriptor update template must: be created with a layout that matches (is the same as, or defined identically to) this layout. This parameter is ignored if pname:templateType is not ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount": "pname:descriptorUpdateEntryCount is the number of elements in the pname:pDescriptorUpdateEntries array.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries": "pname:pDescriptorUpdateEntries is a pointer to an array of slink:VkDescriptorUpdateTemplateEntryKHR structures describing the descriptors to be updated by the descriptor update template.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint": "pname:pipelineBindPoint is a elink:VkPipelineBindPoint indicating whether the descriptors will be used by graphics pipelines or compute pipelines. This parameter is ignored if pname:templateType is not ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout": "pname:pipelineLayout is a sname:VkPipelineLayout object used to program the bindings. This parameter is ignored if pname:templateType is not ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR",
  "VkDescriptorUpdateTemplateCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.set": "pname:set is the set number of the descriptor set in the pipeline layout that will be updated. This parameter is ignored if pname:templateType is not ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR ifndef::VK_KHR_push_descriptor[]",
  "VkDescriptorUpdateTemplateCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkDescriptorUpdateTemplateCreateInfoKHR.templateType": "pname:templateType Specifies the type of the descriptor update template. If set to ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR it can: only be used to update descriptor sets with a fixed pname:descriptorSetLayout. If set to ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR it can: only be used to push descriptor sets using the provided pname:pipelineBindPoint, pname:pipelineLayout, and pname:set number.",
  "VkDescriptorUpdateTemplateEntryKHR": "Describes a single descriptor update of the descriptor update template.",
  "VkDescriptorUpdateTemplateEntryKHR.descriptorCount": "pname:descriptorCount is the number of descriptors to update. If pname:descriptorCount is greater than the number of remaining array elements in the destination binding, those affect consecutive bindings in a manner similar to slink:VkWriteDescriptorSet above.",
  "VkDescriptorUpdateTemplateEntryKHR.descriptorType": "pname:descriptorType is a elink:VkDescriptorType specifying the type of the descriptor.",
  "VkDescriptorUpdateTemplateEntryKHR.dstArrayElement": "pname:dstArrayElement is the starting element in the array belonging to pname:dstBinding.",
  "VkDescriptorUpdateTemplateEntryKHR.dstBinding": "pname:dstBinding is the descriptor binding to update when using this descriptor update template.",
  "VkDescriptorUpdateTemplateEntryKHR.offset": "pname:offset is the offset in bytes of the first binding in the raw data structure.",
  "VkDescriptorUpdateTemplateEntryKHR.stride": "pname:stride is the stride in bytes between two consecutive array elements of the descriptor update informations in the raw data structure. The actual pointer ptr for each array element j of update entry i is computed using the following formula: [source,c++] --------------------------------------------------- const char *ptr = (const char *)pData + pDescriptorUpdateEntries[i].offset + j * pDescriptorUpdateEntries[i].stride --------------------------------------------------- The stride is useful in case the bindings are stored in structs along with other data.",
  "VkDescriptorUpdateTemplateKHR": "Opaque handle to a descriptor update template.",
  "VkDescriptorUpdateTemplateTypeKHR": "Indicates the valid usage of the descriptor update template.",
  "VkDescriptorUpdateTemplateTypeKHR.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR": "ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR indicates that the descriptor update template will be used for descriptor set updates only.",
  "VkDescriptorUpdateTemplateTypeKHR.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR": "ename:VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR indicates that the descriptor update template will be used for push descriptor updates only.",
  "vkDestroyBuffer": "Destroy a buffer object.",
  "vkDestroyBuffer.buffer": "",
  "vkDestroyBuffer.device": "",
  "vkDestroyBuffer.pAllocator": "",
  "vkDestroyBufferView": "Destroy a buffer view object.",
  "vkDestroyBufferView.bufferView": "",
  "vkDestroyBufferView.device": "",
  "vkDestroyBufferView.pAllocator": "",
  "vkDestroyCommandPool": "Destroy a command pool object.",
  "vkDestroyCommandPool.commandPool": "",
  "vkDestroyCommandPool.device": "",
  "vkDestroyCommandPool.pAllocator": "",
  "vkDestroyDebugReportCallbackEXT": "Destroy a debug report callback object.",
  "vkDestroyDebugReportCallbackEXT.callback": "",
  "vkDestroyDebugReportCallbackEXT.instance": "",
  "vkDestroyDebugReportCallbackEXT.pAllocator": "",
  "vkDestroyDescriptorPool": "Destroy a descriptor pool object.",
  "vkDestroyDescriptorPool.descriptorPool": "",
  "vkDestroyDescriptorPool.device": "",
  "vkDestroyDescriptorPool.pAllocator": "",
  "vkDestroyDescriptorSetLayout": "Destroy a descriptor set layout object.",
  "vkDestroyDescriptorSetLayout.descriptorSetLayout": "",
  "vkDestroyDescriptorSetLayout.device": "",
  "vkDestroyDescriptorSetLayout.pAllocator": "",
  "vkDestroyDescriptorUpdateTemplateKHR": "Destroy a descriptor update template object.",
  "vkDestroyDescriptorUpdateTemplateKHR.descriptorUpdateTemplate": "",
  "vkDestroyDescriptorUpdateTemplateKHR.device": "",
  "vkDestroyDescriptorUpdateTemplateKHR.pAllocator": "",
  "vkDestroyDevice": "Destroy a logical device.",
  "vkDestroyDevice.device": "",
  "vkDestroyDevice.pAllocator": "",
  "vkDestroyEvent": "Destroy an event object.",
  "vkDestroyEvent.device": "",
  "vkDestroyEvent.event": "",
  "vkDestroyEvent.pAllocator": "",
  "vkDestroyFence": "Destroy a fence object.",
  "vkDestroyFence.device": "",
  "vkDestroyFence.fence": "",
  "vkDestroyFence.pAllocator": "",
  "vkDestroyFramebuffer": "Destroy a framebuffer object.",
  "vkDestroyFramebuffer.device": "",
  "vkDestroyFramebuffer.framebuffer": "",
  "vkDestroyFramebuffer.pAllocator": "",
  "vkDestroyImage": "Destroy an image object.",
  "vkDestroyImage.device": "",
  "vkDestroyImage.image": "",
  "vkDestroyImage.pAllocator": "",
  "vkDestroyImageView": "Destroy an image view object.",
  "vkDestroyImageView.device": "",
  "vkDestroyImageView.imageView": "",
  "vkDestroyImageView.pAllocator": "",
  "vkDestroyIndirectCommandsLayoutNVX": "Destroy a object table.",
  "vkDestroyIndirectCommandsLayoutNVX.device": "",
  "vkDestroyIndirectCommandsLayoutNVX.indirectCommandsLayout": "",
  "vkDestroyIndirectCommandsLayoutNVX.pAllocator": "",
  "vkDestroyInstance": "Destroy an instance of Vulkan.",
  "vkDestroyInstance.instance": "",
  "vkDestroyInstance.pAllocator": "",
  "vkDestroyObjectTableNVX": "Destroy a object table.",
  "vkDestroyObjectTableNVX.device": "",
  "vkDestroyObjectTableNVX.objectTable": "",
  "vkDestroyObjectTableNVX.pAllocator": "",
  "vkDestroyPipeline": "Destroy a pipeline object.",
  "vkDestroyPipeline.device": "",
  "vkDestroyPipeline.pAllocator": "",
  "vkDestroyPipeline.pipeline": "",
  "vkDestroyPipelineCache": "Destroy a pipeline cache object.",
  "vkDestroyPipelineCache.device": "",
  "vkDestroyPipelineCache.pAllocator": "",
  "vkDestroyPipelineCache.pipelineCache": "",
  "vkDestroyPipelineLayout": "Destroy a pipeline layout object.",
  "vkDestroyPipelineLayout.device": "",
  "vkDestroyPipelineLayout.pAllocator": "",
  "vkDestroyPipelineLayout.pipelineLayout": "",
  "vkDestroyQueryPool": "Destroy a query pool object.",
  "vkDestroyQueryPool.device": "",
  "vkDestroyQueryPool.pAllocator": "",
  "vkDestroyQueryPool.queryPool": "",
  "vkDestroyRenderPass": "Destroy a render pass object.",
  "vkDestroyRenderPass.device": "",
  "vkDestroyRenderPass.pAllocator": "",
  "vkDestroyRenderPass.renderPass": "",
  "vkDestroySampler": "Destroy a sampler object.",
  "vkDestroySampler.device": "",
  "vkDestroySampler.pAllocator": "",
  "vkDestroySampler.sampler": "",
  "vkDestroySemaphore": "Destroy a semaphore object.",
  "vkDestroySemaphore.device": "",
  "vkDestroySemaphore.pAllocator": "",
  "vkDestroySemaphore.semaphore": "",
  "vkDestroyShaderModule": "Destroy a shader module module.",
  "vkDestroyShaderModule.device": "",
  "vkDestroyShaderModule.pAllocator": "",
  "vkDestroyShaderModule.shaderModule": "",
  "vkDestroySurfaceKHR": "Destroy a VkSurfaceKHR object.",
  "vkDestroySurfaceKHR.instance": "",
  "vkDestroySurfaceKHR.pAllocator": "",
  "vkDestroySurfaceKHR.surface": "",
  "vkDestroySwapchainKHR": "Destroy a swapchain object.",
  "vkDestroySwapchainKHR.device": "",
  "vkDestroySwapchainKHR.pAllocator": "",
  "vkDestroySwapchainKHR.swapchain": "",
  "VkDevice": "Opaque handle to a device object.",
  "VkDeviceCreateFlagBits": "",
  "VkDeviceCreateFlags": "",
  "VkDeviceCreateFlags.__none": "",
  "VkDeviceCreateInfo": "Structure specifying parameters of a newly created device.",
  "VkDeviceCreateInfo.enabledExtensionCount": "pname:enabledExtensionCount is the number of device extensions to enable.",
  "VkDeviceCreateInfo.enabledLayerCount": "pname:enabledLayerCount is deprecated and ignored.",
  "VkDeviceCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkDeviceCreateInfo.pEnabledFeatures": "pname:pEnabledFeatures is `NULL` or a pointer to a slink:VkPhysicalDeviceFeatures structure that contains boolean indicators of all the features to be enabled. Refer to the <<features-features,Features>> section for further details.",
  "VkDeviceCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceCreateInfo.ppEnabledExtensionNames": "pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the <<extended-functionality-extensions,Extensions>> section for further details.",
  "VkDeviceCreateInfo.ppEnabledLayerNames": "pname:ppEnabledLayerNames is deprecated and ignored. See <<extended-functionality-device-layer-deprecation,Device Layer Deprecation>>.",
  "VkDeviceCreateInfo.pQueueCreateInfos": "pname:pQueueCreateInfos is a pointer to an array of slink:VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.",
  "VkDeviceCreateInfo.queueCreateInfoCount": "pname:queueCreateInfoCount is the unsigned integer size of the pname:pQueueCreateInfos array. Refer to the <<devsandqueues-queue-creation,Queue Creation>> section below for further details.",
  "VkDeviceCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkDeviceEventInfoEXT": "Describe a device event to create.",
  "VkDeviceEventInfoEXT.deviceEvent": "",
  "VkDeviceEventInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceEventInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDeviceEventTypeEXT": "Events that can occur on a device object.",
  "VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT": "",
  "VkDeviceGeneratedCommandsFeaturesNVX": "Structure specifying physical device support.",
  "VkDeviceGeneratedCommandsFeaturesNVX.computeBindingPointSupport": "pname:computeBindingPointSupport indicates whether the sname:VkObjectTableNVX supports entries with ename:VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX bit set and sname:VkIndirectCommandsLayoutNVX supports ename:VK_PIPELINE_BIND_POINT_COMPUTE.",
  "VkDeviceGeneratedCommandsFeaturesNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGeneratedCommandsFeaturesNVX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGeneratedCommandsLimitsNVX": "Structure specifying physical device limits.",
  "VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount": "pname:maxIndirectCommandsLayoutTokenCount the maximum number of tokens in sname:VkIndirectCommandsLayoutNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts": "pname:maxObjectEntryCounts the maximum number of entries per resource type in sname:VkObjectTableNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment": "pname:minCommandsTokenBufferOffsetAlignment the minimum alignment for memory addresses optionally used in fname:vkCmdProcessCommandsNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment": "pname:minSequenceCountBufferOffsetAlignment the minimum alignment for memory addresses optionally used in fname:vkCmdProcessCommandsNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment": "pname:minSequenceIndexBufferOffsetAlignment the minimum alignment for memory addresses optionally used in fname:vkCmdProcessCommandsNVX.",
  "VkDeviceGeneratedCommandsLimitsNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGeneratedCommandsLimitsNVX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupBindSparseInfoKHX": "Structure indicating which instances are bound.",
  "VkDeviceGroupBindSparseInfoKHX.memoryDeviceIndex": "pname:memoryDeviceIndex is a device index indicating which instance of the memory the resource instance is bound to.",
  "VkDeviceGroupBindSparseInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupBindSparseInfoKHX.resourceDeviceIndex": "pname:resourceDeviceIndex is a device index indicating which instance of the resource is bound.",
  "VkDeviceGroupBindSparseInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupCommandBufferBeginInfoKHX": "Set the initial device mask for a command buffer.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.deviceMask": "pname:deviceMask is the initial value of the command buffer's device mask.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupCommandBufferBeginInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupDeviceCreateInfoKHX": "Create a logical device from multiple physical devices.",
  "VkDeviceGroupDeviceCreateInfoKHX.physicalDeviceCount": "pname:physicalDeviceCount is the number of elements in the pname:pPhysicalDevices array.",
  "VkDeviceGroupDeviceCreateInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupDeviceCreateInfoKHX.pPhysicalDevices": "pname:pPhysicalDevices is an array of physical device handles belonging to the same device group.",
  "VkDeviceGroupDeviceCreateInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupPresentCapabilitiesKHX": "Present capabilities from other physical devices.",
  "VkDeviceGroupPresentCapabilitiesKHX.modes": "pname:modes is a bitmask indicating which device group presentation modes are supported. The bits returned in pname:modes are: + --",
  "VkDeviceGroupPresentCapabilitiesKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupPresentCapabilitiesKHX.presentMask": "pname:presentMask is an array of masks, where the mask at element [eq]#i# is non-zero if physical device [eq]#i# has a presentation engine, and where bit [eq]#j# is set in element [eq]#i# if physical device [eq]#i# can: present swapchain images from physical device [eq]#j#. If element [eq]#i# is non-zero, then bit [eq]#i# must: be set.",
  "VkDeviceGroupPresentCapabilitiesKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupPresentInfoKHX": "Mode and mask controlling which physical devices' images are presented.",
  "VkDeviceGroupPresentInfoKHX.mode": "pname:mode is the device group present mode that will be used for this present.",
  "VkDeviceGroupPresentInfoKHX.pDeviceMasks": "pname:pDeviceMasks is an array of device masks, one for each element of slink:VkPresentInfoKHR::pSwapchains.",
  "VkDeviceGroupPresentInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupPresentInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupPresentInfoKHX.swapchainCount": "pname:swapchainCount is zero or the number of elements in pname:pDeviceMasks.",
  "VkDeviceGroupPresentModeFlagBitsKHX": "Bitmask specifying supported device group present modes.",
  "VkDeviceGroupPresentModeFlagsKHX": "",
  "VkDeviceGroupPresentModeFlagsKHX.__none": "",
  "VkDeviceGroupPresentModeFlagsKHX.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagsKHX.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagsKHX.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX": "",
  "VkDeviceGroupPresentModeFlagsKHX.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX": "",
  "VkDeviceGroupRenderPassBeginInfoKHX": "Set the initial device mask and render areas for a render pass instance.",
  "VkDeviceGroupRenderPassBeginInfoKHX.deviceMask": "pname:deviceMask is the device mask for the render pass instance.",
  "VkDeviceGroupRenderPassBeginInfoKHX.deviceRenderAreaCount": "pname:deviceRenderAreaCount is the number of elements in the pname:pDeviceRenderAreas array.",
  "VkDeviceGroupRenderPassBeginInfoKHX.pDeviceRenderAreas": "pname:pDeviceRenderAreas is an array of structures of type slink:VkRect2D defining the render area for each physical device.",
  "VkDeviceGroupRenderPassBeginInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupRenderPassBeginInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupSubmitInfoKHX": "Structure indicating which physical devices execute semaphore operations and command buffers.",
  "VkDeviceGroupSubmitInfoKHX.commandBufferCount": "pname:commandBufferCount is the number of elements in the pname:pCommandBufferDeviceMasks array.",
  "VkDeviceGroupSubmitInfoKHX.pCommandBufferDeviceMasks": "pname:pCommandBufferDeviceMasks is an array of device masks indicating which physical devices execute the command buffer in the corresponding element of slink:VkSubmitInfo::pname:pCommandBuffers. A physical device executes the command buffer if the corresponding bit is set in the mask.",
  "VkDeviceGroupSubmitInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupSubmitInfoKHX.pSignalSemaphoreDeviceIndices": "pname:pSignalSemaphoreDeviceIndices is an array of device indices indicating which physical device executes the semaphore signal operation in the corresponding element of slink:VkSubmitInfo::pname:pSignalSemaphores.",
  "VkDeviceGroupSubmitInfoKHX.pWaitSemaphoreDeviceIndices": "pname:pWaitSemaphoreDeviceIndices is an array of device indices indicating which physical device executes the semaphore wait operation in the corresponding element of slink:VkSubmitInfo::pname:pWaitSemaphores.",
  "VkDeviceGroupSubmitInfoKHX.signalSemaphoreCount": "pname:signalSemaphoreCount is the number of elements in the pname:pSignalSemaphoreDeviceIndices array.",
  "VkDeviceGroupSubmitInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceGroupSubmitInfoKHX.waitSemaphoreCount": "pname:waitSemaphoreCount is the number of elements in the pname:pWaitSemaphoreDeviceIndices array.",
  "VkDeviceGroupSwapchainCreateInfoKHX": "Structure specifying parameters of a newly created swapchain object.",
  "VkDeviceGroupSwapchainCreateInfoKHX.modes": "pname:modes is a bitfield of modes that the swapchain can: be used with.",
  "VkDeviceGroupSwapchainCreateInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceGroupSwapchainCreateInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkDeviceMemory": "Opaque handle to a device memory object.",
  "VkDeviceQueueCreateFlagBits": "",
  "VkDeviceQueueCreateFlags": "",
  "VkDeviceQueueCreateFlags.__none": "",
  "VkDeviceQueueCreateInfo": "Structure specifying parameters of a newly created device queue.",
  "VkDeviceQueueCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkDeviceQueueCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDeviceQueueCreateInfo.pQueuePriorities": "pname:pQueuePriorities is an array of pname:queueCount normalized floating point values, specifying priorities of work that will be submitted to each created queue. See <<devsandqueues-priority,Queue Priority>> for more information.",
  "VkDeviceQueueCreateInfo.queueCount": "pname:queueCount is an unsigned integer specifying the number of queues to create in the queue family indicated by pname:queueFamilyIndex.",
  "VkDeviceQueueCreateInfo.queueFamilyIndex": "pname:queueFamilyIndex is an unsigned integer indicating the index of the queue family to create on this device. This index corresponds to the index of an element of the pname:pQueueFamilyProperties array that was returned by fname:vkGetPhysicalDeviceQueueFamilyProperties.",
  "VkDeviceQueueCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkDeviceSize": "Vulkan device memory size and offsets.",
  "vkDeviceWaitIdle": "Wait for a device to become idle.",
  "vkDeviceWaitIdle.device": "",
  "VkDiscardRectangleModeEXT": "",
  "VkDiscardRectangleModeEXT.VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT": "",
  "VkDiscardRectangleModeEXT.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT": "",
  "VkDispatchIndirectCommand": "Structure specifying a dispatch indirect command.",
  "VkDispatchIndirectCommand.x": "pname:x is the number of local workgroups to dispatch in the X dimension.",
  "VkDispatchIndirectCommand.y": "pname:y is the number of local workgroups to dispatch in the Y dimension.",
  "VkDispatchIndirectCommand.z": "pname:z is the number of local workgroups to dispatch in the Z dimension.",
  "VkDisplayEventInfoEXT": "Describe a display event to create.",
  "VkDisplayEventInfoEXT.displayEvent": "pname:displayEvent specifies when the fence will be signaled. Possible values are: + --",
  "VkDisplayEventInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDisplayEventInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDisplayEventTypeEXT": "Events that can occur on a display object.",
  "VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT": "",
  "VkDisplayKHR": "",
  "VkDisplayModeCreateFlagsKHR": "",
  "VkDisplayModeCreateFlagsKHR.__none": "",
  "VkDisplayModeCreateInfoKHR": "Structure specifying parameters of a newly created display mode object.",
  "VkDisplayModeCreateInfoKHR.flags": "pname:flags is reserved for future use, and must: be zero.",
  "VkDisplayModeCreateInfoKHR.parameters": "pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters to use in creating the new mode. If the parameters are not compatible with the specified display, the implementation must: return ename:VK_ERROR_INITIALIZATION_FAILED.",
  "VkDisplayModeCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDisplayModeCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkDisplayModeKHR": "",
  "VkDisplayModeParametersKHR": "Structure describing display parameters associated with a display mode.",
  "VkDisplayModeParametersKHR.refreshRate": "pname:refreshRate is a code:uint32_t that is the number of times the display is refreshed each second multiplied by 1000.",
  "VkDisplayModeParametersKHR.visibleRegion": "pname:visibleRegion is the 2D extents of the visible region.",
  "VkDisplayModePropertiesKHR": "Structure describing display mode properties.",
  "VkDisplayModePropertiesKHR.displayMode": "pname:displayMode is a handle to the display mode described in this structure. This handle will be valid for the lifetime of the Vulkan instance.",
  "VkDisplayModePropertiesKHR.parameters": "pname:parameters is a sname:VkDisplayModeParametersKHR structure describing the display parameters associated with pname:displayMode.",
  "VkDisplayPlaneAlphaFlagBitsKHR": "Alpha blending type.",
  "VkDisplayPlaneAlphaFlagsKHR": "",
  "VkDisplayPlaneAlphaFlagsKHR.__none": "",
  "VkDisplayPlaneAlphaFlagsKHR.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR": "",
  "VkDisplayPlaneAlphaFlagsKHR.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR": "",
  "VkDisplayPlaneAlphaFlagsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR": "",
  "VkDisplayPlaneAlphaFlagsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR": "",
  "VkDisplayPlaneCapabilitiesKHR": "Structure describing capabilities of a mode and plane combination.",
  "VkDisplayPlaneCapabilitiesKHR.maxDstExtent": "",
  "VkDisplayPlaneCapabilitiesKHR.maxDstPosition": "",
  "VkDisplayPlaneCapabilitiesKHR.maxSrcExtent": "pname:maxSrcExtent is the maximum source rectangle size supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.maxSrcPosition": "pname:maxSrcPosition is the maximum source rectangle offset supported by this plane using the specified mode. The pname:x and pname:y components of pname:maxSrcPosition must: each be greater than or equal to the pname:x and pname:y components of pname:minSrcPosition, respectively.",
  "VkDisplayPlaneCapabilitiesKHR.minDstExtent": "",
  "VkDisplayPlaneCapabilitiesKHR.minDstPosition": "pname:minDstPosition, pname:maxDstPosition, pname:minDstExtent, pname:maxDstExtent all have similar semantics to their corresponding \"Src\" equivalents, but apply to the output region within the mode rather than the input region within the source image. Unlike the \"Src\" offsets, pname:minDstPosition and pname:maxDstPosition may: contain negative values.",
  "VkDisplayPlaneCapabilitiesKHR.minSrcExtent": "pname:minSrcExtent is the minimum source rectangle size supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.minSrcPosition": "pname:minSrcPosition is the minimum source rectangle offset supported by this plane using the specified mode.",
  "VkDisplayPlaneCapabilitiesKHR.supportedAlpha": "pname:supportedAlpha is a bitmask of elink:VkDisplayPlaneAlphaFlagBitsKHR describing the supported alpha blending modes.",
  "VkDisplayPlanePropertiesKHR": "Structure describing display plane properties.",
  "VkDisplayPlanePropertiesKHR.currentDisplay": "pname:currentDisplay is the handle of the display the plane is currently associated with. If the plane is not currently attached to any displays, this will be sname:VK_NULL_HANDLE.",
  "VkDisplayPlanePropertiesKHR.currentStackIndex": "pname:currentStackIndex is the current z-order of the plane. This will be between 0 and the value returned by fname:vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pname:pPropertyCount.",
  "vkDisplayPowerControlEXT": "Set the power state of a display.",
  "vkDisplayPowerControlEXT.device": "",
  "vkDisplayPowerControlEXT.display": "",
  "vkDisplayPowerControlEXT.pDisplayPowerInfo": "",
  "VkDisplayPowerInfoEXT": "Describe the power state of a display.",
  "VkDisplayPowerInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDisplayPowerInfoEXT.powerState": "pname:powerState is the new power state of the display. Possible values are: + --",
  "VkDisplayPowerInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkDisplayPowerStateEXT": "Possible power states for a VkDisplay.",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_OFF_EXT": "",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_ON_EXT": "",
  "VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_SUSPEND_EXT": "",
  "VkDisplayPresentInfoKHR": "Structure describing parameters of a queue presentation to a swapchain.",
  "VkDisplayPresentInfoKHR.dstRect": "pname:dstRect is a rectangular region within the visible region of the swapchain's display mode. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire visible region of the visible region of the swapchain's mode. If the specified rectangle is a subset of the display mode's visible region, content from display planes below the swapchain's plane will be visible outside the rectangle. If there are no planes below the swapchain's, the area outside the specified rectangle will be black. If portions of the specified rectangle are outside of the display's visible region, pixels mapping only to those portions of the rectangle will be discarded.",
  "VkDisplayPresentInfoKHR.persistent": "pname:persistent: If this is ename:VK_TRUE, the display engine will enable buffered mode on displays that support it. This allows the display engine to stop sending content to the display until a new image is presented. The display will instead maintain a copy of the last presented image. This allows less power to be used, but may: increase presentation latency. If sname:VkDisplayPresentInfoKHR is not specified, persistent mode will not be used.",
  "VkDisplayPresentInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDisplayPresentInfoKHR.srcRect": "pname:srcRect is a rectangular region of pixels to present. It must: be a subset of the image being presented. If sname:VkDisplayPresentInfoKHR is not specified, this region will be assumed to be the entire presentable image.",
  "VkDisplayPresentInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkDisplayPropertiesKHR": "Structure describing an available display device.",
  "VkDisplayPropertiesKHR.display": "pname:display is a handle that is used to refer to the display described here. This handle will be valid for the lifetime of the Vulkan instance.",
  "VkDisplayPropertiesKHR.displayName": "pname:displayName is a pointer to a NULL-terminated string containing the name of the display. Generally, this will be the name provided by the display's EDID. It can: be `NULL` if no suitable name is available.",
  "VkDisplayPropertiesKHR.persistentContent": "",
  "VkDisplayPropertiesKHR.physicalDimensions": "pname:physicalDimensions describes the physical width and height of the visible portion of the display, in millimeters.",
  "VkDisplayPropertiesKHR.physicalResolution": "pname:physicalResolution describes the physical, native, or preferred resolution of the display.",
  "VkDisplayPropertiesKHR.planeReorderPossible": "",
  "VkDisplayPropertiesKHR.supportedTransforms": "",
  "VkDisplaySurfaceCreateFlagsKHR": "",
  "VkDisplaySurfaceCreateFlagsKHR.__none": "",
  "VkDisplaySurfaceCreateInfoKHR": "Structure specifying parameters of a newly created display plane surface object.",
  "VkDisplaySurfaceCreateInfoKHR.alphaMode": "pname:alphaMode is the type of alpha blending to use.",
  "VkDisplaySurfaceCreateInfoKHR.displayMode": "pname:displayMode is the mode to use when displaying this surface.",
  "VkDisplaySurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use, and must: be zero.",
  "VkDisplaySurfaceCreateInfoKHR.globalAlpha": "pname:globalAlpha is the global alpha value. This value is ignored if pname:alphaMode is not ename:VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.",
  "VkDisplaySurfaceCreateInfoKHR.imageExtent": "",
  "VkDisplaySurfaceCreateInfoKHR.planeIndex": "pname:planeIndex is the plane on which this surface appears.",
  "VkDisplaySurfaceCreateInfoKHR.planeStackIndex": "pname:planeStackIndex is the z-order of the plane.",
  "VkDisplaySurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkDisplaySurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkDisplaySurfaceCreateInfoKHR.transform": "pname:transform is the transform to apply to the images as part of the scanout operation.",
  "VkDrawIndexedIndirectCommand": "Structure specifying a draw indexed indirect command.",
  "VkDrawIndexedIndirectCommand.firstIndex": "pname:firstIndex is the base index within the index buffer.",
  "VkDrawIndexedIndirectCommand.firstInstance": "pname:firstInstance is the instance ID of the first instance to draw.",
  "VkDrawIndexedIndirectCommand.indexCount": "pname:indexCount is the number of vertices to draw.",
  "VkDrawIndexedIndirectCommand.instanceCount": "pname:instanceCount is the number of instances to draw.",
  "VkDrawIndexedIndirectCommand.vertexOffset": "pname:vertexOffset is the value added to the vertex index before indexing into the vertex buffer.",
  "VkDrawIndirectCommand": "Structure specifying a draw indirect command.",
  "VkDrawIndirectCommand.firstInstance": "pname:firstInstance is the instance ID of the first instance to draw.",
  "VkDrawIndirectCommand.firstVertex": "pname:firstVertex is the index of the first vertex to draw.",
  "VkDrawIndirectCommand.instanceCount": "pname:instanceCount is the number of instances to draw.",
  "VkDrawIndirectCommand.vertexCount": "pname:vertexCount is the number of vertices to draw.",
  "VkDynamicState": "Indicate which dynamic state is taken from dynamic state commands.",
  "VkDynamicState.VK_DYNAMIC_STATE_BLEND_CONSTANTS": "ename:VK_DYNAMIC_STATE_BLEND_CONSTANTS indicates that the pname:blendConstants state in sname:VkPipelineColorBlendStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetBlendConstants before any draws are performed with a pipeline state with sname:VkPipelineColorBlendAttachmentState member pname:blendEnable set to ename:VK_TRUE and any of the blend functions using a constant blend color.",
  "VkDynamicState.VK_DYNAMIC_STATE_DEPTH_BIAS": "ename:VK_DYNAMIC_STATE_DEPTH_BIAS indicates that the pname:depthBiasConstantFactor, pname:depthBiasClamp and pname:depthBiasSlopeFactor states in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBias before any draws are performed with pname:depthBiasEnable in sname:VkPipelineRasterizationStateCreateInfo set to ename:VK_TRUE.",
  "VkDynamicState.VK_DYNAMIC_STATE_DEPTH_BOUNDS": "ename:VK_DYNAMIC_STATE_DEPTH_BOUNDS indicates that the pname:minDepthBounds and pname:maxDepthBounds states of slink:VkPipelineDepthStencilStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetDepthBounds before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:depthBoundsTestEnable set to ename:VK_TRUE.",
  "VkDynamicState.VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT": "",
  "VkDynamicState.VK_DYNAMIC_STATE_LINE_WIDTH": "ename:VK_DYNAMIC_STATE_LINE_WIDTH indicates that the pname:lineWidth state in sname:VkPipelineRasterizationStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetLineWidth before any draw commands that generate line primitives for the rasterizer.",
  "VkDynamicState.VK_DYNAMIC_STATE_SCISSOR": "ename:VK_DYNAMIC_STATE_SCISSOR indicates that the pname:pScissors state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetScissor before any draw commands. The number of scissor rectangles used by a pipeline is still specified by the pname:scissorCount member of sname:VkPipelineViewportStateCreateInfo.",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK": "ename:VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK indicates that the pname:compareMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilCompareMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_REFERENCE": "ename:VK_DYNAMIC_STATE_STENCIL_REFERENCE indicates that the pname:reference state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilReference before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_STENCIL_WRITE_MASK": "ename:VK_DYNAMIC_STATE_STENCIL_WRITE_MASK indicates that the pname:writeMask state in sname:VkPipelineDepthStencilStateCreateInfo for both pname:front and pname:back will be ignored and must: be set dynamically with flink:vkCmdSetStencilWriteMask before any draws are performed with a pipeline state with sname:VkPipelineDepthStencilStateCreateInfo member pname:stencilTestEnable set to ename:VK_TRUE",
  "VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT": "ename:VK_DYNAMIC_STATE_VIEWPORT indicates that the pname:pViewports state in sname:VkPipelineViewportStateCreateInfo will be ignored and must: be set dynamically with flink:vkCmdSetViewport before any draw commands. The number of viewports used by a pipeline is still specified by the pname:viewportCount member of sname:VkPipelineViewportStateCreateInfo.",
  "VkDynamicState.VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV": "",
  "vkEndCommandBuffer": "Finish recording a command buffer.",
  "vkEndCommandBuffer.commandBuffer": "",
  "vkEnumerateDeviceExtensionProperties": "Returns properties of available physical device extensions.",
  "vkEnumerateDeviceExtensionProperties.physicalDevice": "",
  "vkEnumerateDeviceExtensionProperties.pLayerName": "",
  "vkEnumerateDeviceExtensionProperties.pProperties": "",
  "vkEnumerateDeviceExtensionProperties.pPropertyCount": "",
  "vkEnumerateDeviceLayerProperties": "Returns properties of available physical device layers.",
  "vkEnumerateDeviceLayerProperties.physicalDevice": "",
  "vkEnumerateDeviceLayerProperties.pProperties": "",
  "vkEnumerateDeviceLayerProperties.pPropertyCount": "",
  "vkEnumerateInstanceExtensionProperties": "Returns up to requested number of global extension properties.",
  "vkEnumerateInstanceExtensionProperties.pLayerName": "",
  "vkEnumerateInstanceExtensionProperties.pProperties": "",
  "vkEnumerateInstanceExtensionProperties.pPropertyCount": "",
  "vkEnumerateInstanceLayerProperties": "Returns up to requested number of global layer properties.",
  "vkEnumerateInstanceLayerProperties.pProperties": "",
  "vkEnumerateInstanceLayerProperties.pPropertyCount": "",
  "vkEnumeratePhysicalDeviceGroupsKHX": "Enumerates groups of physical devices that can be used to create a single logical device.",
  "vkEnumeratePhysicalDeviceGroupsKHX.instance": "",
  "vkEnumeratePhysicalDeviceGroupsKHX.pPhysicalDeviceGroupCount": "",
  "vkEnumeratePhysicalDeviceGroupsKHX.pPhysicalDeviceGroupProperties": "",
  "vkEnumeratePhysicalDevices": "Enumerates the physical devices accessible to a Vulkan instance.",
  "vkEnumeratePhysicalDevices.instance": "",
  "vkEnumeratePhysicalDevices.pPhysicalDeviceCount": "",
  "vkEnumeratePhysicalDevices.pPhysicalDevices": "",
  "VkEvent": "Opaque handle to a event object.",
  "VkEventCreateFlags": "",
  "VkEventCreateFlags.__none": "",
  "VkEventCreateInfo": "Structure specifying parameters of a newly created event.",
  "VkEventCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkEventCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkEventCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkExportFenceCreateInfoKHR": "",
  "VkExportFenceCreateInfoKHR.handleTypes": "",
  "VkExportFenceCreateInfoKHR.pNext": "",
  "VkExportFenceCreateInfoKHR.sType": "",
  "VkExportFenceWin32HandleInfoKHR": "",
  "VkExportFenceWin32HandleInfoKHR.dwAccess": "",
  "VkExportFenceWin32HandleInfoKHR.name": "",
  "VkExportFenceWin32HandleInfoKHR.pAttributes": "",
  "VkExportFenceWin32HandleInfoKHR.pNext": "",
  "VkExportFenceWin32HandleInfoKHR.sType": "",
  "VkExportMemoryAllocateInfoKHR": "",
  "VkExportMemoryAllocateInfoKHR.handleTypes": "",
  "VkExportMemoryAllocateInfoKHR.pNext": "",
  "VkExportMemoryAllocateInfoKHR.sType": "",
  "VkExportMemoryAllocateInfoNV": "",
  "VkExportMemoryAllocateInfoNV.handleTypes": "",
  "VkExportMemoryAllocateInfoNV.pNext": "",
  "VkExportMemoryAllocateInfoNV.sType": "",
  "VkExportMemoryWin32HandleInfoKHR": "",
  "VkExportMemoryWin32HandleInfoKHR.dwAccess": "",
  "VkExportMemoryWin32HandleInfoKHR.name": "",
  "VkExportMemoryWin32HandleInfoKHR.pAttributes": "",
  "VkExportMemoryWin32HandleInfoKHR.pNext": "",
  "VkExportMemoryWin32HandleInfoKHR.sType": "",
  "VkExportMemoryWin32HandleInfoNV": "Specify security attributes and access rights for Win32 memory handles.",
  "VkExportMemoryWin32HandleInfoNV.dwAccess": "pname:dwAccess is a code:DWORD specifying access rights of the handle.",
  "VkExportMemoryWin32HandleInfoNV.pAttributes": "pname:pAttributes is a pointer to a Windows code:SECURITY_ATTRIBUTES structure specifying security attributes of the handle.",
  "VkExportMemoryWin32HandleInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkExportMemoryWin32HandleInfoNV.sType": "pname:sType is the type of this structure.",
  "VkExportSemaphoreCreateInfoKHR": "",
  "VkExportSemaphoreCreateInfoKHR.handleTypes": "",
  "VkExportSemaphoreCreateInfoKHR.pNext": "",
  "VkExportSemaphoreCreateInfoKHR.sType": "",
  "VkExportSemaphoreWin32HandleInfoKHR": "",
  "VkExportSemaphoreWin32HandleInfoKHR.dwAccess": "",
  "VkExportSemaphoreWin32HandleInfoKHR.name": "",
  "VkExportSemaphoreWin32HandleInfoKHR.pAttributes": "",
  "VkExportSemaphoreWin32HandleInfoKHR.pNext": "",
  "VkExportSemaphoreWin32HandleInfoKHR.sType": "",
  "VkExtensionProperties": "Structure specifying a extension properties.",
  "VkExtensionProperties.extensionName": "pname:extensionName is a null-terminated string specifying the name of the extension.",
  "VkExtensionProperties.specVersion": "pname:specVersion is the version of this extension. It is an integer, incremented with backward compatible changes.",
  "VkExtent2D": "Structure specifying a two-dimensional extent.",
  "VkExtent2D.height": "",
  "VkExtent2D.width": "",
  "VkExtent3D": "Structure specifying a three-dimensional extent.",
  "VkExtent3D.depth": "",
  "VkExtent3D.height": "",
  "VkExtent3D.width": "",
  "VkExternalBufferPropertiesKHR": "",
  "VkExternalBufferPropertiesKHR.externalMemoryProperties": "",
  "VkExternalBufferPropertiesKHR.pNext": "",
  "VkExternalBufferPropertiesKHR.sType": "",
  "VkExternalFenceFeatureFlagBitsKHR": "",
  "VkExternalFenceFeatureFlagsKHR": "",
  "VkExternalFenceFeatureFlagsKHR.__none": "",
  "VkExternalFenceFeatureFlagsKHR.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalFenceFeatureFlagsKHR.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagBitsKHR": "",
  "VkExternalFenceHandleTypeFlagsKHR": "",
  "VkExternalFenceHandleTypeFlagsKHR.__none": "",
  "VkExternalFenceHandleTypeFlagsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalFenceHandleTypeFlagsKHR.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR": "",
  "VkExternalFencePropertiesKHR": "",
  "VkExternalFencePropertiesKHR.compatibleHandleTypes": "",
  "VkExternalFencePropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalFencePropertiesKHR.externalFenceFeatures": "",
  "VkExternalFencePropertiesKHR.pNext": "",
  "VkExternalFencePropertiesKHR.sType": "",
  "VkExternalImageFormatPropertiesKHR": "",
  "VkExternalImageFormatPropertiesKHR.externalMemoryProperties": "",
  "VkExternalImageFormatPropertiesKHR.pNext": "",
  "VkExternalImageFormatPropertiesKHR.sType": "",
  "VkExternalImageFormatPropertiesNV": "Structure specifying external image format properties.",
  "VkExternalImageFormatPropertiesNV.compatibleHandleTypes": "pname:compatibleHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be specified simultaneously with the handle type specified by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType when calling flink:vkAllocateMemory, or 0 if the external memory handle type is 0. pname:compatibleHandleTypes will always contain flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType",
  "VkExternalImageFormatPropertiesNV.exportFromImportedHandleTypes": "pname:exportFromImportedHandleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV containing a bit set for every external handle type that may: be used to create memory from which the handles of the type specified in flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType can: be exported, or 0 if the external memory handle type is 0.",
  "VkExternalImageFormatPropertiesNV.externalMemoryFeatures": "pname:externalMemoryFeatures is a bitmask of elink:VkExternalMemoryFeatureFlagBitsNV indicating properties of the external memory handle type (flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV::pname:externalHandleType) being queried, or 0 if the external memory handle type is 0.",
  "VkExternalImageFormatPropertiesNV.imageFormatProperties": "pname:imageFormatProperties will be filled in as when calling flink:vkGetPhysicalDeviceImageFormatProperties, but the values returned may: vary depending on the external handle type requested.",
  "VkExternalMemoryBufferCreateInfoKHR": "",
  "VkExternalMemoryBufferCreateInfoKHR.handleTypes": "",
  "VkExternalMemoryBufferCreateInfoKHR.pNext": "",
  "VkExternalMemoryBufferCreateInfoKHR.sType": "",
  "VkExternalMemoryFeatureFlagBitsKHR": "",
  "VkExternalMemoryFeatureFlagBitsNV": "Bitmask specifying external memory features.",
  "VkExternalMemoryFeatureFlagsKHR": "",
  "VkExternalMemoryFeatureFlagsKHR.__none": "",
  "VkExternalMemoryFeatureFlagsKHR.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagsKHR.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagsKHR.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalMemoryFeatureFlagsNV": "",
  "VkExternalMemoryFeatureFlagsNV.__none": "",
  "VkExternalMemoryFeatureFlagsNV.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV": "",
  "VkExternalMemoryFeatureFlagsNV.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV": "",
  "VkExternalMemoryFeatureFlagsNV.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagBitsKHR": "",
  "VkExternalMemoryHandleTypeFlagBitsNV": "Bitmask specifying memory handle types.",
  "VkExternalMemoryHandleTypeFlagsKHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.__none": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsKHR.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalMemoryHandleTypeFlagsNV": "",
  "VkExternalMemoryHandleTypeFlagsNV.__none": "",
  "VkExternalMemoryHandleTypeFlagsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV": "",
  "VkExternalMemoryHandleTypeFlagsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV": "",
  "VkExternalMemoryImageCreateInfoKHR": "",
  "VkExternalMemoryImageCreateInfoKHR.handleTypes": "",
  "VkExternalMemoryImageCreateInfoKHR.pNext": "",
  "VkExternalMemoryImageCreateInfoKHR.sType": "",
  "VkExternalMemoryImageCreateInfoNV": "Specify that an image may be backed by external memory.",
  "VkExternalMemoryImageCreateInfoNV.handleTypes": "pname:handleTypes is a bitmask of elink:VkExternalMemoryHandleTypeFlagBitsNV specifying one or more external memory handle types. The types must: all be compatible with each other and the other image creation parameters, as reported by flink:vkGetPhysicalDeviceExternalImageFormatPropertiesNV.",
  "VkExternalMemoryImageCreateInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkExternalMemoryImageCreateInfoNV.sType": "pname:sType is the type of this structure.",
  "VkExternalMemoryPropertiesKHR": "",
  "VkExternalMemoryPropertiesKHR.compatibleHandleTypes": "",
  "VkExternalMemoryPropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalMemoryPropertiesKHR.externalMemoryFeatures": "",
  "VkExternalSemaphoreFeatureFlagBitsKHR": "",
  "VkExternalSemaphoreFeatureFlagsKHR": "",
  "VkExternalSemaphoreFeatureFlagsKHR.__none": "",
  "VkExternalSemaphoreFeatureFlagsKHR.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR": "",
  "VkExternalSemaphoreFeatureFlagsKHR.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagBitsKHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.__none": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR": "",
  "VkExternalSemaphoreHandleTypeFlagsKHR.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR": "",
  "VkExternalSemaphorePropertiesKHR": "",
  "VkExternalSemaphorePropertiesKHR.compatibleHandleTypes": "",
  "VkExternalSemaphorePropertiesKHR.exportFromImportedHandleTypes": "",
  "VkExternalSemaphorePropertiesKHR.externalSemaphoreFeatures": "",
  "VkExternalSemaphorePropertiesKHR.pNext": "",
  "VkExternalSemaphorePropertiesKHR.sType": "",
  "VkFence": "Opaque handle to a fence object.",
  "VkFenceCreateFlagBits": "Bitmask specifying initial state and behavior of a fence.",
  "VkFenceCreateFlags": "",
  "VkFenceCreateFlags.__none": "",
  "VkFenceCreateFlags.VK_FENCE_CREATE_SIGNALED_BIT": "",
  "VkFenceCreateInfo": "Structure specifying parameters of a newly created fence.",
  "VkFenceCreateInfo.flags": "pname:flags defines the initial state and behavior of the fence. Bits which can: be set include: + --",
  "VkFenceCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkFenceCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkFenceGetFdInfoKHR": "",
  "VkFenceGetFdInfoKHR.fence": "",
  "VkFenceGetFdInfoKHR.handleType": "",
  "VkFenceGetFdInfoKHR.pNext": "",
  "VkFenceGetFdInfoKHR.sType": "",
  "VkFenceGetWin32HandleInfoKHR": "",
  "VkFenceGetWin32HandleInfoKHR.fence": "",
  "VkFenceGetWin32HandleInfoKHR.handleType": "",
  "VkFenceGetWin32HandleInfoKHR.pNext": "",
  "VkFenceGetWin32HandleInfoKHR.sType": "",
  "VkFenceImportFlagBitsKHR": "",
  "VkFenceImportFlagsKHR": "",
  "VkFenceImportFlagsKHR.__none": "",
  "VkFenceImportFlagsKHR.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR": "",
  "VkFilter": "Specify filters used for texture lookups.",
  "VkFilter.VK_FILTER_CUBIC_IMG": "",
  "VkFilter.VK_FILTER_LINEAR": "",
  "VkFilter.VK_FILTER_NEAREST": "",
  "VkFlags": "Vulkan bitmasks.",
  "vkFlushMappedMemoryRanges": "Flush mapped memory ranges.",
  "vkFlushMappedMemoryRanges.device": "",
  "vkFlushMappedMemoryRanges.memoryRangeCount": "",
  "vkFlushMappedMemoryRanges.pMemoryRanges": "",
  "VkFormat": "Available image formats.",
  "VkFormat.VK_FORMAT_A1R5G5B5_UNORM_PACK16": "ename:VK_FORMAT_A1R5G5B5_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 1-bit A component in bit 15, a 5-bit R component in bits 10..14, a 5-bit G component in bits 5..9, and a 5-bit B component in bits 0..4.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SINT_PACK32": "ename:VK_FORMAT_A2B10G10R10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SNORM_PACK32": "ename:VK_FORMAT_A2B10G10R10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_SSCALED_PACK32": "ename:VK_FORMAT_A2B10G10R10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_UINT_PACK32": "ename:VK_FORMAT_A2B10G10R10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_UNORM_PACK32": "ename:VK_FORMAT_A2B10G10R10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2B10G10R10_USCALED_PACK32": "ename:VK_FORMAT_A2B10G10R10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit R component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SINT_PACK32": "ename:VK_FORMAT_A2R10G10B10_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SNORM_PACK32": "ename:VK_FORMAT_A2R10G10B10_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_SSCALED_PACK32": "ename:VK_FORMAT_A2R10G10B10_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_UINT_PACK32": "ename:VK_FORMAT_A2R10G10B10_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_UNORM_PACK32": "ename:VK_FORMAT_A2R10G10B10_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A2R10G10B10_USCALED_PACK32": "ename:VK_FORMAT_A2R10G10B10_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has a 2-bit A component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component in bits 10..19, and a 10-bit B component in bits 0..9.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SINT_PACK32": "ename:VK_FORMAT_A8B8G8R8_SINT_PACK32:: A four-component, 32-bit packed signed integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SNORM_PACK32": "ename:VK_FORMAT_A8B8G8R8_SNORM_PACK32:: A four-component, 32-bit packed signed normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SRGB_PACK32": "ename:VK_FORMAT_A8B8G8R8_SRGB_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits 16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits 8..15, and an 8-bit R component stored with sRGB nonlinear encoding in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_SSCALED_PACK32": "ename:VK_FORMAT_A8B8G8R8_SSCALED_PACK32:: A four-component, 32-bit packed signed scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_UINT_PACK32": "ename:VK_FORMAT_A8B8G8R8_UINT_PACK32:: A four-component, 32-bit packed unsigned integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_UNORM_PACK32": "ename:VK_FORMAT_A8B8G8R8_UNORM_PACK32:: A four-component, 32-bit packed unsigned normalized format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_A8B8G8R8_USCALED_PACK32": "ename:VK_FORMAT_A8B8G8R8_USCALED_PACK32:: A four-component, 32-bit packed unsigned scaled integer format that has an 8-bit A component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G component in bits 8..15, and an 8-bit R component in bits 0..7.",
  "VkFormat.VK_FORMAT_ASTC_10x10_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_10x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x10_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_10x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x10 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x5_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_10x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x5_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_10x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x6_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_10x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x6_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_10x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_10x8_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_10x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_10x8_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_10x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 10x8 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_12x10_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_12x10_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_12x10_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_12x10_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x10 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_12x12_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_12x12_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_12x12_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_12x12_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 12x12 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_4x4_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_4x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_4x4_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_4x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_5x4_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_5x4_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_5x4_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_5x4_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_5x5_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_5x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_5x5_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_5x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 5x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_6x5_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_6x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_6x5_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_6x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_6x6_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_6x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_6x6_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_6x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes a 6x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x5_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_8x5_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x5_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_8x5_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x5 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x6_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_8x6_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x6_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_8x6_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x6 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_ASTC_8x8_SRGB_BLOCK": "ename:VK_FORMAT_ASTC_8x8_SRGB_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_ASTC_8x8_UNORM_BLOCK": "ename:VK_FORMAT_ASTC_8x8_UNORM_BLOCK:: A four-component, ASTC compressed format where each 128-bit compressed texel block encodes an 8x8 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_B10G11R11_UFLOAT_PACK32": "ename:VK_FORMAT_B10G11R11_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 10-bit B component in bits 22..31, an 11-bit G component in bits 11..21, an 11-bit R component in bits 0..10. See <<fundamentals-fp10>> and <<fundamentals-fp11>>.",
  "VkFormat.VK_FORMAT_B4G4R4A4_UNORM_PACK16": "ename:VK_FORMAT_B4G4R4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit B component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits 4..7, and a 4-bit A component in bits 0..3.",
  "VkFormat.VK_FORMAT_B5G5R5A1_UNORM_PACK16": "ename:VK_FORMAT_B5G5R5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits 1..5, and a 1-bit A component in bit 0.",
  "VkFormat.VK_FORMAT_B5G6R5_UNORM_PACK16": "ename:VK_FORMAT_B5G6R5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit B component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in bits 0..4.",
  "VkFormat.VK_FORMAT_B8G8R8_SINT": "ename:VK_FORMAT_B8G8R8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SNORM": "ename:VK_FORMAT_B8G8R8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SRGB": "ename:VK_FORMAT_B8G8R8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB nonlinear encoding in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_SSCALED": "ename:VK_FORMAT_B8G8R8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_UINT": "ename:VK_FORMAT_B8G8R8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_UNORM": "ename:VK_FORMAT_B8G8R8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8_USCALED": "ename:VK_FORMAT_B8G8R8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, and an 8-bit R component in byte 2.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SINT": "ename:VK_FORMAT_B8G8R8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SNORM": "ename:VK_FORMAT_B8G8R8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SRGB": "ename:VK_FORMAT_B8G8R8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit R component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_SSCALED": "ename:VK_FORMAT_B8G8R8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_UINT": "ename:VK_FORMAT_B8G8R8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_UNORM": "ename:VK_FORMAT_B8G8R8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_B8G8R8A8_USCALED": "ename:VK_FORMAT_B8G8R8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_BC1_RGB_SRGB_BLOCK": "ename:VK_FORMAT_BC1_RGB_SRGB_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_BC1_RGB_UNORM_BLOCK": "ename:VK_FORMAT_BC1_RGB_UNORM_BLOCK:: A three-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_BC1_RGBA_SRGB_BLOCK": "ename:VK_FORMAT_BC1_RGBA_SRGB_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_BC1_RGBA_UNORM_BLOCK": "ename:VK_FORMAT_BC1_RGBA_UNORM_BLOCK:: A four-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_BC2_SRGB_BLOCK": "ename:VK_FORMAT_BC2_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_BC2_UNORM_BLOCK": "ename:VK_FORMAT_BC2_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_BC3_SRGB_BLOCK": "ename:VK_FORMAT_BC3_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_BC3_UNORM_BLOCK": "ename:VK_FORMAT_BC3_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_BC4_SNORM_BLOCK": "ename:VK_FORMAT_BC4_SNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.",
  "VkFormat.VK_FORMAT_BC4_UNORM_BLOCK": "ename:VK_FORMAT_BC4_UNORM_BLOCK:: A one-component, block-compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.",
  "VkFormat.VK_FORMAT_BC5_SNORM_BLOCK": "ename:VK_FORMAT_BC5_SNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_BC5_UNORM_BLOCK": "ename:VK_FORMAT_BC5_UNORM_BLOCK:: A two-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_BC6H_SFLOAT_BLOCK": "ename:VK_FORMAT_BC6H_SFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed floating-point RGB texel data.",
  "VkFormat.VK_FORMAT_BC6H_UFLOAT_BLOCK": "ename:VK_FORMAT_BC6H_UFLOAT_BLOCK:: A three-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned floating-point RGB texel data.",
  "VkFormat.VK_FORMAT_BC7_SRGB_BLOCK": "ename:VK_FORMAT_BC7_SRGB_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with sRGB nonlinear encoding applied to the RGB components.",
  "VkFormat.VK_FORMAT_BC7_UNORM_BLOCK": "ename:VK_FORMAT_BC7_UNORM_BLOCK:: A four-component, block-compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data.",
  "VkFormat.VK_FORMAT_D16_UNORM": "ename:VK_FORMAT_D16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit depth component.",
  "VkFormat.VK_FORMAT_D16_UNORM_S8_UINT": "ename:VK_FORMAT_D16_UNORM_S8_UINT:: A two-component, 24-bit format that has 16 unsigned normalized bits in the depth component and 8 unsigned integer bits in the stencil component.",
  "VkFormat.VK_FORMAT_D24_UNORM_S8_UINT": "ename:VK_FORMAT_D24_UNORM_S8_UINT:: A two-component, 32-bit packed format that has 8 unsigned integer bits in the stencil component, and 24 unsigned normalized bits in the depth component.",
  "VkFormat.VK_FORMAT_D32_SFLOAT": "ename:VK_FORMAT_D32_SFLOAT:: A one-component, 32-bit signed floating-point format that has 32-bits in the depth component.",
  "VkFormat.VK_FORMAT_D32_SFLOAT_S8_UINT": "ename:VK_FORMAT_D32_SFLOAT_S8_UINT:: A two-component format that has 32 signed float bits in the depth component and 8 unsigned integer bits in the stencil component. There are optionally: 24-bits that are unused.",
  "VkFormat.VK_FORMAT_E5B9G9R9_UFLOAT_PACK32": "ename:VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:: A three-component, 32-bit packed unsigned floating-point format that has a 5-bit shared exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a 9-bit G component mantissa in bits 9..17, and a 9-bit R component mantissa in bits 0..8.",
  "VkFormat.VK_FORMAT_EAC_R11_SNORM_BLOCK": "ename:VK_FORMAT_EAC_R11_SNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of signed normalized red texel data.",
  "VkFormat.VK_FORMAT_EAC_R11_UNORM_BLOCK": "ename:VK_FORMAT_EAC_R11_UNORM_BLOCK:: A one-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized red texel data.",
  "VkFormat.VK_FORMAT_EAC_R11G11_SNORM_BLOCK": "ename:VK_FORMAT_EAC_R11G11_SNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of signed normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_EAC_R11G11_UNORM_BLOCK": "ename:VK_FORMAT_EAC_R11G11_UNORM_BLOCK:: A two-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RG texel data with the first 64 bits encoding red values followed by 64 bits encoding green values.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:: A three-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data. This format has no alpha and is considered opaque.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data with sRGB nonlinear encoding, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGB texel data, and provides 1 bit of alpha.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:: A four-component, ETC2 compressed format where each 64-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values with sRGB nonlinear encoding applied.",
  "VkFormat.VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK": "ename:VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:: A four-component, ETC2 compressed format where each 128-bit compressed texel block encodes a 4x4 rectangle of unsigned normalized RGBA texel data with the first 64 bits encoding alpha values followed by 64 bits encoding RGB values.",
  "VkFormat.VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG": "",
  "VkFormat.VK_FORMAT_R16_SFLOAT": "ename:VK_FORMAT_R16_SFLOAT:: A one-component, 16-bit signed floating-point format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SINT": "ename:VK_FORMAT_R16_SINT:: A one-component, 16-bit signed integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SNORM": "ename:VK_FORMAT_R16_SNORM:: A one-component, 16-bit signed normalized format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_SSCALED": "ename:VK_FORMAT_R16_SSCALED:: A one-component, 16-bit signed scaled integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_UINT": "ename:VK_FORMAT_R16_UINT:: A one-component, 16-bit unsigned integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_UNORM": "ename:VK_FORMAT_R16_UNORM:: A one-component, 16-bit unsigned normalized format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16_USCALED": "ename:VK_FORMAT_R16_USCALED:: A one-component, 16-bit unsigned scaled integer format that has a single 16-bit R component.",
  "VkFormat.VK_FORMAT_R16G16_SFLOAT": "ename:VK_FORMAT_R16G16_SFLOAT:: A two-component, 32-bit signed floating-point format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SINT": "ename:VK_FORMAT_R16G16_SINT:: A two-component, 32-bit signed integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SNORM": "ename:VK_FORMAT_R16G16_SNORM:: A two-component, 32-bit signed normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_SSCALED": "ename:VK_FORMAT_R16G16_SSCALED:: A two-component, 32-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_UINT": "ename:VK_FORMAT_R16G16_UINT:: A two-component, 32-bit unsigned integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_UNORM": "ename:VK_FORMAT_R16G16_UNORM:: A two-component, 32-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16_USCALED": "ename:VK_FORMAT_R16G16_USCALED:: A two-component, 32-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, and a 16-bit G component in bytes 2..3.",
  "VkFormat.VK_FORMAT_R16G16B16_SFLOAT": "ename:VK_FORMAT_R16G16B16_SFLOAT:: A three-component, 48-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SINT": "ename:VK_FORMAT_R16G16B16_SINT:: A three-component, 48-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SNORM": "ename:VK_FORMAT_R16G16B16_SNORM:: A three-component, 48-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_SSCALED": "ename:VK_FORMAT_R16G16B16_SSCALED:: A three-component, 48-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_UINT": "ename:VK_FORMAT_R16G16B16_UINT:: A three-component, 48-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_UNORM": "ename:VK_FORMAT_R16G16B16_UNORM:: A three-component, 48-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16_USCALED": "ename:VK_FORMAT_R16G16B16_USCALED:: A three-component, 48-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes 4..5.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SFLOAT": "ename:VK_FORMAT_R16G16B16A16_SFLOAT:: A four-component, 64-bit signed floating-point format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SINT": "ename:VK_FORMAT_R16G16B16A16_SINT:: A four-component, 64-bit signed integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SNORM": "ename:VK_FORMAT_R16G16B16A16_SNORM:: A four-component, 64-bit signed normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_SSCALED": "ename:VK_FORMAT_R16G16B16A16_SSCALED:: A four-component, 64-bit signed scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_UINT": "ename:VK_FORMAT_R16G16B16A16_UINT:: A four-component, 64-bit unsigned integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_UNORM": "ename:VK_FORMAT_R16G16B16A16_UNORM:: A four-component, 64-bit unsigned normalized format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R16G16B16A16_USCALED": "ename:VK_FORMAT_R16G16B16A16_USCALED:: A four-component, 64-bit unsigned scaled integer format that has a 16-bit R component in bytes 0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5, and a 16-bit A component in bytes 6..7.",
  "VkFormat.VK_FORMAT_R32_SFLOAT": "ename:VK_FORMAT_R32_SFLOAT:: A one-component, 32-bit signed floating-point format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32_SINT": "ename:VK_FORMAT_R32_SINT:: A one-component, 32-bit signed integer format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32_UINT": "ename:VK_FORMAT_R32_UINT:: A one-component, 32-bit unsigned integer format that has a single 32-bit R component.",
  "VkFormat.VK_FORMAT_R32G32_SFLOAT": "ename:VK_FORMAT_R32G32_SFLOAT:: A two-component, 64-bit signed floating-point format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32_SINT": "ename:VK_FORMAT_R32G32_SINT:: A two-component, 64-bit signed integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32_UINT": "ename:VK_FORMAT_R32G32_UINT:: A two-component, 64-bit unsigned integer format that has a 32-bit R component in bytes 0..3, and a 32-bit G component in bytes 4..7.",
  "VkFormat.VK_FORMAT_R32G32B32_SFLOAT": "ename:VK_FORMAT_R32G32B32_SFLOAT:: A three-component, 96-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32_SINT": "ename:VK_FORMAT_R32G32B32_SINT:: A three-component, 96-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32_UINT": "ename:VK_FORMAT_R32G32B32_UINT:: A three-component, 96-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in bytes 8..11.",
  "VkFormat.VK_FORMAT_R32G32B32A32_SFLOAT": "ename:VK_FORMAT_R32G32B32A32_SFLOAT:: A four-component, 128-bit signed floating-point format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R32G32B32A32_SINT": "ename:VK_FORMAT_R32G32B32A32_SINT:: A four-component, 128-bit signed integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R32G32B32A32_UINT": "ename:VK_FORMAT_R32G32B32A32_UINT:: A four-component, 128-bit unsigned integer format that has a 32-bit R component in bytes 0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11, and a 32-bit A component in bytes 12..15.",
  "VkFormat.VK_FORMAT_R4G4_UNORM_PACK8": "ename:VK_FORMAT_R4G4_UNORM_PACK8:: A two-component, 8-bit packed unsigned normalized format that has a 4-bit R component in bits 4..7, and a 4-bit G component in bits 0..3.",
  "VkFormat.VK_FORMAT_R4G4B4A4_UNORM_PACK16": "ename:VK_FORMAT_R4G4B4A4_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 4-bit R component in bits 12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits 4..7, and a 4-bit A component in bits 0..3.",
  "VkFormat.VK_FORMAT_R5G5B5A1_UNORM_PACK16": "ename:VK_FORMAT_R5G5B5A1_UNORM_PACK16:: A four-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits 1..5, and a 1-bit A component in bit 0.",
  "VkFormat.VK_FORMAT_R5G6B5_UNORM_PACK16": "ename:VK_FORMAT_R5G6B5_UNORM_PACK16:: A three-component, 16-bit packed unsigned normalized format that has a 5-bit R component in bits 11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in bits 0..4.",
  "VkFormat.VK_FORMAT_R64_SFLOAT": "ename:VK_FORMAT_R64_SFLOAT:: A one-component, 64-bit signed floating-point format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64_SINT": "ename:VK_FORMAT_R64_SINT:: A one-component, 64-bit signed integer format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64_UINT": "ename:VK_FORMAT_R64_UINT:: A one-component, 64-bit unsigned integer format that has a single 64-bit R component.",
  "VkFormat.VK_FORMAT_R64G64_SFLOAT": "ename:VK_FORMAT_R64G64_SFLOAT:: A two-component, 128-bit signed floating-point format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64_SINT": "ename:VK_FORMAT_R64G64_SINT:: A two-component, 128-bit signed integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64_UINT": "ename:VK_FORMAT_R64G64_UINT:: A two-component, 128-bit unsigned integer format that has a 64-bit R component in bytes 0..7, and a 64-bit G component in bytes 8..15.",
  "VkFormat.VK_FORMAT_R64G64B64_SFLOAT": "ename:VK_FORMAT_R64G64B64_SFLOAT:: A three-component, 192-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64_SINT": "ename:VK_FORMAT_R64G64B64_SINT:: A three-component, 192-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64_UINT": "ename:VK_FORMAT_R64G64B64_UINT:: A three-component, 192-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in bytes 16..23.",
  "VkFormat.VK_FORMAT_R64G64B64A64_SFLOAT": "ename:VK_FORMAT_R64G64B64A64_SFLOAT:: A four-component, 256-bit signed floating-point format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R64G64B64A64_SINT": "ename:VK_FORMAT_R64G64B64A64_SINT:: A four-component, 256-bit signed integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R64G64B64A64_UINT": "ename:VK_FORMAT_R64G64B64A64_UINT:: A four-component, 256-bit unsigned integer format that has a 64-bit R component in bytes 0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23, and a 64-bit A component in bytes 24..31.",
  "VkFormat.VK_FORMAT_R8_SINT": "ename:VK_FORMAT_R8_SINT:: A one-component, 8-bit signed integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_SNORM": "ename:VK_FORMAT_R8_SNORM:: A one-component, 8-bit signed normalized format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_SRGB": "ename:VK_FORMAT_R8_SRGB:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component stored with sRGB nonlinear encoding.",
  "VkFormat.VK_FORMAT_R8_SSCALED": "ename:VK_FORMAT_R8_SSCALED:: A one-component, 8-bit signed scaled integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_UINT": "ename:VK_FORMAT_R8_UINT:: A one-component, 8-bit unsigned integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_UNORM": "ename:VK_FORMAT_R8_UNORM:: A one-component, 8-bit unsigned normalized format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8_USCALED": "ename:VK_FORMAT_R8_USCALED:: A one-component, 8-bit unsigned scaled integer format that has a single 8-bit R component.",
  "VkFormat.VK_FORMAT_R8G8_SINT": "ename:VK_FORMAT_R8G8_SINT:: A two-component, 16-bit signed integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SNORM": "ename:VK_FORMAT_R8G8_SNORM:: A two-component, 16-bit signed normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SRGB": "ename:VK_FORMAT_R8G8_SRGB:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB nonlinear encoding in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_SSCALED": "ename:VK_FORMAT_R8G8_SSCALED:: A two-component, 16-bit signed scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_UINT": "ename:VK_FORMAT_R8G8_UINT:: A two-component, 16-bit unsigned integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_UNORM": "ename:VK_FORMAT_R8G8_UNORM:: A two-component, 16-bit unsigned normalized format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8_USCALED": "ename:VK_FORMAT_R8G8_USCALED:: A two-component, 16-bit unsigned scaled integer format that has an 8-bit R component in byte 0, and an 8-bit G component in byte 1.",
  "VkFormat.VK_FORMAT_R8G8B8_SINT": "ename:VK_FORMAT_R8G8B8_SINT:: A three-component, 24-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SNORM": "ename:VK_FORMAT_R8G8B8_SNORM:: A three-component, 24-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SRGB": "ename:VK_FORMAT_R8G8B8_SRGB:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB nonlinear encoding in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_SSCALED": "ename:VK_FORMAT_R8G8B8_SSCALED:: A three-component, 24-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_UINT": "ename:VK_FORMAT_R8G8B8_UINT:: A three-component, 24-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_UNORM": "ename:VK_FORMAT_R8G8B8_UNORM:: A three-component, 24-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8_USCALED": "ename:VK_FORMAT_R8G8B8_USCALED:: A three-component, 24-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, and an 8-bit B component in byte 2.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SINT": "ename:VK_FORMAT_R8G8B8A8_SINT:: A four-component, 32-bit signed integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SNORM": "ename:VK_FORMAT_R8G8B8A8_SNORM:: A four-component, 32-bit signed normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SRGB": "ename:VK_FORMAT_R8G8B8A8_SRGB:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component stored with sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB nonlinear encoding in byte 1, an 8-bit B component stored with sRGB nonlinear encoding in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_SSCALED": "ename:VK_FORMAT_R8G8B8A8_SSCALED:: A four-component, 32-bit signed scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_UINT": "ename:VK_FORMAT_R8G8B8A8_UINT:: A four-component, 32-bit unsigned integer format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_UNORM": "ename:VK_FORMAT_R8G8B8A8_UNORM:: A four-component, 32-bit unsigned normalized format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_R8G8B8A8_USCALED": "ename:VK_FORMAT_R8G8B8A8_USCALED:: A four-component, 32-bit unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A component in byte 3.",
  "VkFormat.VK_FORMAT_S8_UINT": "ename:VK_FORMAT_S8_UINT:: A one-component, 8-bit unsigned integer format that has 8-bits in the stencil component.",
  "VkFormat.VK_FORMAT_UNDEFINED": "ename:VK_FORMAT_UNDEFINED:: The format is not specified.",
  "VkFormat.VK_FORMAT_X8_D24_UNORM_PACK32": "ename:VK_FORMAT_X8_D24_UNORM_PACK32:: A two-component, 32-bit format that has 24 unsigned normalized bits in the depth component and, optionally:, 8 bits that are unused.",
  "VkFormatFeatureFlagBits": "Bitmask specifying features supported by a buffer.",
  "VkFormatFeatureFlags": "",
  "VkFormatFeatureFlags.__none": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_BLIT_DST_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_BLIT_SRC_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT": "",
  "VkFormatFeatureFlags.VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT": "",
  "VkFormatProperties": "Structure specifying image format properties.",
  "VkFormatProperties.bufferFeatures": "pname:bufferFeatures describes the features supported by buffers.",
  "VkFormatProperties.linearTilingFeatures": "pname:linearTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_LINEAR.",
  "VkFormatProperties.optimalTilingFeatures": "pname:optimalTilingFeatures describes the features supported by ename:VK_IMAGE_TILING_OPTIMAL.",
  "VkFormatProperties2KHR": "Structure specifying image format properties.",
  "VkFormatProperties2KHR.formatProperties": "pname:formatProperties is a structure of type slink:VkFormatProperties describing features supported by the requested format.",
  "VkFormatProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkFormatProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkFramebuffer": "Opaque handle to a framebuffer object.",
  "VkFramebufferCreateFlagBits": "",
  "VkFramebufferCreateFlags": "",
  "VkFramebufferCreateFlags.__none": "",
  "VkFramebufferCreateInfo": "Structure specifying parameters of a newly created framebuffer.",
  "VkFramebufferCreateInfo.attachmentCount": "pname:attachmentCount is the number of attachments.",
  "VkFramebufferCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkFramebufferCreateInfo.height": "",
  "VkFramebufferCreateInfo.layers": "",
  "VkFramebufferCreateInfo.pAttachments": "pname:pAttachments is an array of sname:VkImageView handles, each of which will be used as the corresponding attachment in a render pass instance.",
  "VkFramebufferCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkFramebufferCreateInfo.renderPass": "pname:renderPass is a render pass that defines what render passes the framebuffer will be compatible with. See <<renderpass-compatibility,Render Pass Compatibility>> for details.",
  "VkFramebufferCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkFramebufferCreateInfo.width": "pname:width, pname:height and pname:layers define the dimensions of the framebuffer. If the render pass uses multiview, then pname:layers must: be one and each attachment requires a number of layers that is greater than the maximum bit index set in the view mask in the subpasses in which it is used.",
  "vkFreeCommandBuffers": "Free command buffers.",
  "vkFreeCommandBuffers.commandBufferCount": "",
  "vkFreeCommandBuffers.commandPool": "",
  "vkFreeCommandBuffers.device": "",
  "vkFreeCommandBuffers.pCommandBuffers": "",
  "vkFreeDescriptorSets": "Free one or more descriptor sets.",
  "vkFreeDescriptorSets.descriptorPool": "",
  "vkFreeDescriptorSets.descriptorSetCount": "",
  "vkFreeDescriptorSets.device": "",
  "vkFreeDescriptorSets.pDescriptorSets": "",
  "vkFreeMemory": "Free GPU memory.",
  "vkFreeMemory.device": "",
  "vkFreeMemory.memory": "",
  "vkFreeMemory.pAllocator": "",
  "VkFrontFace": "Interpret polygon front-facing orientation.",
  "VkFrontFace.VK_FRONT_FACE_CLOCKWISE": "",
  "VkFrontFace.VK_FRONT_FACE_COUNTER_CLOCKWISE": "",
  "vkGetBufferMemoryRequirements": "Returns the memory requirements for specified Vulkan object.",
  "vkGetBufferMemoryRequirements.buffer": "",
  "vkGetBufferMemoryRequirements.device": "",
  "vkGetBufferMemoryRequirements.pMemoryRequirements": "",
  "vkGetBufferMemoryRequirements2KHR": "",
  "vkGetBufferMemoryRequirements2KHR.device": "",
  "vkGetBufferMemoryRequirements2KHR.pInfo": "",
  "vkGetBufferMemoryRequirements2KHR.pMemoryRequirements": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX": "Query supported peer memory features of a device.",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.device": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.heapIndex": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.localDeviceIndex": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.pPeerMemoryFeatures": "",
  "vkGetDeviceGroupPeerMemoryFeaturesKHX.remoteDeviceIndex": "",
  "vkGetDeviceGroupPresentCapabilitiesKHX": "Query present capabilities from other physical devices.",
  "vkGetDeviceGroupPresentCapabilitiesKHX.device": "",
  "vkGetDeviceGroupPresentCapabilitiesKHX.pDeviceGroupPresentCapabilities": "",
  "vkGetDeviceGroupSurfacePresentModesKHX": "Query present capabilities for a surface.",
  "vkGetDeviceGroupSurfacePresentModesKHX.device": "",
  "vkGetDeviceGroupSurfacePresentModesKHX.pModes": "",
  "vkGetDeviceGroupSurfacePresentModesKHX.surface": "",
  "vkGetDeviceMemoryCommitment": "Query the current commitment for a VkDeviceMemory.",
  "vkGetDeviceMemoryCommitment.device": "",
  "vkGetDeviceMemoryCommitment.memory": "",
  "vkGetDeviceMemoryCommitment.pCommittedMemoryInBytes": "",
  "vkGetDeviceProcAddr": "Return a function pointer for a command.",
  "vkGetDeviceProcAddr.device": "",
  "vkGetDeviceProcAddr.pName": "",
  "vkGetDeviceQueue": "Get a queue handle from a device.",
  "vkGetDeviceQueue.device": "",
  "vkGetDeviceQueue.pQueue": "",
  "vkGetDeviceQueue.queueFamilyIndex": "",
  "vkGetDeviceQueue.queueIndex": "",
  "vkGetDisplayModePropertiesKHR": "Query the set of mode properties supported by the display.",
  "vkGetDisplayModePropertiesKHR.display": "",
  "vkGetDisplayModePropertiesKHR.physicalDevice": "",
  "vkGetDisplayModePropertiesKHR.pProperties": "",
  "vkGetDisplayModePropertiesKHR.pPropertyCount": "",
  "vkGetDisplayPlaneCapabilitiesKHR": "Query capabilities of a mode and plane combination.",
  "vkGetDisplayPlaneCapabilitiesKHR.mode": "",
  "vkGetDisplayPlaneCapabilitiesKHR.pCapabilities": "",
  "vkGetDisplayPlaneCapabilitiesKHR.physicalDevice": "",
  "vkGetDisplayPlaneCapabilitiesKHR.planeIndex": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR": "Query the list of displays a plane supports.",
  "vkGetDisplayPlaneSupportedDisplaysKHR.pDisplayCount": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.pDisplays": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.physicalDevice": "",
  "vkGetDisplayPlaneSupportedDisplaysKHR.planeIndex": "",
  "vkGetEventStatus": "Retrieve the status of an event object.",
  "vkGetEventStatus.device": "",
  "vkGetEventStatus.event": "",
  "vkGetFenceFdKHR": "",
  "vkGetFenceFdKHR.device": "",
  "vkGetFenceFdKHR.pFd": "",
  "vkGetFenceFdKHR.pGetFdInfo": "",
  "vkGetFenceStatus": "Return the status of a fence.",
  "vkGetFenceStatus.device": "",
  "vkGetFenceStatus.fence": "",
  "vkGetFenceWin32HandleKHR": "",
  "vkGetFenceWin32HandleKHR.device": "",
  "vkGetFenceWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetFenceWin32HandleKHR.pHandle": "",
  "vkGetImageMemoryRequirements": "Returns the memory requirements for specified Vulkan object.",
  "vkGetImageMemoryRequirements.device": "",
  "vkGetImageMemoryRequirements.image": "",
  "vkGetImageMemoryRequirements.pMemoryRequirements": "",
  "vkGetImageMemoryRequirements2KHR": "",
  "vkGetImageMemoryRequirements2KHR.device": "",
  "vkGetImageMemoryRequirements2KHR.pInfo": "",
  "vkGetImageMemoryRequirements2KHR.pMemoryRequirements": "",
  "vkGetImageSparseMemoryRequirements": "Query the memory requirements for a sparse image.",
  "vkGetImageSparseMemoryRequirements.device": "",
  "vkGetImageSparseMemoryRequirements.image": "",
  "vkGetImageSparseMemoryRequirements.pSparseMemoryRequirementCount": "",
  "vkGetImageSparseMemoryRequirements.pSparseMemoryRequirements": "",
  "vkGetImageSparseMemoryRequirements2KHR": "",
  "vkGetImageSparseMemoryRequirements2KHR.device": "",
  "vkGetImageSparseMemoryRequirements2KHR.pInfo": "",
  "vkGetImageSparseMemoryRequirements2KHR.pSparseMemoryRequirementCount": "",
  "vkGetImageSparseMemoryRequirements2KHR.pSparseMemoryRequirements": "",
  "vkGetImageSubresourceLayout": "Retrieve information about an image subresource.",
  "vkGetImageSubresourceLayout.device": "",
  "vkGetImageSubresourceLayout.image": "",
  "vkGetImageSubresourceLayout.pLayout": "",
  "vkGetImageSubresourceLayout.pSubresource": "",
  "vkGetInstanceProcAddr": "Return a function pointer for a command.",
  "vkGetInstanceProcAddr.instance": "",
  "vkGetInstanceProcAddr.pName": "",
  "vkGetMemoryFdKHR": "",
  "vkGetMemoryFdKHR.device": "",
  "vkGetMemoryFdKHR.pFd": "",
  "vkGetMemoryFdKHR.pGetFdInfo": "",
  "vkGetMemoryFdPropertiesKHR": "",
  "vkGetMemoryFdPropertiesKHR.device": "",
  "vkGetMemoryFdPropertiesKHR.fd": "",
  "vkGetMemoryFdPropertiesKHR.handleType": "",
  "vkGetMemoryFdPropertiesKHR.pMemoryFdProperties": "",
  "vkGetMemoryWin32HandleKHR": "",
  "vkGetMemoryWin32HandleKHR.device": "",
  "vkGetMemoryWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetMemoryWin32HandleKHR.pHandle": "",
  "vkGetMemoryWin32HandleNV": "Retrieve Win32 handle to a device memory object.",
  "vkGetMemoryWin32HandleNV.device": "",
  "vkGetMemoryWin32HandleNV.handleType": "",
  "vkGetMemoryWin32HandleNV.memory": "",
  "vkGetMemoryWin32HandleNV.pHandle": "",
  "vkGetMemoryWin32HandlePropertiesKHR": "",
  "vkGetMemoryWin32HandlePropertiesKHR.device": "",
  "vkGetMemoryWin32HandlePropertiesKHR.handle": "",
  "vkGetMemoryWin32HandlePropertiesKHR.handleType": "",
  "vkGetMemoryWin32HandlePropertiesKHR.pMemoryWin32HandleProperties": "",
  "vkGetPastPresentationTimingGOOGLE": "",
  "vkGetPastPresentationTimingGOOGLE.device": "",
  "vkGetPastPresentationTimingGOOGLE.pPresentationTimingCount": "",
  "vkGetPastPresentationTimingGOOGLE.pPresentationTimings": "",
  "vkGetPastPresentationTimingGOOGLE.swapchain": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR": "Query the plane properties.",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.pProperties": "",
  "vkGetPhysicalDeviceDisplayPlanePropertiesKHR.pPropertyCount": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR": "Query information about the available displays.",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.pProperties": "",
  "vkGetPhysicalDeviceDisplayPropertiesKHR.pPropertyCount": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.pExternalBufferInfo": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.pExternalBufferProperties": "",
  "vkGetPhysicalDeviceExternalBufferPropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.pExternalFenceInfo": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.pExternalFenceProperties": "",
  "vkGetPhysicalDeviceExternalFencePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV": "Determine image capabilities compatible with external memory handle types.",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.externalHandleType": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.flags": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.format": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.pExternalImageFormatProperties": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.physicalDevice": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.tiling": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.type": "",
  "vkGetPhysicalDeviceExternalImageFormatPropertiesNV.usage": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.pExternalSemaphoreInfo": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.pExternalSemaphoreProperties": "",
  "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceFeatures": "Reports capabilities of a physical device.",
  "vkGetPhysicalDeviceFeatures.pFeatures": "",
  "vkGetPhysicalDeviceFeatures.physicalDevice": "",
  "vkGetPhysicalDeviceFeatures2KHR": "Reports capabilities of a physical device.",
  "vkGetPhysicalDeviceFeatures2KHR.pFeatures": "",
  "vkGetPhysicalDeviceFeatures2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceFormatProperties": "Lists physical device's format capabilities.",
  "vkGetPhysicalDeviceFormatProperties.format": "",
  "vkGetPhysicalDeviceFormatProperties.pFormatProperties": "",
  "vkGetPhysicalDeviceFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceFormatProperties2KHR": "Lists physical device's format capabilities.",
  "vkGetPhysicalDeviceFormatProperties2KHR.format": "",
  "vkGetPhysicalDeviceFormatProperties2KHR.pFormatProperties": "",
  "vkGetPhysicalDeviceFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX": "Returns device-generated commands related properties of a physical device.",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.pFeatures": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.physicalDevice": "",
  "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.pLimits": "",
  "vkGetPhysicalDeviceImageFormatProperties": "Lists physical device's image format capabilities.",
  "vkGetPhysicalDeviceImageFormatProperties.flags": "",
  "vkGetPhysicalDeviceImageFormatProperties.format": "",
  "vkGetPhysicalDeviceImageFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceImageFormatProperties.pImageFormatProperties": "",
  "vkGetPhysicalDeviceImageFormatProperties.tiling": "",
  "vkGetPhysicalDeviceImageFormatProperties.type": "",
  "vkGetPhysicalDeviceImageFormatProperties.usage": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR": "Lists physical device's image format capabilities.",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.pImageFormatInfo": "",
  "vkGetPhysicalDeviceImageFormatProperties2KHR.pImageFormatProperties": "",
  "vkGetPhysicalDeviceMemoryProperties": "Reports memory information for the specified physical device.",
  "vkGetPhysicalDeviceMemoryProperties.physicalDevice": "",
  "vkGetPhysicalDeviceMemoryProperties.pMemoryProperties": "",
  "vkGetPhysicalDeviceMemoryProperties2KHR": "Reports memory information for the specified physical device.",
  "vkGetPhysicalDeviceMemoryProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceMemoryProperties2KHR.pMemoryProperties": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR": "Query physical device for presentation to Mir.",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.connection": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceMirPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDevicePresentRectanglesKHX": "Query present rectangles for a surface on a physical device.",
  "vkGetPhysicalDevicePresentRectanglesKHX.physicalDevice": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.pRectCount": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.pRects": "",
  "vkGetPhysicalDevicePresentRectanglesKHX.surface": "",
  "vkGetPhysicalDeviceProperties": "Returns properties of a physical device.",
  "vkGetPhysicalDeviceProperties.physicalDevice": "",
  "vkGetPhysicalDeviceProperties.pProperties": "",
  "vkGetPhysicalDeviceProperties2KHR": "Returns properties of a physical device.",
  "vkGetPhysicalDeviceProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceProperties2KHR.pProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties": "Reports properties of the queues of the specified physical device.",
  "vkGetPhysicalDeviceQueueFamilyProperties.physicalDevice": "",
  "vkGetPhysicalDeviceQueueFamilyProperties.pQueueFamilyProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties.pQueueFamilyPropertyCount": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR": "Reports properties of the queues of the specified physical device.",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.pQueueFamilyProperties": "",
  "vkGetPhysicalDeviceQueueFamilyProperties2KHR.pQueueFamilyPropertyCount": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties": "Retrieve properties of an image format applied to sparse images.",
  "vkGetPhysicalDeviceSparseImageFormatProperties.format": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.physicalDevice": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.pProperties": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.pPropertyCount": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.samples": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.tiling": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.type": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties.usage": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR": "Retrieve properties of an image format applied to sparse images.",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pFormatInfo": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pProperties": "",
  "vkGetPhysicalDeviceSparseImageFormatProperties2KHR.pPropertyCount": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT": "Query surface capabilities.",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2EXT.surface": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilities2KHR.pSurfaceInfo": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR": "Query surface capabilities.",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.pSurfaceCapabilities": "",
  "vkGetPhysicalDeviceSurfaceCapabilitiesKHR.surface": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceFormatCount": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceFormats": "",
  "vkGetPhysicalDeviceSurfaceFormats2KHR.pSurfaceInfo": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR": "Query color formats supported by surface.",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.pSurfaceFormatCount": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.pSurfaceFormats": "",
  "vkGetPhysicalDeviceSurfaceFormatsKHR.surface": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR": "Query supported presentation modes.",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.pPresentModeCount": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.pPresentModes": "",
  "vkGetPhysicalDeviceSurfacePresentModesKHR.surface": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR": "Query if presentation is supported.",
  "vkGetPhysicalDeviceSurfaceSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.pSupported": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceSurfaceSupportKHR.surface": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR": "Query physical device for presentation to Wayland.",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.display": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceWaylandPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR": "Query queue family support for presentation on a Win32 display.",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceWin32PresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR": "Query physical device for presentation to X11 server using XCB.",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.connection": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXcbPresentationSupportKHR.visual_id": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR": "Query physical device for presentation to X11 server using Xlib.",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.dpy": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.physicalDevice": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.queueFamilyIndex": "",
  "vkGetPhysicalDeviceXlibPresentationSupportKHR.visualID": "",
  "vkGetPipelineCacheData": "Get the data store from a pipeline cache.",
  "vkGetPipelineCacheData.device": "",
  "vkGetPipelineCacheData.pData": "",
  "vkGetPipelineCacheData.pDataSize": "",
  "vkGetPipelineCacheData.pipelineCache": "",
  "vkGetQueryPoolResults": "Copy results of queries in a query pool to a host memory region.",
  "vkGetQueryPoolResults.dataSize": "",
  "vkGetQueryPoolResults.device": "",
  "vkGetQueryPoolResults.firstQuery": "",
  "vkGetQueryPoolResults.flags": "",
  "vkGetQueryPoolResults.pData": "",
  "vkGetQueryPoolResults.queryCount": "",
  "vkGetQueryPoolResults.queryPool": "",
  "vkGetQueryPoolResults.stride": "",
  "vkGetRandROutputDisplayEXT": "Query the VkDisplayKHR corresponding to an X11 RandR Output.",
  "vkGetRandROutputDisplayEXT.dpy": "",
  "vkGetRandROutputDisplayEXT.pDisplay": "",
  "vkGetRandROutputDisplayEXT.physicalDevice": "",
  "vkGetRandROutputDisplayEXT.rrOutput": "",
  "vkGetRefreshCycleDurationGOOGLE": "",
  "vkGetRefreshCycleDurationGOOGLE.device": "",
  "vkGetRefreshCycleDurationGOOGLE.pDisplayTimingProperties": "",
  "vkGetRefreshCycleDurationGOOGLE.swapchain": "",
  "vkGetRenderAreaGranularity": "Returns the granularity for optimal render area.",
  "vkGetRenderAreaGranularity.device": "",
  "vkGetRenderAreaGranularity.pGranularity": "",
  "vkGetRenderAreaGranularity.renderPass": "",
  "vkGetSemaphoreFdKHR": "",
  "vkGetSemaphoreFdKHR.device": "",
  "vkGetSemaphoreFdKHR.pFd": "",
  "vkGetSemaphoreFdKHR.pGetFdInfo": "",
  "vkGetSemaphoreWin32HandleKHR": "",
  "vkGetSemaphoreWin32HandleKHR.device": "",
  "vkGetSemaphoreWin32HandleKHR.pGetWin32HandleInfo": "",
  "vkGetSemaphoreWin32HandleKHR.pHandle": "",
  "vkGetSwapchainCounterEXT": "Query the current value of a surface counter.",
  "vkGetSwapchainCounterEXT.counter": "",
  "vkGetSwapchainCounterEXT.device": "",
  "vkGetSwapchainCounterEXT.pCounterValue": "",
  "vkGetSwapchainCounterEXT.swapchain": "",
  "vkGetSwapchainImagesKHR": "Obtain the array of presentable images associated with a swapchain.",
  "vkGetSwapchainImagesKHR.device": "",
  "vkGetSwapchainImagesKHR.pSwapchainImageCount": "",
  "vkGetSwapchainImagesKHR.pSwapchainImages": "",
  "vkGetSwapchainImagesKHR.swapchain": "",
  "vkGetSwapchainStatusKHR": "",
  "vkGetSwapchainStatusKHR.device": "",
  "vkGetSwapchainStatusKHR.swapchain": "",
  "VkGraphicsPipelineCreateInfo": "Structure specifying parameters of a newly created graphics pipeline.",
  "VkGraphicsPipelineCreateInfo.basePipelineHandle": "pname:basePipelineHandle is a pipeline to derive from.",
  "VkGraphicsPipelineCreateInfo.basePipelineIndex": "pname:basePipelineIndex is an index into the pname:pCreateInfos parameter to use as a pipeline to derive from.",
  "VkGraphicsPipelineCreateInfo.flags": "pname:flags is a bitmask of elink:VkPipelineCreateFlagBits controlling how the pipeline will be generated, as described below.",
  "VkGraphicsPipelineCreateInfo.layout": "pname:layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline.",
  "VkGraphicsPipelineCreateInfo.pColorBlendState": "pname:pColorBlendState is a pointer to an instance of the slink:VkPipelineColorBlendStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use any color attachments.",
  "VkGraphicsPipelineCreateInfo.pDepthStencilState": "pname:pDepthStencilState is a pointer to an instance of the slink:VkPipelineDepthStencilStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled or if the subpass of the render pass the pipeline is created against does not use a depth/stencil attachment.",
  "VkGraphicsPipelineCreateInfo.pDynamicState": "pname:pDynamicState is a pointer to slink:VkPipelineDynamicStateCreateInfo and is used to indicate which properties of the pipeline state object are dynamic and can: be changed independently of the pipeline state. This can: be `NULL`, which means no state in the pipeline is considered dynamic.",
  "VkGraphicsPipelineCreateInfo.pInputAssemblyState": "pname:pInputAssemblyState is a pointer to an instance of the slink:VkPipelineInputAssemblyStateCreateInfo structure which determines input assembly behavior, as described in <<drawing, Drawing Commands>>.",
  "VkGraphicsPipelineCreateInfo.pMultisampleState": "pname:pMultisampleState is a pointer to an instance of the slink:VkPipelineMultisampleStateCreateInfo, or `NULL` if the pipeline has rasterization disabled.",
  "VkGraphicsPipelineCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkGraphicsPipelineCreateInfo.pRasterizationState": "pname:pRasterizationState is a pointer to an instance of the slink:VkPipelineRasterizationStateCreateInfo structure.",
  "VkGraphicsPipelineCreateInfo.pStages": "pname:pStages is an array of size pname:stageCount structures of type slink:VkPipelineShaderStageCreateInfo describing the set of the shader stages to be included in the graphics pipeline.",
  "VkGraphicsPipelineCreateInfo.pTessellationState": "pname:pTessellationState is a pointer to an instance of the slink:VkPipelineTessellationStateCreateInfo structure, or `NULL` if the pipeline does not include a tessellation control shader stage and tessellation evaluation shader stage.",
  "VkGraphicsPipelineCreateInfo.pVertexInputState": "pname:pVertexInputState is a pointer to an instance of the slink:VkPipelineVertexInputStateCreateInfo structure.",
  "VkGraphicsPipelineCreateInfo.pViewportState": "pname:pViewportState is a pointer to an instance of the slink:VkPipelineViewportStateCreateInfo structure, or `NULL` if the pipeline has rasterization disabled.",
  "VkGraphicsPipelineCreateInfo.renderPass": "pname:renderPass is a handle to a render pass object describing the environment in which the pipeline will be used; the pipeline must: only be used with an instance of any render pass compatible with the one provided. See <<renderpass-compatibility,Render Pass Compatibility>> for more information.",
  "VkGraphicsPipelineCreateInfo.stageCount": "pname:stageCount is the number of entries in the pname:pStages array.",
  "VkGraphicsPipelineCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkGraphicsPipelineCreateInfo.subpass": "pname:subpass is the index of the subpass in the render pass where this pipeline will be used.",
  "VkHdrMetadataEXT": "",
  "VkHdrMetadataEXT.displayPrimaryBlue": "",
  "VkHdrMetadataEXT.displayPrimaryGreen": "",
  "VkHdrMetadataEXT.displayPrimaryRed": "",
  "VkHdrMetadataEXT.maxContentLightLevel": "",
  "VkHdrMetadataEXT.maxFrameAverageLightLevel": "",
  "VkHdrMetadataEXT.maxLuminance": "",
  "VkHdrMetadataEXT.minLuminance": "",
  "VkHdrMetadataEXT.pNext": "",
  "VkHdrMetadataEXT.sType": "",
  "VkHdrMetadataEXT.whitePoint": "",
  "VkImage": "Opaque handle to a image object.",
  "VkImageAspectFlagBits": "Bitmask specifying which aspects of an image are included in a view.",
  "VkImageAspectFlags": "",
  "VkImageAspectFlags.__none": "",
  "VkImageAspectFlags.VK_IMAGE_ASPECT_COLOR_BIT": "",
  "VkImageAspectFlags.VK_IMAGE_ASPECT_DEPTH_BIT": "",
  "VkImageAspectFlags.VK_IMAGE_ASPECT_METADATA_BIT": "",
  "VkImageAspectFlags.VK_IMAGE_ASPECT_STENCIL_BIT": "",
  "VkImageBlit": "Structure specifying an image blit operation.",
  "VkImageBlit.dstOffsets": "pname:dstOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the destination region within pname:dstSubresource.",
  "VkImageBlit.dstSubresource": "pname:dstSubresource is the subresource to blit into.",
  "VkImageBlit.srcOffsets": "pname:srcOffsets is an array of two slink:VkOffset3D structures specifying the bounds of the source region within pname:srcSubresource.",
  "VkImageBlit.srcSubresource": "pname:srcSubresource is the subresource to blit from.",
  "VkImageCopy": "Structure specifying an image copy operation.",
  "VkImageCopy.dstOffset": "",
  "VkImageCopy.dstSubresource": "",
  "VkImageCopy.extent": "pname:extent is the size in texels of the source image to copy in pname:width, pname:height and pname:depth.",
  "VkImageCopy.srcOffset": "pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.",
  "VkImageCopy.srcSubresource": "pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively.",
  "VkImageCreateFlagBits": "Bitmask specifying additional parameters of an image.",
  "VkImageCreateFlags": "",
  "VkImageCreateFlags.__none": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_BIND_SFR_BIT_KHX": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_SPARSE_ALIASED_BIT": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_SPARSE_BINDING_BIT": "",
  "VkImageCreateFlags.VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT": "",
  "VkImageCreateInfo": "Structure specifying the parameters of a newly created image object.",
  "VkImageCreateInfo.arrayLayers": "pname:arrayLayers is the number of layers in the image.",
  "VkImageCreateInfo.extent": "pname:extent is a slink:VkExtent3D describing the number of data elements in each dimension of the base level.",
  "VkImageCreateInfo.flags": "pname:flags is a bitmask describing additional parameters of the image. See elink:VkImageCreateFlagBits below for a description of the supported bits.",
  "VkImageCreateInfo.format": "pname:format is a elink:VkFormat describing the format and type of the data elements that will be contained in the image.",
  "VkImageCreateInfo.imageType": "pname:imageType is a elink:VkImageType specifying the basic dimensionality of the image, as described below. Layers in array textures do not count as a dimension for the purposes of the image type.",
  "VkImageCreateInfo.initialLayout": "pname:initialLayout selects the initial elink:VkImageLayout state of all image subresources of the image. See <<resources-image-layouts,Image Layouts>>. pname:initialLayout must: be ename:VK_IMAGE_LAYOUT_UNDEFINED or ename:VK_IMAGE_LAYOUT_PREINITIALIZED.",
  "VkImageCreateInfo.mipLevels": "pname:mipLevels describes the number of levels of detail available for minified sampling of the image.",
  "VkImageCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImageCreateInfo.pQueueFamilyIndices": "pname:pQueueFamilyIndices is a list of queue families that will access this image (ignored if pname:sharingMode is not ename:VK_SHARING_MODE_CONCURRENT).",
  "VkImageCreateInfo.queueFamilyIndexCount": "pname:queueFamilyIndexCount is the number of entries in the pname:pQueueFamilyIndices array.",
  "VkImageCreateInfo.samples": "pname:samples is the number of sub-data element samples in the image as defined in elink:VkSampleCountFlagBits. See <<primsrast-multisampling,Multisampling>>.",
  "VkImageCreateInfo.sharingMode": "pname:sharingMode is the sharing mode of the image when it will be accessed by multiple queue families, and must: be one of the values described for elink:VkSharingMode in the <<resources-sharing,Resource Sharing>> section below.",
  "VkImageCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkImageCreateInfo.tiling": "pname:tiling is a elink:VkImageTiling specifying the tiling arrangement of the data elements in memory, as described below.",
  "VkImageCreateInfo.usage": "pname:usage is a bitmask describing the intended usage of the image. See elink:VkImageUsageFlagBits below for a description of the supported bits.",
  "VkImageFormatProperties": "Structure specifying a image format properties.",
  "VkImageFormatProperties.maxArrayLayers": "pname:maxArrayLayers is the maximum number of array layers. pname:maxArrayLayers must: either be equal to 1 or be greater than or equal to the pname:maxImageArrayLayers member of slink:VkPhysicalDeviceLimits. A value of 1 is valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR or if pname:type is ename:VK_IMAGE_TYPE_3D.",
  "VkImageFormatProperties.maxExtent": "pname:maxExtent are the maximum image dimensions. See the <<features-extentperimagetype,Allowed Extent Values>> section below for how these values are constrained by pname:type.",
  "VkImageFormatProperties.maxMipLevels": "pname:maxMipLevels is the maximum number of mipmap levels. pname:maxMipLevels must: either be equal to 1 (valid only if pname:tiling is ename:VK_IMAGE_TILING_LINEAR) or be equal to [eq]#{lceil}log~2~(max(pname:width, pname:height, pname:depth)){rceil} {plus} 1#. [eq]#pname:width#, [eq]#pname:height#, and [eq]#pname:depth# are taken from the corresponding members of pname:maxExtent.",
  "VkImageFormatProperties.maxResourceSize": "pname:maxResourceSize is an upper bound on the total image size in bytes, inclusive of all image subresources. Implementations may: have an address space limit on total size of a resource, which is advertised by this property. pname:maxResourceSize must: be at least 2^31^.",
  "VkImageFormatProperties.sampleCounts": "pname:sampleCounts is a bitmask of elink:VkSampleCountFlagBits specifying all the supported sample counts for this image as described <<features-supported-sample-counts, below>>.",
  "VkImageFormatProperties2KHR": "Structure specifying a image format properties.",
  "VkImageFormatProperties2KHR.imageFormatProperties": "pname:imageFormatProperties is an instance of a slink:VkImageFormatProperties structure in which capabilities are returned.",
  "VkImageFormatProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImageFormatProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkImageLayout": "Layout of image and image subresources.",
  "VkImageLayout.VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL": "ename:VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: must: only be used as a color or resolve attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL": "ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: must: only be used as a depth/stencil attachment in a sname:VkFramebuffer. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL": "ename:VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: must: only be used as a read-only depth/stencil attachment in a sname:VkFramebuffer and/or as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bit enabled. Only image subresources of images created with ename:VK_IMAGE_USAGE_SAMPLED_BIT can: be used as sampled image or combined image/sampler in a shader. Similarly, only image subresources of images created with ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT can: be used as input attachments.",
  "VkImageLayout.VK_IMAGE_LAYOUT_GENERAL": "ename:VK_IMAGE_LAYOUT_GENERAL: Supports all types of device access.",
  "VkImageLayout.VK_IMAGE_LAYOUT_PREINITIALIZED": "ename:VK_IMAGE_LAYOUT_PREINITIALIZED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are preserved. This layout is intended to be used as the initial layout for an image whose contents are written by the host, and hence the data can: be written to memory immediately, without first executing a layout transition. Currently, ename:VK_IMAGE_LAYOUT_PREINITIALIZED is only useful with ename:VK_IMAGE_TILING_LINEAR images because there is not a standard layout defined for ename:VK_IMAGE_TILING_OPTIMAL images.",
  "VkImageLayout.VK_IMAGE_LAYOUT_PRESENT_SRC_KHR": "ename:VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: must: only be used for presenting a presentable image for display. A swapchain's image must: be transitioned to this layout before calling flink:vkQueuePresentKHR, and must: be transitioned away from this layout after calling flink:vkAcquireNextImageKHR.",
  "VkImageLayout.VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL": "ename:VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: must: only be used as a read-only image in a shader (which can: be read as a sampled image, combined image/sampler and/or input attachment). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_SAMPLED_BIT or ename:VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR": "",
  "VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL": "ename:VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: must: only be used as a destination image of a transfer command. This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_DST_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL": "ename:VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: must: only be used as a source image of a transfer command (see the definition of <<synchronization-pipeline-stages-transfer, ename:VK_PIPELINE_STAGE_TRANSFER_BIT>>). This layout is valid only for image subresources of images created with the ename:VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage bit enabled.",
  "VkImageLayout.VK_IMAGE_LAYOUT_UNDEFINED": "ename:VK_IMAGE_LAYOUT_UNDEFINED: Supports no device access. This layout must: only be used as the pname:initialLayout member of sname:VkImageCreateInfo or sname:VkAttachmentDescription, or as the pname:oldLayout in an image transition. When transitioning out of this layout, the contents of the memory are not guaranteed to be preserved.",
  "VkImageMemoryBarrier": "Structure specifying the parameters of an image memory barrier.",
  "VkImageMemoryBarrier.dstAccessMask": "pname:dstAccessMask defines a <<synchronization-access-masks, destination access mask>>.",
  "VkImageMemoryBarrier.dstQueueFamilyIndex": "pname:dstQueueFamilyIndex is the destination queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.",
  "VkImageMemoryBarrier.image": "pname:image is a handle to the image affected by this barrier.",
  "VkImageMemoryBarrier.newLayout": "pname:newLayout is the new layout in an <<synchronization-image-layout-transitions, image layout transition>>.",
  "VkImageMemoryBarrier.oldLayout": "pname:oldLayout is the old layout in an <<synchronization-image-layout-transitions, image layout transition>>.",
  "VkImageMemoryBarrier.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImageMemoryBarrier.srcAccessMask": "pname:srcAccessMask defines a <<synchronization-access-masks, source access mask>>.",
  "VkImageMemoryBarrier.srcQueueFamilyIndex": "pname:srcQueueFamilyIndex is the source queue family for a <<synchronization-queue-transfers, queue family ownership transfer>>.",
  "VkImageMemoryBarrier.sType": "pname:sType is the type of this structure.",
  "VkImageMemoryBarrier.subresourceRange": "pname:subresourceRange describes the <<resources-image-views, image subresource range>> within pname:image that is affected by this barrier.",
  "VkImageMemoryRequirementsInfo2KHR": "",
  "VkImageMemoryRequirementsInfo2KHR.image": "",
  "VkImageMemoryRequirementsInfo2KHR.pNext": "",
  "VkImageMemoryRequirementsInfo2KHR.sType": "",
  "VkImageResolve": "Structure specifying an image resolve operation.",
  "VkImageResolve.dstOffset": "",
  "VkImageResolve.dstSubresource": "",
  "VkImageResolve.extent": "pname:extent is the size in texels of the source image to resolve in pname:width, pname:height and pname:depth.",
  "VkImageResolve.srcOffset": "pname:srcOffset and pname:dstOffset select the initial x, y, and z offsets in texels of the sub-regions of the source and destination image data.",
  "VkImageResolve.srcSubresource": "pname:srcSubresource and pname:dstSubresource are slink:VkImageSubresourceLayers structures specifying the image subresources of the images used for the source and destination image data, respectively. Resolve of depth/stencil images is not supported.",
  "VkImageSparseMemoryRequirementsInfo2KHR": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.image": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.pNext": "",
  "VkImageSparseMemoryRequirementsInfo2KHR.sType": "",
  "VkImageSubresource": "Structure specifying a image subresource.",
  "VkImageSubresource.arrayLayer": "pname:arrayLayer selects the array layer.",
  "VkImageSubresource.aspectMask": "pname:aspectMask is a elink:VkImageAspectFlags selecting the image _aspect_.",
  "VkImageSubresource.mipLevel": "pname:mipLevel selects the mipmap level.",
  "VkImageSubresourceLayers": "Structure specifying a image subresource layers.",
  "VkImageSubresourceLayers.aspectMask": "pname:aspectMask is a combination of elink:VkImageAspectFlagBits, selecting the color, depth and/or stencil aspects to be copied.",
  "VkImageSubresourceLayers.baseArrayLayer": "pname:baseArrayLayer and pname:layerCount are the starting layer and number of layers to copy.",
  "VkImageSubresourceLayers.layerCount": "",
  "VkImageSubresourceLayers.mipLevel": "pname:mipLevel is the mipmap level to copy from.",
  "VkImageSubresourceRange": "Structure specifying a image subresource range.",
  "VkImageSubresourceRange.aspectMask": "pname:aspectMask is a bitmask indicating which aspect(s) of the image are included in the view. See elink:VkImageAspectFlagBits.",
  "VkImageSubresourceRange.baseArrayLayer": "pname:baseArrayLayer is the first array layer accessible to the view.",
  "VkImageSubresourceRange.baseMipLevel": "pname:baseMipLevel is the first mipmap level accessible to the view.",
  "VkImageSubresourceRange.layerCount": "pname:layerCount is the number of array layers (starting from pname:baseArrayLayer) accessible to the view.",
  "VkImageSubresourceRange.levelCount": "pname:levelCount is the number of mipmap levels (starting from pname:baseMipLevel) accessible to the view.",
  "VkImageSwapchainCreateInfoKHX": "Specify that an image will be bound to swapchain memory.",
  "VkImageSwapchainCreateInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImageSwapchainCreateInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkImageSwapchainCreateInfoKHX.swapchain": "pname:swapchain is dlink:VK_NULL_HANDLE or a handle of a swapchain that the image will be bound to.",
  "VkImageTiling": "Specifies the tiling arrangement of data in an image.",
  "VkImageTiling.VK_IMAGE_TILING_LINEAR": "",
  "VkImageTiling.VK_IMAGE_TILING_OPTIMAL": "",
  "VkImageType": "Specifies the type of an image object.",
  "VkImageType.VK_IMAGE_TYPE_1D": "",
  "VkImageType.VK_IMAGE_TYPE_2D": "",
  "VkImageType.VK_IMAGE_TYPE_3D": "",
  "VkImageUsageFlagBits": "Bitmask specifying intended usage of an image.",
  "VkImageUsageFlags": "",
  "VkImageUsageFlags.__none": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_SAMPLED_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_STORAGE_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_TRANSFER_DST_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_TRANSFER_SRC_BIT": "",
  "VkImageUsageFlags.VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT": "",
  "VkImageView": "Opaque handle to a image view object.",
  "VkImageViewCreateFlags": "",
  "VkImageViewCreateFlags.__none": "",
  "VkImageViewCreateInfo": "Structure specifying parameters of a newly created image view.",
  "VkImageViewCreateInfo.components": "pname:components specifies a remapping of color components (or of depth or stencil components after they have been converted into color components). See slink:VkComponentMapping.",
  "VkImageViewCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkImageViewCreateInfo.format": "pname:format is a elink:VkFormat describing the format and type used to interpret data elements in the image.",
  "VkImageViewCreateInfo.image": "pname:image is a sname:VkImage on which the view will be created.",
  "VkImageViewCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImageViewCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkImageViewCreateInfo.subresourceRange": "pname:subresourceRange is a slink:VkImageSubresourceRange selecting the set of mipmap levels and array layers to be accessible to the view.",
  "VkImageViewCreateInfo.viewType": "pname:viewType is the type of the image view.",
  "VkImageViewType": "Image view types.",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_1D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_1D_ARRAY": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_2D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_2D_ARRAY": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_3D": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_CUBE": "",
  "VkImageViewType.VK_IMAGE_VIEW_TYPE_CUBE_ARRAY": "",
  "VkImportFenceFdInfoKHR": "",
  "VkImportFenceFdInfoKHR.fd": "",
  "VkImportFenceFdInfoKHR.fence": "",
  "VkImportFenceFdInfoKHR.flags": "",
  "VkImportFenceFdInfoKHR.handleType": "",
  "VkImportFenceFdInfoKHR.pNext": "",
  "VkImportFenceFdInfoKHR.sType": "",
  "vkImportFenceFdKHR": "",
  "vkImportFenceFdKHR.device": "",
  "vkImportFenceFdKHR.pImportFenceFdInfo": "",
  "VkImportFenceWin32HandleInfoKHR": "",
  "VkImportFenceWin32HandleInfoKHR.fence": "",
  "VkImportFenceWin32HandleInfoKHR.flags": "",
  "VkImportFenceWin32HandleInfoKHR.handle": "",
  "VkImportFenceWin32HandleInfoKHR.handleType": "",
  "VkImportFenceWin32HandleInfoKHR.name": "",
  "VkImportFenceWin32HandleInfoKHR.pNext": "",
  "VkImportFenceWin32HandleInfoKHR.sType": "",
  "vkImportFenceWin32HandleKHR": "",
  "vkImportFenceWin32HandleKHR.device": "",
  "vkImportFenceWin32HandleKHR.pImportFenceWin32HandleInfo": "",
  "VkImportMemoryFdInfoKHR": "",
  "VkImportMemoryFdInfoKHR.fd": "",
  "VkImportMemoryFdInfoKHR.handleType": "",
  "VkImportMemoryFdInfoKHR.pNext": "",
  "VkImportMemoryFdInfoKHR.sType": "",
  "VkImportMemoryWin32HandleInfoKHR": "",
  "VkImportMemoryWin32HandleInfoKHR.handle": "",
  "VkImportMemoryWin32HandleInfoKHR.handleType": "",
  "VkImportMemoryWin32HandleInfoKHR.name": "",
  "VkImportMemoryWin32HandleInfoKHR.pNext": "",
  "VkImportMemoryWin32HandleInfoKHR.sType": "",
  "VkImportMemoryWin32HandleInfoNV": "Import Win32 memory created on the same physical device.",
  "VkImportMemoryWin32HandleInfoNV.handle": "",
  "VkImportMemoryWin32HandleInfoNV.handleType": "pname:handleType is 0 or a flag specifying the type of memory handle in pname:handle. Flags which may: be specified are: + --",
  "VkImportMemoryWin32HandleInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkImportMemoryWin32HandleInfoNV.sType": "pname:sType is the type of this structure.",
  "VkImportSemaphoreFdInfoKHR": "",
  "VkImportSemaphoreFdInfoKHR.fd": "",
  "VkImportSemaphoreFdInfoKHR.flags": "",
  "VkImportSemaphoreFdInfoKHR.handleType": "",
  "VkImportSemaphoreFdInfoKHR.pNext": "",
  "VkImportSemaphoreFdInfoKHR.semaphore": "",
  "VkImportSemaphoreFdInfoKHR.sType": "",
  "vkImportSemaphoreFdKHR": "",
  "vkImportSemaphoreFdKHR.device": "",
  "vkImportSemaphoreFdKHR.pImportSemaphoreFdInfo": "",
  "VkImportSemaphoreWin32HandleInfoKHR": "",
  "VkImportSemaphoreWin32HandleInfoKHR.flags": "",
  "VkImportSemaphoreWin32HandleInfoKHR.handle": "",
  "VkImportSemaphoreWin32HandleInfoKHR.handleType": "",
  "VkImportSemaphoreWin32HandleInfoKHR.name": "",
  "VkImportSemaphoreWin32HandleInfoKHR.pNext": "",
  "VkImportSemaphoreWin32HandleInfoKHR.semaphore": "",
  "VkImportSemaphoreWin32HandleInfoKHR.sType": "",
  "vkImportSemaphoreWin32HandleKHR": "",
  "vkImportSemaphoreWin32HandleKHR.device": "",
  "vkImportSemaphoreWin32HandleKHR.pImportSemaphoreWin32HandleInfo": "",
  "VkIndexType": "Type of index buffer indices.",
  "VkIndexType.VK_INDEX_TYPE_UINT16": "",
  "VkIndexType.VK_INDEX_TYPE_UINT32": "",
  "VkIndirectCommandsLayoutCreateInfoNVX": "Structure specifying the parameters of a newly created indirect commands layout object.",
  "VkIndirectCommandsLayoutCreateInfoNVX.flags": "pname:flags is a bitmask providing usage hints of this layout. See elink:VkIndirectCommandsLayoutUsageFlagBitsNVX below for a description of the supported bits.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint": "pname:pipelineBindPoint is the sname:VkPipelineBindPoint that this layout targets.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkIndirectCommandsLayoutCreateInfoNVX.pTokens": "pname:pTokens is an array describing each command token in detail. See elink:VkIndirectCommandsTokenTypeNVX and slink:VkIndirectCommandsLayoutTokenNVX below for details.",
  "VkIndirectCommandsLayoutCreateInfoNVX.sType": "pname:sType is the type of this structure.",
  "VkIndirectCommandsLayoutCreateInfoNVX.tokenCount": "pname:tokenCount is the length of the individual command sequnce.",
  "VkIndirectCommandsLayoutNVX": "Opaque handle to an indirect commands layout object.",
  "VkIndirectCommandsLayoutTokenNVX": "Struct specifying the details of an indirect command layout token.",
  "VkIndirectCommandsLayoutTokenNVX.bindingUnit": "",
  "VkIndirectCommandsLayoutTokenNVX.divisor": "",
  "VkIndirectCommandsLayoutTokenNVX.dynamicCount": "",
  "VkIndirectCommandsLayoutTokenNVX.tokenType": "",
  "VkIndirectCommandsLayoutUsageFlagBitsNVX": "Bitmask specifying allowed usage of a indirect commands layout.",
  "VkIndirectCommandsLayoutUsageFlagsNVX": "",
  "VkIndirectCommandsLayoutUsageFlagsNVX.__none": "",
  "VkIndirectCommandsLayoutUsageFlagsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX": "",
  "VkIndirectCommandsLayoutUsageFlagsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX": "",
  "VkIndirectCommandsLayoutUsageFlagsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX": "",
  "VkIndirectCommandsLayoutUsageFlagsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX": "",
  "VkIndirectCommandsTokenNVX": "Structure specifying parameters for the reservation of command buffer space.",
  "VkIndirectCommandsTokenNVX.buffer": "pname:buffer specifies the sname:VkBuffer storing the functional arguments for each squence. These argumetns can be written by the device.",
  "VkIndirectCommandsTokenNVX.offset": "pname:offset specified an offset into pname:buffer where the arguments start.",
  "VkIndirectCommandsTokenNVX.tokenType": "pname:tokenType specifies the token command type.",
  "VkIndirectCommandsTokenTypeNVX": "Enum specifying.",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX": "",
  "VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX": "",
  "VkInstance": "Opaque handle to a instance object.",
  "VkInstanceCreateFlagBits": "",
  "VkInstanceCreateFlags": "",
  "VkInstanceCreateFlags.__none": "",
  "VkInstanceCreateInfo": "Structure specifying parameters of a newly created instance.",
  "VkInstanceCreateInfo.enabledExtensionCount": "pname:enabledExtensionCount is the number of global extensions to enable.",
  "VkInstanceCreateInfo.enabledLayerCount": "pname:enabledLayerCount is the number of global layers to enable.",
  "VkInstanceCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkInstanceCreateInfo.pApplicationInfo": "pname:pApplicationInfo is `NULL` or a pointer to an instance of sname:VkApplicationInfo. If not `NULL`, this information helps implementations recognize behavior inherent to classes of applications. slink:VkApplicationInfo is defined in detail below.",
  "VkInstanceCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkInstanceCreateInfo.ppEnabledExtensionNames": "pname:ppEnabledExtensionNames is a pointer to an array of pname:enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable.",
  "VkInstanceCreateInfo.ppEnabledLayerNames": "pname:ppEnabledLayerNames is a pointer to an array of pname:enabledLayerCount null-terminated UTF-8 strings containing the names of layers to enable for the created instance. See the <<extended-functionality-layers,Layers>> section for further details.",
  "VkInstanceCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkInternalAllocationType": "Allocation type.",
  "VkInternalAllocationType.VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE": "ename:VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - The allocation is intended for execution by the host.",
  "vkInvalidateMappedMemoryRanges": "Invalidate ranges of mapped memory objects.",
  "vkInvalidateMappedMemoryRanges.device": "",
  "vkInvalidateMappedMemoryRanges.memoryRangeCount": "",
  "vkInvalidateMappedMemoryRanges.pMemoryRanges": "",
  "VkIOSSurfaceCreateFlagsMVK": "",
  "VkIOSSurfaceCreateFlagsMVK.__none": "",
  "VkIOSSurfaceCreateInfoMVK": "Structure specifying parameters of a newly created iOS surface object.",
  "VkIOSSurfaceCreateInfoMVK.flags": "pname:flags is reserved for future use.",
  "VkIOSSurfaceCreateInfoMVK.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkIOSSurfaceCreateInfoMVK.pView": "pname:pView is a reference to a code:UIView object which will display this surface. This code:UIView must: be backed by a code:CALayer instance of type code:CAMetalLayer.",
  "VkIOSSurfaceCreateInfoMVK.sType": "pname:sType is the type of this structure.",
  "VkLayerProperties": "Structure specifying layer properties.",
  "VkLayerProperties.description": "pname:description is a null-terminated UTF-8 string providing additional details that can: be used by the application to identify the layer.",
  "VkLayerProperties.implementationVersion": "pname:implementationVersion is the version of this layer. It is an integer, increasing with backward compatible changes.",
  "VkLayerProperties.layerName": "pname:layerName is a null-terminated UTF-8 string specifying the name of the layer. Use this name in the pname:ppEnabledLayerNames array passed in the slink:VkInstanceCreateInfo structure to enable this layer for an instance.",
  "VkLayerProperties.specVersion": "pname:specVersion is the Vulkan version the layer was written to, encoded as described in the <<fundamentals-versionnum,API Version Numbers and Semantics>> section.",
  "VkLogicOp": "Framebuffer logical operations.",
  "VkLogicOp.VK_LOGIC_OP_AND": "",
  "VkLogicOp.VK_LOGIC_OP_AND_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_AND_REVERSE": "",
  "VkLogicOp.VK_LOGIC_OP_CLEAR": "",
  "VkLogicOp.VK_LOGIC_OP_COPY": "",
  "VkLogicOp.VK_LOGIC_OP_COPY_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_EQUIVALENT": "",
  "VkLogicOp.VK_LOGIC_OP_INVERT": "",
  "VkLogicOp.VK_LOGIC_OP_NAND": "",
  "VkLogicOp.VK_LOGIC_OP_NO_OP": "",
  "VkLogicOp.VK_LOGIC_OP_NOR": "",
  "VkLogicOp.VK_LOGIC_OP_OR": "",
  "VkLogicOp.VK_LOGIC_OP_OR_INVERTED": "",
  "VkLogicOp.VK_LOGIC_OP_OR_REVERSE": "",
  "VkLogicOp.VK_LOGIC_OP_SET": "",
  "VkLogicOp.VK_LOGIC_OP_XOR": "",
  "VkMacOSSurfaceCreateFlagsMVK": "",
  "VkMacOSSurfaceCreateFlagsMVK.__none": "",
  "VkMacOSSurfaceCreateInfoMVK": "Structure specifying parameters of a newly created macOS surface object.",
  "VkMacOSSurfaceCreateInfoMVK.flags": "pname:flags is reserved for future use.",
  "VkMacOSSurfaceCreateInfoMVK.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkMacOSSurfaceCreateInfoMVK.pView": "pname:pView is a reference to a code:NSView object which will display this surface. This code:NSView must: be backed by a code:CALayer instance of type code:CAMetalLayer.",
  "VkMacOSSurfaceCreateInfoMVK.sType": "pname:sType is the type of this structure.",
  "vkMapMemory": "Map a memory object into application address space.",
  "vkMapMemory.device": "",
  "vkMapMemory.flags": "",
  "vkMapMemory.memory": "",
  "vkMapMemory.offset": "",
  "vkMapMemory.ppData": "",
  "vkMapMemory.size": "",
  "VkMappedMemoryRange": "Structure specifying a mapped memory range.",
  "VkMappedMemoryRange.memory": "pname:memory is the memory object to which this range belongs.",
  "VkMappedMemoryRange.offset": "pname:offset is the zero-based byte offset from the beginning of the memory object.",
  "VkMappedMemoryRange.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkMappedMemoryRange.size": "pname:size is either the size of range, or ename:VK_WHOLE_SIZE to affect the range from pname:offset to the end of the current mapping of the allocation.",
  "VkMappedMemoryRange.sType": "pname:sType is the type of this structure.",
  "VkMemoryAllocateFlagBitsKHX": "Bitmask specifying flags for a device memory allocation.",
  "VkMemoryAllocateFlagsInfoKHX": "",
  "VkMemoryAllocateFlagsInfoKHX.deviceMask": "",
  "VkMemoryAllocateFlagsInfoKHX.flags": "",
  "VkMemoryAllocateFlagsInfoKHX.pNext": "",
  "VkMemoryAllocateFlagsInfoKHX.sType": "",
  "VkMemoryAllocateFlagsKHX": "",
  "VkMemoryAllocateFlagsKHX.__none": "",
  "VkMemoryAllocateFlagsKHX.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX": "",
  "VkMemoryAllocateInfo": "Structure containing parameters of a memory allocation.",
  "VkMemoryAllocateInfo.allocationSize": "pname:allocationSize is the size of the allocation in bytes",
  "VkMemoryAllocateInfo.memoryTypeIndex": "pname:memoryTypeIndex is the memory type index, which selects the properties of the memory to be allocated, as well as the heap the memory will come from.",
  "VkMemoryAllocateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkMemoryAllocateInfo.sType": "pname:sType is the type of this structure.",
  "VkMemoryBarrier": "Structure specifying a global memory barrier.",
  "VkMemoryBarrier.dstAccessMask": "pname:dstAccessMask defines a <<synchronization-access-masks, destination access mask>>.",
  "VkMemoryBarrier.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkMemoryBarrier.srcAccessMask": "pname:srcAccessMask defines a <<synchronization-access-masks, source access mask>>.",
  "VkMemoryBarrier.sType": "pname:sType is the type of this structure.",
  "VkMemoryDedicatedAllocateInfoKHR": "",
  "VkMemoryDedicatedAllocateInfoKHR.buffer": "",
  "VkMemoryDedicatedAllocateInfoKHR.image": "",
  "VkMemoryDedicatedAllocateInfoKHR.pNext": "",
  "VkMemoryDedicatedAllocateInfoKHR.sType": "",
  "VkMemoryDedicatedRequirementsKHR": "",
  "VkMemoryDedicatedRequirementsKHR.pNext": "",
  "VkMemoryDedicatedRequirementsKHR.prefersDedicatedAllocation": "",
  "VkMemoryDedicatedRequirementsKHR.requiresDedicatedAllocation": "",
  "VkMemoryDedicatedRequirementsKHR.sType": "",
  "VkMemoryFdPropertiesKHR": "",
  "VkMemoryFdPropertiesKHR.memoryTypeBits": "",
  "VkMemoryFdPropertiesKHR.pNext": "",
  "VkMemoryFdPropertiesKHR.sType": "",
  "VkMemoryGetFdInfoKHR": "",
  "VkMemoryGetFdInfoKHR.handleType": "",
  "VkMemoryGetFdInfoKHR.memory": "",
  "VkMemoryGetFdInfoKHR.pNext": "",
  "VkMemoryGetFdInfoKHR.sType": "",
  "VkMemoryGetWin32HandleInfoKHR": "",
  "VkMemoryGetWin32HandleInfoKHR.handleType": "",
  "VkMemoryGetWin32HandleInfoKHR.memory": "",
  "VkMemoryGetWin32HandleInfoKHR.pNext": "",
  "VkMemoryGetWin32HandleInfoKHR.sType": "",
  "VkMemoryHeap": "Structure specifying a memory heap.",
  "VkMemoryHeap.flags": "pname:flags is a bitmask of attribute flags for the heap. The bits specified in pname:flags are: + --",
  "VkMemoryHeap.size": "pname:size is the total memory size in bytes in the heap.",
  "VkMemoryHeapFlagBits": "Bitmask specifying attribute flags for a heap.",
  "VkMemoryHeapFlags": "",
  "VkMemoryHeapFlags.__none": "",
  "VkMemoryHeapFlags.VK_MEMORY_HEAP_DEVICE_LOCAL_BIT": "",
  "VkMemoryHeapFlags.VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX": "",
  "VkMemoryMapFlags": "",
  "VkMemoryMapFlags.__none": "",
  "VkMemoryPropertyFlagBits": "Bitmask specifying properties for a memory type.",
  "VkMemoryPropertyFlags": "",
  "VkMemoryPropertyFlags.__none": "",
  "VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT": "",
  "VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_CACHED_BIT": "",
  "VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_COHERENT_BIT": "",
  "VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT": "",
  "VkMemoryPropertyFlags.VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT": "",
  "VkMemoryRequirements": "Structure specifying memory requirements.",
  "VkMemoryRequirements.alignment": "pname:alignment is the alignment, in bytes, of the offset within the allocation required: for the resource.",
  "VkMemoryRequirements.memoryTypeBits": "pname:memoryTypeBits is a bitmask and contains one bit set for every supported memory type for the resource. Bit `i` is set if and only if the memory type `i` in the sname:VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.",
  "VkMemoryRequirements.size": "pname:size is the size, in bytes, of the memory allocation required: for the resource.",
  "VkMemoryRequirements2KHR": "",
  "VkMemoryRequirements2KHR.memoryRequirements": "",
  "VkMemoryRequirements2KHR.pNext": "",
  "VkMemoryRequirements2KHR.sType": "",
  "VkMemoryType": "Structure specifying memory type.",
  "VkMemoryType.heapIndex": "pname:heapIndex describes which memory heap this memory type corresponds to, and must: be less than pname:memoryHeapCount from the sname:VkPhysicalDeviceMemoryProperties structure.",
  "VkMemoryType.propertyFlags": "pname:propertyFlags is a bitmask of properties for this memory type. The bits specified in pname:propertyFlags are: + --",
  "VkMemoryWin32HandlePropertiesKHR": "",
  "VkMemoryWin32HandlePropertiesKHR.memoryTypeBits": "",
  "VkMemoryWin32HandlePropertiesKHR.pNext": "",
  "VkMemoryWin32HandlePropertiesKHR.sType": "",
  "vkMergePipelineCaches": "Combine the data stores of pipeline caches.",
  "vkMergePipelineCaches.device": "",
  "vkMergePipelineCaches.dstCache": "",
  "vkMergePipelineCaches.pSrcCaches": "",
  "vkMergePipelineCaches.srcCacheCount": "",
  "VkMirSurfaceCreateFlagsKHR": "",
  "VkMirSurfaceCreateFlagsKHR.__none": "",
  "VkMirSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Mir surface object.",
  "VkMirSurfaceCreateInfoKHR.connection": "pname:connection and pname:surface are pointers to the code:MirConnection and code:MirSurface for the window to associate the surface with.",
  "VkMirSurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkMirSurfaceCreateInfoKHR.mirSurface": "",
  "VkMirSurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkMirSurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkObjectEntryTypeNVX": "Enum specifying object table entry type.",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX": "",
  "VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX": "",
  "VkObjectEntryUsageFlagBitsNVX": "Bitmask specifying allowed usage of an object entry.",
  "VkObjectEntryUsageFlagsNVX": "",
  "VkObjectEntryUsageFlagsNVX.__none": "",
  "VkObjectEntryUsageFlagsNVX.VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX": "",
  "VkObjectEntryUsageFlagsNVX.VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX": "",
  "VkObjectTableCreateInfoNVX": "Structure specifying the parameters of a newly created object table.",
  "VkObjectTableCreateInfoNVX.maxPipelineLayouts": "pname:maxPipelineLayouts is the maximum number of unique sname:VkPipelineLayout used by any registered sname:VkDescriptorSet or sname:VkPipeline in this table.",
  "VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor": "pname:maxSampledImagesPerDescriptor is the maximum number of ename:VK_DESCRIPTOR_TYPE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT used by any single registered sname:VkDescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor": "pname:maxStorageBuffersPerDescriptor is the maximum number of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC used by any single registered sname:VkDescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor": "pname:maxStorageImagesPerDescriptor is the maximum number of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER used by any single registered sname:VkDescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor": "pname:maxUniformBuffersPerDescriptor is the maximum number of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC used by any single registered sname:VkDescriptorSet in this table.",
  "VkObjectTableCreateInfoNVX.objectCount": "pname:objectCount is the number of entry configurations that the object table supports. The following array parameters must match the size provided here.",
  "VkObjectTableCreateInfoNVX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkObjectTableCreateInfoNVX.pObjectEntryCounts": "pname:pObjectEntryCounts is an array of counts how many objects can be registered in the table.",
  "VkObjectTableCreateInfoNVX.pObjectEntryTypes": "pname:pObjectEntryTypes is an array of elink:VkObjectEntryTypeNVX providing the entry type of a given configuration.",
  "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags": "pname:pObjectEntryUsageFlags is an array of bitmasks describing the binding usage of the entry. See elink:VkObjectEntryUsageFlagBitsNVX below for a description of the supported bits.",
  "VkObjectTableCreateInfoNVX.sType": "pname:sType is the type of this structure.",
  "VkObjectTableDescriptorSetEntryNVX": "",
  "VkObjectTableDescriptorSetEntryNVX.descriptorSet": "",
  "VkObjectTableDescriptorSetEntryNVX.flags": "",
  "VkObjectTableDescriptorSetEntryNVX.pipelineLayout": "",
  "VkObjectTableDescriptorSetEntryNVX.type": "",
  "VkObjectTableEntryNVX": "",
  "VkObjectTableEntryNVX.flags": "",
  "VkObjectTableEntryNVX.type": "",
  "VkObjectTableIndexBufferEntryNVX": "",
  "VkObjectTableIndexBufferEntryNVX.buffer": "",
  "VkObjectTableIndexBufferEntryNVX.flags": "",
  "VkObjectTableIndexBufferEntryNVX.indexType": "",
  "VkObjectTableIndexBufferEntryNVX.type": "",
  "VkObjectTableNVX": "Opaque handle to an object table.",
  "VkObjectTablePipelineEntryNVX": "",
  "VkObjectTablePipelineEntryNVX.flags": "",
  "VkObjectTablePipelineEntryNVX.pipeline": "",
  "VkObjectTablePipelineEntryNVX.type": "",
  "VkObjectTablePushConstantEntryNVX": "",
  "VkObjectTablePushConstantEntryNVX.flags": "",
  "VkObjectTablePushConstantEntryNVX.pipelineLayout": "",
  "VkObjectTablePushConstantEntryNVX.stageFlags": "",
  "VkObjectTablePushConstantEntryNVX.type": "",
  "VkObjectTableVertexBufferEntryNVX": "",
  "VkObjectTableVertexBufferEntryNVX.buffer": "",
  "VkObjectTableVertexBufferEntryNVX.flags": "",
  "VkObjectTableVertexBufferEntryNVX.type": "",
  "VkObjectType": "",
  "VkObjectType.VK_OBJECT_TYPE_BUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_BUFFER_VIEW": "",
  "VkObjectType.VK_OBJECT_TYPE_COMMAND_BUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_COMMAND_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_SET": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT": "",
  "VkObjectType.VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_DEVICE": "",
  "VkObjectType.VK_OBJECT_TYPE_DEVICE_MEMORY": "",
  "VkObjectType.VK_OBJECT_TYPE_DISPLAY_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_DISPLAY_MODE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_EVENT": "",
  "VkObjectType.VK_OBJECT_TYPE_FENCE": "",
  "VkObjectType.VK_OBJECT_TYPE_FRAMEBUFFER": "",
  "VkObjectType.VK_OBJECT_TYPE_IMAGE": "",
  "VkObjectType.VK_OBJECT_TYPE_IMAGE_VIEW": "",
  "VkObjectType.VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX": "",
  "VkObjectType.VK_OBJECT_TYPE_INSTANCE": "",
  "VkObjectType.VK_OBJECT_TYPE_OBJECT_TABLE_NVX": "",
  "VkObjectType.VK_OBJECT_TYPE_PHYSICAL_DEVICE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE_CACHE": "",
  "VkObjectType.VK_OBJECT_TYPE_PIPELINE_LAYOUT": "",
  "VkObjectType.VK_OBJECT_TYPE_QUERY_POOL": "",
  "VkObjectType.VK_OBJECT_TYPE_QUEUE": "",
  "VkObjectType.VK_OBJECT_TYPE_RENDER_PASS": "",
  "VkObjectType.VK_OBJECT_TYPE_SAMPLER": "",
  "VkObjectType.VK_OBJECT_TYPE_SEMAPHORE": "",
  "VkObjectType.VK_OBJECT_TYPE_SHADER_MODULE": "",
  "VkObjectType.VK_OBJECT_TYPE_SURFACE_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_SWAPCHAIN_KHR": "",
  "VkObjectType.VK_OBJECT_TYPE_UNKNOWN": "",
  "VkOffset2D": "Structure specifying a two-dimensional offset.",
  "VkOffset2D.x": "",
  "VkOffset2D.y": "",
  "VkOffset3D": "Structure specifying a three-dimensional offset.",
  "VkOffset3D.x": "",
  "VkOffset3D.y": "",
  "VkOffset3D.z": "",
  "VkPastPresentationTimingGOOGLE": "",
  "VkPastPresentationTimingGOOGLE.actualPresentTime": "",
  "VkPastPresentationTimingGOOGLE.desiredPresentTime": "",
  "VkPastPresentationTimingGOOGLE.earliestPresentTime": "",
  "VkPastPresentationTimingGOOGLE.presentID": "",
  "VkPastPresentationTimingGOOGLE.presentMargin": "",
  "VkPeerMemoryFeatureFlagBitsKHX": "Bitmask specifying supported peer memory features.",
  "VkPeerMemoryFeatureFlagsKHX": "",
  "VkPeerMemoryFeatureFlagsKHX.__none": "",
  "VkPeerMemoryFeatureFlagsKHX.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagsKHX.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagsKHX.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX": "",
  "VkPeerMemoryFeatureFlagsKHX.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX": "",
  "VkPhysicalDevice": "Opaque handle to a physical device object.",
  "VkPhysicalDevice16BitStorageFeaturesKHR": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.pNext": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storageBuffer16BitAccess": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storageInputOutput16": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.storagePushConstant16": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.sType": "",
  "VkPhysicalDevice16BitStorageFeaturesKHR.uniformAndStorageBuffer16BitAccess": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.advancedBlendCoherentOperations": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext": "",
  "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendAllOperations": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendCorrelatedOverlap": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendIndependentBlend": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendMaxColorAttachments": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendNonPremultipliedDstColor": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.advancedBlendNonPremultipliedSrcColor": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext": "",
  "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.maxDiscardRectangles": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext": "",
  "VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.flags": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.sType": "",
  "VkPhysicalDeviceExternalBufferInfoKHR.usage": "",
  "VkPhysicalDeviceExternalFenceInfoKHR": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalFenceInfoKHR.sType": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalImageFormatInfoKHR.sType": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext": "",
  "VkPhysicalDeviceExternalSemaphoreInfoKHR.sType": "",
  "VkPhysicalDeviceFeatures": "Structure describing the fine-grained features that can be supported by an implementation.",
  "VkPhysicalDeviceFeatures.alphaToOne": "",
  "VkPhysicalDeviceFeatures.depthBiasClamp": "",
  "VkPhysicalDeviceFeatures.depthBounds": "",
  "VkPhysicalDeviceFeatures.depthClamp": "",
  "VkPhysicalDeviceFeatures.drawIndirectFirstInstance": "",
  "VkPhysicalDeviceFeatures.dualSrcBlend": "",
  "VkPhysicalDeviceFeatures.fillModeNonSolid": "",
  "VkPhysicalDeviceFeatures.fragmentStoresAndAtomics": "",
  "VkPhysicalDeviceFeatures.fullDrawIndexUint32": "",
  "VkPhysicalDeviceFeatures.geometryShader": "",
  "VkPhysicalDeviceFeatures.imageCubeArray": "",
  "VkPhysicalDeviceFeatures.independentBlend": "",
  "VkPhysicalDeviceFeatures.inheritedQueries": "",
  "VkPhysicalDeviceFeatures.largePoints": "",
  "VkPhysicalDeviceFeatures.logicOp": "",
  "VkPhysicalDeviceFeatures.multiDrawIndirect": "",
  "VkPhysicalDeviceFeatures.multiViewport": "",
  "VkPhysicalDeviceFeatures.occlusionQueryPrecise": "",
  "VkPhysicalDeviceFeatures.pipelineStatisticsQuery": "",
  "VkPhysicalDeviceFeatures.robustBufferAccess": "",
  "VkPhysicalDeviceFeatures.samplerAnisotropy": "",
  "VkPhysicalDeviceFeatures.sampleRateShading": "",
  "VkPhysicalDeviceFeatures.shaderClipDistance": "",
  "VkPhysicalDeviceFeatures.shaderCullDistance": "",
  "VkPhysicalDeviceFeatures.shaderFloat64": "",
  "VkPhysicalDeviceFeatures.shaderImageGatherExtended": "",
  "VkPhysicalDeviceFeatures.shaderInt16": "",
  "VkPhysicalDeviceFeatures.shaderInt64": "",
  "VkPhysicalDeviceFeatures.shaderResourceMinLod": "",
  "VkPhysicalDeviceFeatures.shaderResourceResidency": "",
  "VkPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageBufferArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageExtendedFormats": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageMultisample": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageReadWithoutFormat": "",
  "VkPhysicalDeviceFeatures.shaderStorageImageWriteWithoutFormat": "",
  "VkPhysicalDeviceFeatures.shaderTessellationAndGeometryPointSize": "",
  "VkPhysicalDeviceFeatures.shaderUniformBufferArrayDynamicIndexing": "",
  "VkPhysicalDeviceFeatures.sparseBinding": "",
  "VkPhysicalDeviceFeatures.sparseResidency16Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency2Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency4Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidency8Samples": "",
  "VkPhysicalDeviceFeatures.sparseResidencyAliased": "",
  "VkPhysicalDeviceFeatures.sparseResidencyBuffer": "",
  "VkPhysicalDeviceFeatures.sparseResidencyImage2D": "",
  "VkPhysicalDeviceFeatures.sparseResidencyImage3D": "",
  "VkPhysicalDeviceFeatures.tessellationShader": "",
  "VkPhysicalDeviceFeatures.textureCompressionASTC_LDR": "",
  "VkPhysicalDeviceFeatures.textureCompressionBC": "",
  "VkPhysicalDeviceFeatures.textureCompressionETC2": "",
  "VkPhysicalDeviceFeatures.variableMultisampleRate": "",
  "VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics": "",
  "VkPhysicalDeviceFeatures.wideLines": "",
  "VkPhysicalDeviceFeatures2KHR": "Structure describing the fine-grained features that can be supported by an implementation.",
  "VkPhysicalDeviceFeatures2KHR.features": "pname:features is a structure of type slink:VkPhysicalDeviceFeatures describing the fine-grained features of the Vulkan 1.0 API.",
  "VkPhysicalDeviceFeatures2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceFeatures2KHR.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDeviceGroupPropertiesKHX": "Structure specifying physical device group properties.",
  "VkPhysicalDeviceGroupPropertiesKHX.physicalDeviceCount": "pname:physicalDeviceCount is the number of physical devices in the group.",
  "VkPhysicalDeviceGroupPropertiesKHX.physicalDevices": "pname:physicalDevices is an array of physical device handles representing all physical devices in the group. The first pname:physicalDeviceCount elements of the array will be valid.",
  "VkPhysicalDeviceGroupPropertiesKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceGroupPropertiesKHX.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDeviceGroupPropertiesKHX.subsetAllocation": "pname:subsetAllocation indicates whether logical devices created from the group support allocating device memory on a subset of devices, via the pname:deviceMask member of the slink:VkMemoryAllocateFlagsInfoKHX. If this is ename:VK_FALSE, then all device memory allocations are made across all physical devices in the group. If pname:physicalDeviceCount is `1`, then pname:subsetAllocation must: be ename:VK_FALSE.",
  "VkPhysicalDeviceIDPropertiesKHR": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceLUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceLUIDValid": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceNodeMask": "",
  "VkPhysicalDeviceIDPropertiesKHR.deviceUUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.driverUUID": "",
  "VkPhysicalDeviceIDPropertiesKHR.pNext": "",
  "VkPhysicalDeviceIDPropertiesKHR.sType": "",
  "VkPhysicalDeviceImageFormatInfo2KHR": "Structure specifying image creation parameters.",
  "VkPhysicalDeviceImageFormatInfo2KHR.flags": "pname:flags is a bitmask describing additional parameters of the image, corresponding to slink:VkImageCreateInfo::pname:flags.",
  "VkPhysicalDeviceImageFormatInfo2KHR.format": "pname:format is the image format, corresponding to slink:VkImageCreateInfo::pname:format.",
  "VkPhysicalDeviceImageFormatInfo2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceImageFormatInfo2KHR.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDeviceImageFormatInfo2KHR.tiling": "pname:tiling is the image tiling, corresponding to slink:VkImageCreateInfo::pname:tiling.",
  "VkPhysicalDeviceImageFormatInfo2KHR.type": "pname:type is the image type, corresponding to slink:VkImageCreateInfo::pname:imageType.",
  "VkPhysicalDeviceImageFormatInfo2KHR.usage": "pname:usage is the intended usage of the image, corresponding to slink:VkImageCreateInfo::pname:usage.",
  "VkPhysicalDeviceLimits": "Structure reporting implementation-dependent physical device limits.",
  "VkPhysicalDeviceLimits.bufferImageGranularity": "pname:bufferImageGranularity is the granularity, in bytes, at which buffer or linear image resources, and optimal image resources can: be bound to adjacent offsets in the same sname:VkDeviceMemory object without aliasing. See <<resources-bufferimagegranularity,Buffer-Image Granularity>> for more details.",
  "VkPhysicalDeviceLimits.discreteQueuePriorities": " pname:discreteQueuePriorities is the number of discrete priorities that can: be assigned to a queue based on the value of each member of sname:VkDeviceQueueCreateInfo::pname:pQueuePriorities. This must: be at least 2, and levels must: be spread evenly over the range, with at least one level at 1.0, and another at 0.0. See <<devsandqueues-priority>>.",
  "VkPhysicalDeviceLimits.framebufferColorSampleCounts": " pname:framebufferColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the color sample counts that are supported for all framebuffer color attachments.",
  "VkPhysicalDeviceLimits.framebufferDepthSampleCounts": " pname:framebufferDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported depth sample counts for all framebuffer depth/stencil attachments, when the format includes a depth component.",
  "VkPhysicalDeviceLimits.framebufferNoAttachmentsSampleCounts": "pname:framebufferNoAttachmentsSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported sample counts for a framebuffer with no attachments.",
  "VkPhysicalDeviceLimits.framebufferStencilSampleCounts": "pname:framebufferStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the supported stencil sample counts for all framebuffer depth/stencil attachments, when the format includes a stencil component.",
  "VkPhysicalDeviceLimits.lineWidthGranularity": "pname:lineWidthGranularity is the granularity of supported line widths. Not all line widths in the range defined by pname:lineWidthRange are supported. This limit specifies the granularity (or increment) between successive supported line widths.",
  "VkPhysicalDeviceLimits.lineWidthRange": "pname:lineWidthRange[2] is the range [eq]#[pname:minimum,pname:maximum]# of supported widths for lines. Values specified by the pname:lineWidth member of the sname:VkPipelineRasterizationStateCreateInfo or the pname:lineWidth parameter to fname:vkCmdSetLineWidth are clamped to this range.",
  "VkPhysicalDeviceLimits.maxBoundDescriptorSets": "pname:maxBoundDescriptorSets is the maximum number of descriptor sets that can: be simultaneously used by a pipeline. All code:DescriptorSet decorations in shader modules must: have a value less than pname:maxBoundDescriptorSets. See <<descriptorsets-sets>>.",
  "VkPhysicalDeviceLimits.maxClipDistances": "pname:maxClipDistances is the maximum number of clip distances that can: be used in a single shader stage. The size of any array declared with the code:ClipDistance built-in decoration in a shader module must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxColorAttachments": "pname:maxColorAttachments is the maximum number of color attachments that can: be used by a subpass in a render pass. The pname:colorAttachmentCount member of the sname:VkSubpassDescription structure must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxCombinedClipAndCullDistances": " pname:maxCombinedClipAndCullDistances is the maximum combined number of clip and cull distances that can: be used in a single shader stage. The sum of the sizes of any pair of arrays declared with the code:ClipDistance and code:CullDistance built-in decoration used by a single shader stage in a shader module must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxComputeSharedMemorySize": " pname:maxComputeSharedMemorySize is the maximum total storage size, in bytes, of all variables declared with the code:WorkgroupLocal storage class in shader modules (or with the code:shared storage qualifier in GLSL) in the compute shader stage.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupCount": " pname:maxComputeWorkGroupCount[3] is the maximum number of local workgroups that can: be dispatched by a single dispatch command. These three values represent the maximum number of local workgroups for the X, Y, and Z dimensions, respectively. The workgroup count parameters to the dispatch commands must: be less than or equal to the corresponding limit. See <<dispatch>>.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupInvocations": " pname:maxComputeWorkGroupInvocations is the maximum total number of compute shader invocations in a single local workgroup. The product of the X, Y, and Z sizes as specified by the code:LocalSize execution mode in shader modules and by the object decorated by the code:WorkgroupSize decoration must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxComputeWorkGroupSize": " pname:maxComputeWorkGroupSize[3] is the maximum size of a local compute workgroup, per dimension. These three values represent the maximum local workgroup size in the X, Y, and Z dimensions, respectively. The pname:x, pname:y, and pname:z sizes specified by the code:LocalSize execution mode and by the object decorated by the code:WorkgroupSize decoration in shader modules must: be less than or equal to the corresponding limit.",
  "VkPhysicalDeviceLimits.maxCullDistances": "pname:maxCullDistances is the maximum number of cull distances that can: be used in a single shader stage. The size of any array declared with the code:CullDistance built-in decoration in a shader module must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxDescriptorSetInputAttachments": " pname:maxDescriptorSetInputAttachments is the maximum number of input attachments that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. See <<descriptorsets-inputattachment>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetSampledImages": " pname:maxDescriptorSetSampledImages is the maximum number of sampled images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. See <<descriptorsets-combinedimagesampler>>, <<descriptorsets-sampledimage>>, and <<descriptorsets-uniformtexelbuffer>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetSamplers": " pname:maxDescriptorSetSamplers is the maximum number of samplers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. See <<descriptorsets-sampler>> and <<descriptorsets-combinedimagesampler>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageBuffers": " pname:maxDescriptorSetStorageBuffers is the maximum number of storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-storagebuffer>> and <<descriptorsets-storagebufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageBuffersDynamic": " pname:maxDescriptorSetStorageBuffersDynamic is the maximum number of dynamic storage buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-storagebufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetStorageImages": " pname:maxDescriptorSetStorageImages is the maximum number of storage images that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. See <<descriptorsets-storageimage>>, and <<descriptorsets-storagetexelbuffer>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetUniformBuffers": " pname:maxDescriptorSetUniformBuffers is the maximum number of uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-uniformbuffer>> and <<descriptorsets-uniformbufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxDescriptorSetUniformBuffersDynamic": " pname:maxDescriptorSetUniformBuffersDynamic is the maximum number of dynamic uniform buffers that can: be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. See <<descriptorsets-uniformbufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxDrawIndexedIndexValue": " pname:maxDrawIndexedIndexValue is the maximum index value that can: be used for indexed draw calls when using 32-bit indices. This excludes the primitive restart index value of 0xFFFFFFFF. See <<features-features-fullDrawIndexUint32,fullDrawIndexUint32>>.",
  "VkPhysicalDeviceLimits.maxDrawIndirectCount": "pname:maxDrawIndirectCount is the maximum draw count that is supported for indirect draw calls. See <<features-features-multiDrawIndirect,multiDrawIndirect>>.",
  "VkPhysicalDeviceLimits.maxFragmentCombinedOutputResources": " pname:maxFragmentCombinedOutputResources is the total number of storage buffers, storage images, and output buffers which can: be used in the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFragmentDualSrcAttachments": " pname:maxFragmentDualSrcAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage when blending is enabled and one of the dual source blend modes is in use. See <<framebuffer-dsb>> and <<features-features-dualSrcBlend,dualSrcBlend>>.",
  "VkPhysicalDeviceLimits.maxFragmentInputComponents": " pname:maxFragmentInputComponents is the maximum number of components of input variables which can: be provided as inputs to the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFragmentOutputAttachments": " pname:maxFragmentOutputAttachments is the maximum number of output attachments which can: be written to by the fragment shader stage.",
  "VkPhysicalDeviceLimits.maxFramebufferHeight": "pname:maxFramebufferHeight is the maximum height for a framebuffer. The pname:height member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxFramebufferLayers": "pname:maxFramebufferLayers is the maximum layer count for a layered framebuffer. The pname:layers member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxFramebufferWidth": "pname:maxFramebufferWidth is the maximum width for a framebuffer. The pname:width member of the sname:VkFramebufferCreateInfo structure must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxGeometryInputComponents": " pname:maxGeometryInputComponents is the maximum number of components of input variables which can: be provided as inputs to the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxGeometryOutputComponents": " pname:maxGeometryOutputComponents is the maximum number of components of output variables which can: be output from the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxGeometryOutputVertices": " pname:maxGeometryOutputVertices is the maximum number of vertices which can: be emitted by any geometry shader.",
  "VkPhysicalDeviceLimits.maxGeometryShaderInvocations": " pname:maxGeometryShaderInvocations is the maximum invocation count supported for instanced geometry shaders. The value provided in the code:Invocations execution mode of shader modules must: be less than or equal to this limit. See <<geometry>>.",
  "VkPhysicalDeviceLimits.maxGeometryTotalOutputComponents": " pname:maxGeometryTotalOutputComponents is the maximum total number of components of output, across all emitted vertices, which can: be output from the geometry shader stage.",
  "VkPhysicalDeviceLimits.maxImageArrayLayers": "pname:maxImageArrayLayers is the maximum number of layers (pname:arrayLayers) for an image.",
  "VkPhysicalDeviceLimits.maxImageDimension1D": "pname:maxImageDimension1D is the maximum dimension (pname:width) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_1D.",
  "VkPhysicalDeviceLimits.maxImageDimension2D": "pname:maxImageDimension2D is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and without ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.",
  "VkPhysicalDeviceLimits.maxImageDimension3D": "pname:maxImageDimension3D is the maximum dimension (pname:width, pname:height, or pname:depth) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_3D.",
  "VkPhysicalDeviceLimits.maxImageDimensionCube": "pname:maxImageDimensionCube is the maximum dimension (pname:width or pname:height) of an image created with an pname:imageType of ename:VK_IMAGE_TYPE_2D and with ename:VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT set in pname:flags.",
  "VkPhysicalDeviceLimits.maxInterpolationOffset": "pname:maxInterpolationOffset is the maximum positive offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.",
  "VkPhysicalDeviceLimits.maxMemoryAllocationCount": " pname:maxMemoryAllocationCount is the maximum number of device memory allocations, as created by flink:vkAllocateMemory, which can: simultaneously exist.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorInputAttachments": " pname:maxPerStageDescriptorInputAttachments is the maximum number of input attachments that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. These are only supported for the fragment stage. See <<descriptorsets-inputattachment>>.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorSampledImages": " pname:maxPerStageDescriptorSampledImages is the maximum number of sampled images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-combinedimagesampler>>, <<descriptorsets-sampledimage>>, and <<descriptorsets-uniformtexelbuffer>>.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorSamplers": " pname:maxPerStageDescriptorSamplers is the maximum number of samplers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_SAMPLER or ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-sampler>> and <<descriptorsets-combinedimagesampler>>.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorStorageBuffers": " pname:maxPerStageDescriptorStorageBuffers is the maximum number of storage buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-storagebuffer>> and <<descriptorsets-storagebufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorStorageImages": " pname:maxPerStageDescriptorStorageImages is the maximum number of storage images that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER count against this limit. A descriptor is accessible to a pipeline shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-storageimage>>, and <<descriptorsets-storagetexelbuffer>>.",
  "VkPhysicalDeviceLimits.maxPerStageDescriptorUniformBuffers": " pname:maxPerStageDescriptorUniformBuffers is the maximum number of uniform buffers that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC count against this limit. A descriptor is accessible to a shader stage when the pname:stageFlags member of the sname:VkDescriptorSetLayoutBinding structure has the bit for that shader stage set. See <<descriptorsets-uniformbuffer>> and <<descriptorsets-uniformbufferdynamic>>.",
  "VkPhysicalDeviceLimits.maxPerStageResources": "pname:maxPerStageResources is the maximum number of resources that can: be accessible to a single shader stage in a pipeline layout. Descriptors with a type of ename:VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, ename:VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, ename:VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, ename:VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, or ename:VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT count against this limit. For the fragment shader stage the framebuffer color attachments also count against this limit.",
  "VkPhysicalDeviceLimits.maxPushConstantsSize": "pname:maxPushConstantsSize is the maximum size, in bytes, of the pool of push constant memory. For each of the push constant ranges indicated by the pname:pPushConstantRanges member of the sname:VkPipelineLayoutCreateInfo structure, pname:offset + pname:size must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.maxSampleMaskWords": "pname:maxSampleMaskWords is the maximum number of array elements of a variable decorated with the code:SampleMask built-in decoration.",
  "VkPhysicalDeviceLimits.maxSamplerAllocationCount": " pname:maxSamplerAllocationCount is the maximum number of sampler objects, as created by flink:vkCreateSampler, which can: simultaneously exist on a device.",
  "VkPhysicalDeviceLimits.maxSamplerAnisotropy": "pname:maxSamplerAnisotropy is the maximum degree of sampler anisotropy. The maximum degree of anisotropic filtering used for an image sampling operation is the minimum of the pname:maxAnisotropy member of the sname:VkSamplerCreateInfo structure and this limit. See <<samplers-maxAnisotropy>>.",
  "VkPhysicalDeviceLimits.maxSamplerLodBias": "pname:maxSamplerLodBias is the maximum absolute sampler level of detail bias. The sum of the pname:mipLodBias member of the sname:VkSamplerCreateInfo structure and the code:Bias operand of image sampling operations in shader modules (or 0 if no code:Bias operand is provided to an image sampling operation) are clamped to the range [eq]#[-pname:maxSamplerLodBias,+pname:maxSamplerLodBias]#. See <<samplers-mipLodBias>>.",
  "VkPhysicalDeviceLimits.maxStorageBufferRange": "pname:maxStorageBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerPatchOutputComponents": " pname:maxTessellationControlPerPatchOutputComponents is the maximum number of components of per-patch output variables which can: be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerVertexInputComponents": " pname:maxTessellationControlPerVertexInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlPerVertexOutputComponents": " pname:maxTessellationControlPerVertexOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationControlTotalOutputComponents": " pname:maxTessellationControlTotalOutputComponents is the maximum total number of components of per-vertex and per-patch output variables which can: be output from the tessellation control shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationEvaluationInputComponents": " pname:maxTessellationEvaluationInputComponents is the maximum number of components of input variables which can: be provided as per-vertex inputs to the tessellation evaluation shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationEvaluationOutputComponents": " pname:maxTessellationEvaluationOutputComponents is the maximum number of components of per-vertex output variables which can: be output from the tessellation evaluation shader stage.",
  "VkPhysicalDeviceLimits.maxTessellationGenerationLevel": " pname:maxTessellationGenerationLevel is the maximum tessellation generation level supported by the fixed-function tessellation primitive generator. See <<tessellation>>.",
  "VkPhysicalDeviceLimits.maxTessellationPatchSize": " pname:maxTessellationPatchSize is the maximum patch size, in vertices, of patches that can: be processed by the tessellation control shader and tessellation primitive generator. The pname:patchControlPoints member of the sname:VkPipelineTessellationStateCreateInfo structure specified at pipeline creation time and the value provided in the code:OutputVertices execution mode of shader modules must: be less than or equal to this limit. See <<tessellation>>.",
  "VkPhysicalDeviceLimits.maxTexelBufferElements": "pname:maxTexelBufferElements is the maximum number of addressable texels for a buffer view created on a buffer which was created with the ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure.",
  "VkPhysicalDeviceLimits.maxTexelGatherOffset": "pname:maxTexelGatherOffset is the maximum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.",
  "VkPhysicalDeviceLimits.maxTexelOffset": "pname:maxTexelOffset is the maximum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.",
  "VkPhysicalDeviceLimits.maxUniformBufferRange": "pname:maxUniformBufferRange is the maximum value that can: be specified in the pname:range member of any slink:VkDescriptorBufferInfo structures passed to a call to flink:vkUpdateDescriptorSets for descriptors of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.",
  "VkPhysicalDeviceLimits.maxVertexInputAttributeOffset": " pname:maxVertexInputAttributeOffset is the maximum vertex input attribute offset that can: be added to the vertex input binding stride. The pname:offset member of the sname:VkVertexInputAttributeDescription structure must: be less than or equal to this limit. See <<fxvertex-input>>.",
  "VkPhysicalDeviceLimits.maxVertexInputAttributes": " pname:maxVertexInputAttributes is the maximum number of vertex input attributes that can: be specified for a graphics pipeline. These are described in the array of sname:VkVertexInputAttributeDescription structures that are provided at graphics pipeline creation time via the pname:pVertexAttributeDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. See <<fxvertex-attrib>> and <<fxvertex-input>>.",
  "VkPhysicalDeviceLimits.maxVertexInputBindings": "pname:maxVertexInputBindings is the maximum number of vertex buffers that can: be specified for providing vertex attributes to a graphics pipeline. These are described in the array of sname:VkVertexInputBindingDescription structures that are provided at graphics pipeline creation time via the pname:pVertexBindingDescriptions member of the sname:VkPipelineVertexInputStateCreateInfo structure. The pname:binding member of sname:VkVertexInputBindingDescription must: be less than this limit. See <<fxvertex-input>>.",
  "VkPhysicalDeviceLimits.maxVertexInputBindingStride": " pname:maxVertexInputBindingStride is the maximum vertex input binding stride that can: be specified in a vertex input binding. The pname:stride member of the sname:VkVertexInputBindingDescription structure must: be less than or equal to this limit. See <<fxvertex-input>>.",
  "VkPhysicalDeviceLimits.maxVertexOutputComponents": " pname:maxVertexOutputComponents is the maximum number of components of output variables which can: be output by a vertex shader. See <<shaders-vertex>>.",
  "VkPhysicalDeviceLimits.maxViewportDimensions": "pname:maxViewportDimensions[2] are the maximum viewport dimensions in the X (width) and Y (height) dimensions, respectively. The maximum viewport dimensions must: be greater than or equal to the largest image which can: be created and used as a framebuffer attachment. See <<vertexpostproc-viewport,Controlling the Viewport>>.",
  "VkPhysicalDeviceLimits.maxViewports": "pname:maxViewports is the maximum number of active viewports. The pname:viewportCount member of the sname:VkPipelineViewportStateCreateInfo structure that is provided at pipeline creation must: be less than or equal to this limit.",
  "VkPhysicalDeviceLimits.minInterpolationOffset": "pname:minInterpolationOffset is the minimum negative offset value for the code:offset operand of the code:InterpolateAtOffset extended instruction.",
  "VkPhysicalDeviceLimits.minMemoryMapAlignment": "pname:minMemoryMapAlignment is the minimum required: alignment, in bytes, of host visible memory allocations within the host address space. When mapping a memory allocation with flink:vkMapMemory, subtracting pname:offset bytes from the returned pointer will always produce an integer multiple of this limit. See <<memory-device-hostaccess>>.",
  "VkPhysicalDeviceLimits.minStorageBufferOffsetAlignment": " pname:minStorageBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for storage buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or ename:VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for storage buffers must: be multiples of this limit.",
  "VkPhysicalDeviceLimits.minTexelBufferOffsetAlignment": " pname:minTexelBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkBufferViewCreateInfo structure for texel buffers. When a buffer view is created for a buffer which was created with ename:VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or ename:VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set in the pname:usage member of the sname:VkBufferCreateInfo structure, the pname:offset must: be an integer multiple of this limit.",
  "VkPhysicalDeviceLimits.minTexelGatherOffset": "pname:minTexelGatherOffset is the minimum offset value for the code:Offset or code:ConstOffsets image operands of any of the code:OpImage*code:Gather image instructions.",
  "VkPhysicalDeviceLimits.minTexelOffset": "pname:minTexelOffset is the minimum offset value for the code:ConstOffset image operand of any of the code:OpImageSample* or code:OpImageFetch* image instructions.",
  "VkPhysicalDeviceLimits.minUniformBufferOffsetAlignment": " pname:minUniformBufferOffsetAlignment is the minimum required: alignment, in bytes, for the pname:offset member of the sname:VkDescriptorBufferInfo structure for uniform buffers. When a descriptor of type ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or ename:VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC is updated, the pname:offset must: be an integer multiple of this limit. Similarly, dynamic offsets for uniform buffers must: be multiples of this limit.",
  "VkPhysicalDeviceLimits.mipmapPrecisionBits": "pname:mipmapPrecisionBits is the number of bits of division that the LOD calculation for mipmap fetching get snapped to when determining the contribution from each mip level to the mip filtered results. [eq]#2^pname:mipmapPrecisionBits^# is the actual number of divisions. + -- [NOTE] .Note ==== For example, if this value is 2 bits then when linearly filtering between two levels, each level could: contribute: 0%, 33%, 66%, or 100% (this is just an example and the amount of contribution should: be covered by different equations in the spec). ==== -- +",
  "VkPhysicalDeviceLimits.nonCoherentAtomSize": "pname:nonCoherentAtomSize is the size and alignment in bytes that bounds concurrent access to <<memory-device-hostaccess, host-mapped device memory>>.",
  "VkPhysicalDeviceLimits.optimalBufferCopyOffsetAlignment": " pname:optimalBufferCopyOffsetAlignment is the optimal buffer offset alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.",
  "VkPhysicalDeviceLimits.optimalBufferCopyRowPitchAlignment": " pname:optimalBufferCopyRowPitchAlignment is the optimal buffer row pitch alignment in bytes for fname:vkCmdCopyBufferToImage and fname:vkCmdCopyImageToBuffer. Row pitch is the number of bytes between texels with the same X coordinate in adjacent rows (Y coordinates differ by one). The per texel alignment requirements are still enforced, this is just an additional alignment recommendation for optimal performance and power.",
  "VkPhysicalDeviceLimits.pointSizeGranularity": "pname:pointSizeGranularity is the granularity of supported point sizes. Not all point sizes in the range defined by pname:pointSizeRange are supported. This limit specifies the granularity (or increment) between successive supported point sizes.",
  "VkPhysicalDeviceLimits.pointSizeRange": "pname:pointSizeRange[2] is the range [eq]#[pname:minimum,pname:maximum]# of supported sizes for points. Values written to variables decorated with the code:PointSize built-in decoration are clamped to this range.",
  "VkPhysicalDeviceLimits.sampledImageColorSampleCounts": " pname:sampledImageColorSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a non-integer color format.",
  "VkPhysicalDeviceLimits.sampledImageDepthSampleCounts": " pname:sampledImageDepthSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a depth format.",
  "VkPhysicalDeviceLimits.sampledImageIntegerSampleCounts": " pname:sampledImageIntegerSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and an integer color format.",
  "VkPhysicalDeviceLimits.sampledImageStencilSampleCounts": " pname:sampledImageStencilSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, pname:usage containing ename:VK_IMAGE_USAGE_SAMPLED_BIT, and a stencil format.",
  "VkPhysicalDeviceLimits.sparseAddressSpaceSize": "pname:sparseAddressSpaceSize is the total amount of address space available, in bytes, for sparse memory resources. This is an upper bound on the sum of the size of all sparse resources, regardless of whether any memory is bound to them.",
  "VkPhysicalDeviceLimits.standardSampleLocations": " pname:standardSampleLocations indicates whether rasterization uses the standard sample locations as documented in <<primsrast-multisampling,Multisampling>>. If set to ename:VK_TRUE, the implementation uses the documented sample locations. If set to ename:VK_FALSE, the implementation may: use different sample locations.",
  "VkPhysicalDeviceLimits.storageImageSampleCounts": " pname:storageImageSampleCounts is a bitmask^1^ of elink:VkSampleCountFlagBits bits indicating the sample counts supported for all 2D images created with ename:VK_IMAGE_TILING_OPTIMAL, and pname:usage containing ename:VK_IMAGE_USAGE_STORAGE_BIT.",
  "VkPhysicalDeviceLimits.strictLines": "pname:strictLines indicates whether lines are rasterized according to the preferred method of rasterization. If set to ename:VK_FALSE, lines may: be rasterized under a relaxed set of rules. If set to ename:VK_TRUE, lines are rasterized as per the strict definition. See <<primsrast-lines-basic,Basic Line Segment Rasterization>>.",
  "VkPhysicalDeviceLimits.subPixelInterpolationOffsetBits": " pname:subPixelInterpolationOffsetBits is the number of subpixel fractional bits that the code:x and code:y offsets to the code:InterpolateAtOffset extended instruction may: be rounded to as fixed-point values.",
  "VkPhysicalDeviceLimits.subPixelPrecisionBits": "pname:subPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates [eq]#x~f~# and [eq]#y~f~#. See <<primsrast>>.",
  "VkPhysicalDeviceLimits.subTexelPrecisionBits": "pname:subTexelPrecisionBits is the number of bits of precision in the division along an axis of an image used for minification and magnification filters. [eq]#2^pname:subTexelPrecisionBits^# is the actual number of divisions along each axis of the image represented. The filtering hardware will snap to these locations when computing the filtered results.",
  "VkPhysicalDeviceLimits.timestampComputeAndGraphics": " pname:timestampComputeAndGraphics indicates support for timestamps on all graphics and compute queues. If this limit is set to ename:VK_TRUE, all queues that advertise the ename:VK_QUEUE_GRAPHICS_BIT or ename:VK_QUEUE_COMPUTE_BIT in the sname:VkQueueFamilyProperties::pname:queueFlags support sname:VkQueueFamilyProperties::pname:timestampValidBits of at least 36. See <<queries-timestamps, Timestamp Queries>>.",
  "VkPhysicalDeviceLimits.timestampPeriod": "pname:timestampPeriod is the number of nanoseconds required: for a timestamp query to be incremented by 1. See <<queries-timestamps, Timestamp Queries>>.",
  "VkPhysicalDeviceLimits.viewportBoundsRange": "pname:viewportBoundsRange[2] is the [eq]#[minimum, maximum]# range that the corners of a viewport must: be contained in. This range must: be at least [eq]#[-2 {times} pname:size, 2 {times} pname:size - 1]#, where [eq]#pname:size = max(pname:maxViewportDimensions[0], pname:maxViewportDimensions[1])#. See <<vertexpostproc-viewport,Controlling the Viewport>>. + -- [NOTE] .Note ==== The intent of the pname:viewportBoundsRange limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [eq]#[-pname:size + 1, 2 {times} pname:size - 1]# which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range. ==== --",
  "VkPhysicalDeviceLimits.viewportSubPixelBits": "pname:viewportSubPixelBits is the number of bits of subpixel precision for viewport bounds. The subpixel precision that floating-point viewport bounds are interpreted at is given by this limit.",
  "VkPhysicalDeviceMemoryProperties": "Structure specifying physical device memory properties.",
  "VkPhysicalDeviceMemoryProperties.memoryHeapCount": "pname:memoryHeapCount is the number of valid elements in the pname:memoryHeaps array.",
  "VkPhysicalDeviceMemoryProperties.memoryHeaps": "pname:memoryHeaps is an array of slink:VkMemoryHeap structures describing the _memory heaps_ from which memory can: be allocated.",
  "VkPhysicalDeviceMemoryProperties.memoryTypeCount": "pname:memoryTypeCount is the number of valid elements in the pname:memoryTypes array.",
  "VkPhysicalDeviceMemoryProperties.memoryTypes": "pname:memoryTypes is an array of slink:VkMemoryType structures describing the _memory types_ that can: be used to access memory allocated from the heaps specified by pname:memoryHeaps.",
  "VkPhysicalDeviceMemoryProperties2KHR": "Structure specifying physical device memory properties.",
  "VkPhysicalDeviceMemoryProperties2KHR.memoryProperties": "pname:memoryProperties is a structure of type slink:VkPhysicalDeviceMemoryProperties which is populated with the same values as in flink:vkGetPhysicalDeviceMemoryProperties.",
  "VkPhysicalDeviceMemoryProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceMemoryProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDeviceMultiviewFeaturesKHX": "Structure describing multiview features that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiview": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiviewGeometryShader": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.multiviewTessellationShader": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.pNext": "",
  "VkPhysicalDeviceMultiviewFeaturesKHX.sType": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX": "Structure describing multiview limits that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.perViewPositionAllComponents": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext": "",
  "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX": "Structure describing multiview limits that can be supported by an implementation.",
  "VkPhysicalDeviceMultiviewPropertiesKHX.maxMultiviewInstanceIndex": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.maxMultiviewViewCount": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.pNext": "",
  "VkPhysicalDeviceMultiviewPropertiesKHX.sType": "",
  "VkPhysicalDeviceProperties": "Structure specifying physical device properties.",
  "VkPhysicalDeviceProperties.apiVersion": "pname:apiVersion is the version of Vulkan supported by the device, encoded as described in the <<fundamentals-versionnum,API Version Numbers and Semantics>> section.",
  "VkPhysicalDeviceProperties.deviceID": "pname:deviceID is a unique identifier for the physical device among devices available from the vendor.",
  "VkPhysicalDeviceProperties.deviceName": "pname:deviceName is a null-terminated UTF-8 string containing the name of the device.",
  "VkPhysicalDeviceProperties.deviceType": "pname:deviceType is a elink:VkPhysicalDeviceType specifying the type of device.",
  "VkPhysicalDeviceProperties.driverVersion": "pname:driverVersion is the vendor-specified version of the driver.",
  "VkPhysicalDeviceProperties.limits": "pname:limits is the slink:VkPhysicalDeviceLimits structure which specifies device-specific limits of the physical device. See <<features-limits,Limits>> for details.",
  "VkPhysicalDeviceProperties.pipelineCacheUUID": "pname:pipelineCacheUUID is an array of size ename:VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the device.",
  "VkPhysicalDeviceProperties.sparseProperties": "pname:sparseProperties is the slink:VkPhysicalDeviceSparseProperties structure which specifies various sparse related properties of the physical device. See <<sparsememory-physicalprops,Sparse Properties>> for details.",
  "VkPhysicalDeviceProperties.vendorID": "pname:vendorID is a unique identifier for the _vendor_ (see below) of the physical device.",
  "VkPhysicalDeviceProperties2KHR": "Structure specifying physical device properties.",
  "VkPhysicalDeviceProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceProperties2KHR.properties": "pname:properties is a structure of type slink:VkPhysicalDeviceProperties describing the properties of the physical device. This structure is written with the same values as if it were written by flink:vkGetPhysicalDeviceProperties.",
  "VkPhysicalDeviceProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDevicePushDescriptorPropertiesKHR": "Structure describing push descriptor limits that can be supported by an implementation.",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.maxPushDescriptors": "",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.pNext": "",
  "VkPhysicalDevicePushDescriptorPropertiesKHR.sType": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.filterMinmaxImageComponentMapping": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.filterMinmaxSingleComponentFormats": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext": "",
  "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType": "",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR": "Structure specifying sparse image format inputs.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.format": "pname:format is the image format.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.samples": "pname:samples is the number of samples per pixel as defined in elink:VkSampleCountFlagBits.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.sType": "pname:sType is the type of this structure.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling": "pname:tiling is the tiling arrangement of the data elements in memory.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.type": "pname:type is the dimensionality of image.",
  "VkPhysicalDeviceSparseImageFormatInfo2KHR.usage": "pname:usage is a bitmask describing the intended usage of the image.",
  "VkPhysicalDeviceSparseProperties": "Structure specifying physical device sparse memory properties.",
  "VkPhysicalDeviceSparseProperties.residencyAlignedMipSize": "pname:residencyAlignedMipSize is ename:VK_TRUE if images with mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block may: be placed in the mip tail. If this property is not reported, only mip levels with dimensions smaller than the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure will be placed in the mip tail. If this property is reported the implementation is allowed to return ename:VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT in the pname:flags member of sname:VkSparseImageFormatProperties, indicating that mip level dimensions that are not integer multiples of the corresponding dimensions of the sparse image block will be placed in the mip tail.",
  "VkPhysicalDeviceSparseProperties.residencyNonResidentStrict": "pname:residencyNonResidentStrict specifies whether the physical device can: consistently access non-resident regions of a resource. If this property is ename:VK_TRUE, access to non-resident regions of resources will be guaranteed to return values as if the resource were populated with 0; writes to non-resident regions will be discarded.",
  "VkPhysicalDeviceSparseProperties.residencyStandard2DBlockShape": "pname:residencyStandard2DBlockShape is ename:VK_TRUE if the physical device will access all single-sample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the <<sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)>> table. If this property is not supported the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for single-sample 2D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSparseProperties.residencyStandard2DMultisampleBlockShape": "pname:residencyStandard2DMultisampleBlockShape is ename:VK_TRUE if the physical device will access all multisample 2D sparse resources using the standard sparse image block shapes (based on image format), as described in the <<sparsememory-sparseblockshapesmsaa,Standard Sparse Image Block Shapes (MSAA)>> table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for multisample 2D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSparseProperties.residencyStandard3DBlockShape": "pname:residencyStandard3DBlockShape is ename:VK_TRUE if the physical device will access all 3D sparse resources using the standard sparse image block shapes (based on image format), as described in the <<sparsememory-sparseblockshapessingle,Standard Sparse Image Block Shapes (Single Sample)>> table. If this property is not supported, the value returned in the pname:imageGranularity member of the sname:VkSparseImageFormatProperties structure for 3D images is not required: to match the standard sparse image block dimensions listed in the table.",
  "VkPhysicalDeviceSurfaceInfo2KHR": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.pNext": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.sType": "",
  "VkPhysicalDeviceSurfaceInfo2KHR.surface": "",
  "VkPhysicalDeviceType": "Supported physical device types.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_CPU": "ename:VK_PHYSICAL_DEVICE_TYPE_CPU The device is typically running on the same processors as the host.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU": "ename:VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU The device is typically a separate processor connected to the host via an interlink.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU": "ename:VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU The device is typically one embedded in or tightly coupled with the host.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_OTHER": "ename:VK_PHYSICAL_DEVICE_TYPE_OTHER The device does not match any other available types.",
  "VkPhysicalDeviceType.VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU": "ename:VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU The device is typically a virtual node in a virtualization environment.",
  "VkPhysicalDeviceVariablePointerFeaturesKHR": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.pNext": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.sType": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointers": "",
  "VkPhysicalDeviceVariablePointerFeaturesKHR.variablePointersStorageBuffer": "",
  "VkPipeline": "Opaque handle to a pipeline object.",
  "VkPipelineBindPoint": "Specify the bind point of a pipeline object to a command buffer.",
  "VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_COMPUTE": "",
  "VkPipelineBindPoint.VK_PIPELINE_BIND_POINT_GRAPHICS": "",
  "VkPipelineCache": "Opaque handle to a pipeline cache object.",
  "VkPipelineCacheCreateFlagBits": "",
  "VkPipelineCacheCreateFlags": "",
  "VkPipelineCacheCreateFlags.__none": "",
  "VkPipelineCacheCreateInfo": "Structure specifying parameters of a newly created pipeline cache.",
  "VkPipelineCacheCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineCacheCreateInfo.initialDataSize": "pname:initialDataSize is the number of bytes in pname:pInitialData. If pname:initialDataSize is zero, the pipeline cache will initially be empty.",
  "VkPipelineCacheCreateInfo.pInitialData": "pname:pInitialData is a pointer to previously retrieved pipeline cache data. If the pipeline cache data is incompatible (as defined below) with the device, the pipeline cache will be initially empty. If pname:initialDataSize is zero, pname:pInitialData is ignored.",
  "VkPipelineCacheCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineCacheCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineCacheHeaderVersion": "Encode pipeline cache version.",
  "VkPipelineCacheHeaderVersion.VK_PIPELINE_CACHE_HEADER_VERSION_ONE": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.dstPremultiplied": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.srcPremultiplied": "",
  "VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType": "",
  "VkPipelineColorBlendAttachmentState": "Structure specifying a pipeline color blend attachment state.",
  "VkPipelineColorBlendAttachmentState.alphaBlendOp": "pname:alphaBlendOp selects which blend operation is use to calculate the alpha values to write to the color attachment.",
  "VkPipelineColorBlendAttachmentState.blendEnable": "pname:blendEnable controls whether blending is enabled for the corresponding color attachment. If blending is not enabled, the source fragment's color for that attachment is passed through unmodified.",
  "VkPipelineColorBlendAttachmentState.colorBlendOp": "pname:colorBlendOp selects which blend operation is used to calculate the RGB values to write to the color attachment.",
  "VkPipelineColorBlendAttachmentState.colorWriteMask": "pname:colorWriteMask is a bitmask selecting which of the R, G, B, and/or A components are enabled for writing, as described later in this chapter.",
  "VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor": "pname:dstAlphaBlendFactor selects which blend factor is used to determine the destination factor [eq]#D~a~#.",
  "VkPipelineColorBlendAttachmentState.dstColorBlendFactor": "pname:dstColorBlendFactor selects which blend factor is used to determine the destination factors [eq]#(D~r~,D~g~,D~b~)#.",
  "VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor": "pname:srcAlphaBlendFactor selects which blend factor is used to determine the source factor [eq]#S~a~#.",
  "VkPipelineColorBlendAttachmentState.srcColorBlendFactor": "pname:srcColorBlendFactor selects which blend factor is used to determine the source factors [eq]#(S~r~,S~g~,S~b~)#.",
  "VkPipelineColorBlendStateCreateFlagBits": "",
  "VkPipelineColorBlendStateCreateFlags": "",
  "VkPipelineColorBlendStateCreateFlags.__none": "",
  "VkPipelineColorBlendStateCreateInfo": "Structure specifying parameters of a newly created pipeline color blend state.",
  "VkPipelineColorBlendStateCreateInfo.attachmentCount": "pname:attachmentCount is the number of sname:VkPipelineColorBlendAttachmentState elements in pname:pAttachments. This value must: equal the pname:colorAttachmentCount for the subpass in which this pipeline is used.",
  "VkPipelineColorBlendStateCreateInfo.blendConstants": "pname:blendConstants is an array of four values used as the R, G, B, and A components of the blend constant that are used in blending, depending on the <<framebuffer-blendfactors,blend factor>>.",
  "VkPipelineColorBlendStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineColorBlendStateCreateInfo.logicOp": "pname:logicOp selects which logical operation to apply.",
  "VkPipelineColorBlendStateCreateInfo.logicOpEnable": "pname:logicOpEnable controls whether to apply <<framebuffer-logicop, Logical Operations>>.",
  "VkPipelineColorBlendStateCreateInfo.pAttachments": "pname:pAttachments: is a pointer to array of per target attachment states.",
  "VkPipelineColorBlendStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineColorBlendStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineCoverageModulationStateCreateFlagsNV": "",
  "VkPipelineCoverageModulationStateCreateFlagsNV.__none": "",
  "VkPipelineCoverageModulationStateCreateInfoNV": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableEnable": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.flags": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.pNext": "",
  "VkPipelineCoverageModulationStateCreateInfoNV.sType": "",
  "VkPipelineCoverageToColorStateCreateFlagsNV": "",
  "VkPipelineCoverageToColorStateCreateFlagsNV.__none": "",
  "VkPipelineCoverageToColorStateCreateInfoNV": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorEnable": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.flags": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.pNext": "",
  "VkPipelineCoverageToColorStateCreateInfoNV.sType": "",
  "VkPipelineCreateFlagBits": "Bitmask controlling how a pipeline is generated.",
  "VkPipelineCreateFlags": "",
  "VkPipelineCreateFlags.__none": "",
  "VkPipelineCreateFlags.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT": "",
  "VkPipelineCreateFlags.VK_PIPELINE_CREATE_DERIVATIVE_BIT": "",
  "VkPipelineCreateFlags.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT": "",
  "VkPipelineCreateFlags.VK_PIPELINE_CREATE_DISPATCH_BASE_KHX": "",
  "VkPipelineCreateFlags.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX": "",
  "VkPipelineDepthStencilStateCreateFlagBits": "",
  "VkPipelineDepthStencilStateCreateFlags": "",
  "VkPipelineDepthStencilStateCreateFlags.__none": "",
  "VkPipelineDepthStencilStateCreateInfo": "Structure specifying parameters of a newly created pipeline depth stencil state.",
  "VkPipelineDepthStencilStateCreateInfo.back": "",
  "VkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable": "pname:depthBoundsTestEnable controls whether <<fragops-dbt,depth bounds testing>> is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.depthCompareOp": "pname:depthCompareOp is the comparison operator used in the <<fragops-depth,depth test>>.",
  "VkPipelineDepthStencilStateCreateInfo.depthTestEnable": "pname:depthTestEnable controls whether <<fragops-depth,depth testing>> is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.depthWriteEnable": "pname:depthWriteEnable controls whether <<fragops-depth-write,depth writes>> are enabled.",
  "VkPipelineDepthStencilStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineDepthStencilStateCreateInfo.front": "pname:front and pname:back control the parameters of the <<fragops-stencil,stencil test>>.",
  "VkPipelineDepthStencilStateCreateInfo.maxDepthBounds": "",
  "VkPipelineDepthStencilStateCreateInfo.minDepthBounds": "pname:minDepthBounds and pname:maxDepthBounds define the range of values used in the <<fragops-dbt,depth bounds test>>.",
  "VkPipelineDepthStencilStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineDepthStencilStateCreateInfo.stencilTestEnable": "pname:stencilTestEnable controls whether <<fragops-stencil,stencil testing>> is enabled.",
  "VkPipelineDepthStencilStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineDiscardRectangleStateCreateFlagsEXT": "",
  "VkPipelineDiscardRectangleStateCreateFlagsEXT.__none": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.flags": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.pNext": "",
  "VkPipelineDiscardRectangleStateCreateInfoEXT.sType": "",
  "VkPipelineDynamicStateCreateFlagBits": "",
  "VkPipelineDynamicStateCreateFlags": "",
  "VkPipelineDynamicStateCreateFlags.__none": "",
  "VkPipelineDynamicStateCreateInfo": "Structure specifying parameters of a newly created pipeline dynamic state.",
  "VkPipelineDynamicStateCreateInfo.dynamicStateCount": "pname:dynamicStateCount is the number of elements in the pname:pDynamicStates array.",
  "VkPipelineDynamicStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineDynamicStateCreateInfo.pDynamicStates": "pname:pDynamicStates is an array of elink:VkDynamicState enums which indicate which pieces of pipeline state will use the values from dynamic state commands rather than from the pipeline state creation info.",
  "VkPipelineDynamicStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineDynamicStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineInputAssemblyStateCreateFlagBits": "",
  "VkPipelineInputAssemblyStateCreateFlags": "",
  "VkPipelineInputAssemblyStateCreateFlags.__none": "",
  "VkPipelineInputAssemblyStateCreateInfo": "Structure specifying parameters of a newly created pipeline input assembly state.",
  "VkPipelineInputAssemblyStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineInputAssemblyStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable": "pname:primitiveRestartEnable controls whether a special vertex index value is treated as restarting the assembly of primitives. This enable only applies to indexed draws (flink:vkCmdDrawIndexed and flink:vkCmdDrawIndexedIndirect), and the special index value is either 0xFFFFFFFF when the pname:indexType parameter of fname:vkCmdBindIndexBuffer is equal to ename:VK_INDEX_TYPE_UINT32, or 0xFFFF when pname:indexType is equal to ename:VK_INDEX_TYPE_UINT16. Primitive restart is not allowed for \"`list`\" topologies.",
  "VkPipelineInputAssemblyStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineInputAssemblyStateCreateInfo.topology": "pname:topology is a elink:VkPrimitiveTopology defining the primitive topology, as described below.",
  "VkPipelineLayout": "Opaque handle to a pipeline layout object.",
  "VkPipelineLayoutCreateFlagBits": "",
  "VkPipelineLayoutCreateFlags": "",
  "VkPipelineLayoutCreateFlags.__none": "",
  "VkPipelineLayoutCreateInfo": "Structure specifying the parameters of a newly created pipeline layout object.",
  "VkPipelineLayoutCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineLayoutCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineLayoutCreateInfo.pPushConstantRanges": "pname:pPushConstantRanges is a pointer to an array of sname:VkPushConstantRange structures defining a set of push constant ranges for use in a single pipeline layout. In addition to descriptor set layouts, a pipeline layout also describes how many push constants can: be accessed by each stage of the pipeline. + [NOTE] .Note ==== Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates. ====",
  "VkPipelineLayoutCreateInfo.pSetLayouts": "pname:pSetLayouts is a pointer to an array of sname:VkDescriptorSetLayout objects.",
  "VkPipelineLayoutCreateInfo.pushConstantRangeCount": "pname:pushConstantRangeCount is the number of push constant ranges included in the pipeline layout.",
  "VkPipelineLayoutCreateInfo.setLayoutCount": "pname:setLayoutCount is the number of descriptor sets included in the pipeline layout.",
  "VkPipelineLayoutCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineMultisampleStateCreateFlagBits": "",
  "VkPipelineMultisampleStateCreateFlags": "",
  "VkPipelineMultisampleStateCreateFlags.__none": "",
  "VkPipelineMultisampleStateCreateInfo": "Structure specifying parameters of a newly created pipeline multisample state.",
  "VkPipelineMultisampleStateCreateInfo.alphaToCoverageEnable": "pname:alphaToCoverageEnable controls whether a temporary coverage value is generated based on the alpha component of the fragment's first color output as specified in the <<fragops-covg,Multisample Coverage>> section.",
  "VkPipelineMultisampleStateCreateInfo.alphaToOneEnable": "pname:alphaToOneEnable controls whether the alpha component of the fragment's first color output is replaced with one as described in <<fragops-covg,Multisample Coverage>>.",
  "VkPipelineMultisampleStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineMultisampleStateCreateInfo.minSampleShading": "pname:minSampleShading is the minimum fraction of sample shading, as described in <<primsrast-sampleshading,Sample Shading>>.",
  "VkPipelineMultisampleStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineMultisampleStateCreateInfo.pSampleMask": "pname:pSampleMask is a bitmask of static coverage information that is ANDed with the coverage information generated during rasterization, as described in <<fragops-samplemask,Sample Mask>>.",
  "VkPipelineMultisampleStateCreateInfo.rasterizationSamples": "pname:rasterizationSamples is a elink:VkSampleCountFlagBits specifying the number of samples per pixel used in rasterization.",
  "VkPipelineMultisampleStateCreateInfo.sampleShadingEnable": "pname:sampleShadingEnable specifies that fragment shading executes per-sample if ename:VK_TRUE, or per-fragment if ename:VK_FALSE, as described in <<primsrast-sampleshading,Sample Shading>>.",
  "VkPipelineMultisampleStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineRasterizationStateCreateFlagBits": "",
  "VkPipelineRasterizationStateCreateFlags": "",
  "VkPipelineRasterizationStateCreateFlags.__none": "",
  "VkPipelineRasterizationStateCreateInfo": "Structure specifying parameters of a newly created pipeline rasterization state.",
  "VkPipelineRasterizationStateCreateInfo.cullMode": "pname:cullMode is the triangle facing direction used for primitive culling. See elink:VkCullModeFlagBits.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasClamp": "pname:depthBiasClamp is the maximum (or minimum) depth bias of a fragment.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor": "pname:depthBiasConstantFactor is a scalar factor controlling the constant depth value added to each fragment.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasEnable": "pname:depthBiasEnable controls whether to bias fragment depth values.",
  "VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor": "pname:depthBiasSlopeFactor is a scalar factor applied to a fragment's slope in depth bias calculations.",
  "VkPipelineRasterizationStateCreateInfo.depthClampEnable": "pname:depthClampEnable controls whether to clamp the fragment's depth values instead of clipping primitives to the z planes of the frustum, as described in <<vertexpostproc-clipping,Primitive Clipping>>.",
  "VkPipelineRasterizationStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineRasterizationStateCreateInfo.frontFace": "pname:frontFace is the front-facing triangle orientation to be used for culling. See elink:VkFrontFace.",
  "VkPipelineRasterizationStateCreateInfo.lineWidth": "pname:lineWidth is the width of rasterized line segments.",
  "VkPipelineRasterizationStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineRasterizationStateCreateInfo.polygonMode": "pname:polygonMode is the triangle rendering mode. See elink:VkPolygonMode.",
  "VkPipelineRasterizationStateCreateInfo.rasterizerDiscardEnable": "pname:rasterizerDiscardEnable controls whether primitives are discarded immediately before the rasterization stage.",
  "VkPipelineRasterizationStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineRasterizationStateRasterizationOrderAMD": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.pNext": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder": "",
  "VkPipelineRasterizationStateRasterizationOrderAMD.sType": "",
  "VkPipelineShaderStageCreateFlagBits": "",
  "VkPipelineShaderStageCreateFlags": "",
  "VkPipelineShaderStageCreateFlags.__none": "",
  "VkPipelineShaderStageCreateInfo": "Structure specifying parameters of a newly created pipeline shader stage.",
  "VkPipelineShaderStageCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineShaderStageCreateInfo.module": "",
  "VkPipelineShaderStageCreateInfo.pName": "",
  "VkPipelineShaderStageCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineShaderStageCreateInfo.pSpecializationInfo": "",
  "VkPipelineShaderStageCreateInfo.stage": "pname:stage names a single pipeline stage. Bits which can: be set include: + --",
  "VkPipelineShaderStageCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineStageFlagBits": "Bitmask specifying pipeline stages.",
  "VkPipelineStageFlags": "",
  "VkPipelineStageFlags.__none": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_ALL_COMMANDS_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_HOST_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_TRANSFER_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_VERTEX_INPUT_BIT": "",
  "VkPipelineStageFlags.VK_PIPELINE_STAGE_VERTEX_SHADER_BIT": "",
  "VkPipelineTessellationStateCreateFlagBits": "",
  "VkPipelineTessellationStateCreateFlags": "",
  "VkPipelineTessellationStateCreateFlags.__none": "",
  "VkPipelineTessellationStateCreateInfo": "Structure specifying parameters of a newly created pipeline tessellation state.",
  "VkPipelineTessellationStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineTessellationStateCreateInfo.patchControlPoints": "pname:patchControlPoints number of control points per patch.",
  "VkPipelineTessellationStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineTessellationStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineVertexInputStateCreateFlagBits": "",
  "VkPipelineVertexInputStateCreateFlags": "",
  "VkPipelineVertexInputStateCreateFlags.__none": "",
  "VkPipelineVertexInputStateCreateInfo": "Structure specifying parameters of a newly created pipeline vertex input state.",
  "VkPipelineVertexInputStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineVertexInputStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions": "pname:pVertexAttributeDescriptions is a pointer to an array of sname:VkVertexInputAttributeDescription structures.",
  "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions": "pname:pVertexBindingDescriptions is a pointer to an array of sname:VkVertexInputBindingDescription structures.",
  "VkPipelineVertexInputStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount": "pname:vertexAttributeDescriptionCount is the number of vertex attribute descriptions provided in pname:pVertexAttributeDescriptions.",
  "VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount": "pname:vertexBindingDescriptionCount is the number of vertex binding descriptions provided in pname:pVertexBindingDescriptions.",
  "VkPipelineViewportStateCreateFlagBits": "",
  "VkPipelineViewportStateCreateFlags": "",
  "VkPipelineViewportStateCreateFlags.__none": "",
  "VkPipelineViewportStateCreateInfo": "Structure specifying parameters of a newly created pipeline viewport state.",
  "VkPipelineViewportStateCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkPipelineViewportStateCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPipelineViewportStateCreateInfo.pScissors": "pname:pScissors is a pointer to an array of sname:VkRect2D structures which define the rectangular bounds of the scissor for the corresponding viewport. If the scissor state is dynamic, this member is ignored.",
  "VkPipelineViewportStateCreateInfo.pViewports": "pname:pViewports is a pointer to an array of slink:VkViewport structures, defining the viewport transforms. If the viewport state is dynamic, this member is ignored.",
  "VkPipelineViewportStateCreateInfo.scissorCount": "pname:scissorCount is the number of <<fragops-scissor,scissors>> and must: match the number of viewports.",
  "VkPipelineViewportStateCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkPipelineViewportStateCreateInfo.viewportCount": "pname:viewportCount is the number of viewports used by the pipeline.",
  "VkPipelineViewportSwizzleStateCreateFlagsNV": "",
  "VkPipelineViewportSwizzleStateCreateFlagsNV.__none": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.flags": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.pNext": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.sType": "",
  "VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount": "",
  "VkPipelineViewportWScalingStateCreateInfoNV": "Structure specifying parameters of a newly created pipeline viewport W scaling state.",
  "VkPipelineViewportWScalingStateCreateInfoNV.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure",
  "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings": "pname:pViewportWScalings is a pointer to an array of sname:VkViewportWScalingNV structures which define the W scaling parameters for the corresponding viewport. If the viewport W scaling state is dynamic, this member is ignored.",
  "VkPipelineViewportWScalingStateCreateInfoNV.sType": "pname:sType is the type of this structure",
  "VkPipelineViewportWScalingStateCreateInfoNV.viewportCount": "pname:viewportCount is the number of viewports used by W scaling and must: match the number of viewports in the pipeline if viewport W scaling is enabled.",
  "VkPipelineViewportWScalingStateCreateInfoNV.viewportWScalingEnable": "pname:viewportWScalingEnable is the enable for viewport W scaling",
  "VkPolygonMode": "Control polygon rasterization mode.",
  "VkPolygonMode.VK_POLYGON_MODE_FILL": "",
  "VkPolygonMode.VK_POLYGON_MODE_FILL_RECTANGLE_NV": "",
  "VkPolygonMode.VK_POLYGON_MODE_LINE": "",
  "VkPolygonMode.VK_POLYGON_MODE_POINT": "",
  "VkPresentInfoKHR": "Structure describing parameters of a queue presentation.",
  "VkPresentInfoKHR.pImageIndices": "pname:pImageIndices is an array of indices into the array of each swapchain's presentable images, with pname:swapchainCount entries. Each entry in this array identifies the image to present on the corresponding entry in the pname:pSwapchains array.",
  "VkPresentInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkPresentInfoKHR.pResults": "pname:pResults is an array of ename:VkResult typed elements with pname:swapchainCount entries. Applications that do not need per-swapchain results can: use `NULL` for pname:pResults. If non-`NULL`, each entry in pname:pResults will be set to the ename:VkResult for presenting the swapchain corresponding to the same index in pname:pSwapchains.",
  "VkPresentInfoKHR.pSwapchains": "pname:pSwapchains is an array of sname:VkSwapchainKHR objects with pname:swapchainCount entries. A given swapchain must: not appear in this list more than once.",
  "VkPresentInfoKHR.pWaitSemaphores": "pname:pWaitSemaphores, if not `NULL`, is an array of sname:VkSemaphore objects with pname:waitSemaphoreCount entries, and specifies the semaphores to wait for before issuing the present request.",
  "VkPresentInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkPresentInfoKHR.swapchainCount": "pname:swapchainCount is the number of swapchains being presented to by this command.",
  "VkPresentInfoKHR.waitSemaphoreCount": "pname:waitSemaphoreCount is the number of semaphores to wait for before issuing the present request. The number may: be zero.",
  "VkPresentModeKHR": "Presentation mode supported for a surface.",
  "VkPresentModeKHR.VK_PRESENT_MODE_FIFO_KHR": "ename:VK_PRESENT_MODE_FIFO_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during each vertical blanking period in which the queue is non-empty. This is the only value of pname:presentMode that is required: to be supported.",
  "VkPresentModeKHR.VK_PRESENT_MODE_FIFO_RELAXED_KHR": "ename:VK_PRESENT_MODE_FIFO_RELAXED_KHR: The presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode may: result in visible tearing in this case. This mode is useful for reducing visual stutter with an application that will mostly present a new image before the next vertical blanking period, but may occasionally be late, and present a new image just after the next vertical blanking period. An internal queue is used to hold pending presentation requests. New requests are appended to the end of the queue, and one request is removed from the beginning of the queue and processed during or after each vertical blanking period in which the queue is non-empty.",
  "VkPresentModeKHR.VK_PRESENT_MODE_IMMEDIATE_KHR": "ename:VK_PRESENT_MODE_IMMEDIATE_KHR: The presentation engine does not wait for a vertical blanking period to update the current image, meaning this mode may: result in visible tearing. No internal queuing of presentation requests is needed, as the requests are applied immediately.",
  "VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR": "ename:VK_PRESENT_MODE_MAILBOX_KHR: The presentation engine waits for the next vertical blanking period to update the current image. Tearing cannot: be observed. An internal single-entry queue is used to hold pending presentation requests. If the queue is full when a new presentation request is received, the new request replaces the existing entry, and any images associated with the prior entry become available for re-use by the application. One request is removed from the queue and processed during each vertical blanking period in which the queue is non-empty.",
  "VkPresentModeKHR.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR": "",
  "VkPresentModeKHR.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR": "",
  "VkPresentRegionKHR": "",
  "VkPresentRegionKHR.pRectangles": "",
  "VkPresentRegionKHR.rectangleCount": "",
  "VkPresentRegionsKHR": "",
  "VkPresentRegionsKHR.pNext": "",
  "VkPresentRegionsKHR.pRegions": "",
  "VkPresentRegionsKHR.sType": "",
  "VkPresentRegionsKHR.swapchainCount": "",
  "VkPresentTimeGOOGLE": "",
  "VkPresentTimeGOOGLE.desiredPresentTime": "",
  "VkPresentTimeGOOGLE.presentID": "",
  "VkPresentTimesInfoGOOGLE": "",
  "VkPresentTimesInfoGOOGLE.pNext": "",
  "VkPresentTimesInfoGOOGLE.pTimes": "",
  "VkPresentTimesInfoGOOGLE.sType": "",
  "VkPresentTimesInfoGOOGLE.swapchainCount": "",
  "VkPrimitiveTopology": "Supported primitive topologies.",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_PATCH_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_POINT_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP": "",
  "VkPrimitiveTopology.VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY": "",
  "VkPushConstantRange": "Structure specifying a push constant range.",
  "VkPushConstantRange.offset": "pname:offset and pname:size are the start offset and size, respectively, consumed by the range. Both pname:offset and pname:size are in units of bytes and must: be a multiple of 4. The layout of the push constant variables is specified in the shader.",
  "VkPushConstantRange.size": "",
  "VkPushConstantRange.stageFlags": "pname:stageFlags is a set of stage flags describing the shader stages that will access a range of push constants. If a particular stage is not included in the range, then accessing members of that range of push constants from the corresponding shader stage will result in undefined data being read.",
  "VkQueryControlFlagBits": "Bitmask specifying constraints on a query.",
  "VkQueryControlFlags": "",
  "VkQueryControlFlags.__none": "",
  "VkQueryControlFlags.VK_QUERY_CONTROL_PRECISE_BIT": "",
  "VkQueryPipelineStatisticFlagBits": "Bitmask specifying queried pipeline statistics.",
  "VkQueryPipelineStatisticFlags": "",
  "VkQueryPipelineStatisticFlags.__none": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPipelineStatisticFlags.VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT": "",
  "VkQueryPool": "Opaque handle to a query pool object.",
  "VkQueryPoolCreateFlagBits": "",
  "VkQueryPoolCreateFlags": "",
  "VkQueryPoolCreateFlags.__none": "",
  "VkQueryPoolCreateInfo": "Structure specifying parameters of a newly created query pool.",
  "VkQueryPoolCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkQueryPoolCreateInfo.pipelineStatistics": "",
  "VkQueryPoolCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkQueryPoolCreateInfo.queryCount": "",
  "VkQueryPoolCreateInfo.queryType": "pname:queryType is the type of queries managed by the pool, and must: be one of the values + --",
  "VkQueryPoolCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkQueryResultFlagBits": "Bitmask specifying how and when query results are returned.",
  "VkQueryResultFlags": "",
  "VkQueryResultFlags.__none": "",
  "VkQueryResultFlags.VK_QUERY_RESULT_64_BIT": "",
  "VkQueryResultFlags.VK_QUERY_RESULT_PARTIAL_BIT": "",
  "VkQueryResultFlags.VK_QUERY_RESULT_WAIT_BIT": "",
  "VkQueryResultFlags.VK_QUERY_RESULT_WITH_AVAILABILITY_BIT": "",
  "VkQueryType": "Specify the type of queries managed by a query pool.",
  "VkQueryType.VK_QUERY_TYPE_OCCLUSION": "",
  "VkQueryType.VK_QUERY_TYPE_PIPELINE_STATISTICS": "",
  "VkQueryType.VK_QUERY_TYPE_TIMESTAMP": "",
  "VkQueue": "Opaque handle to a queue object.",
  "vkQueueBindSparse": "Bind device memory to a sparse resource object.",
  "vkQueueBindSparse.bindInfoCount": "",
  "vkQueueBindSparse.fence": "",
  "vkQueueBindSparse.pBindInfo": "",
  "vkQueueBindSparse.queue": "",
  "VkQueueFamilyProperties": "Structure providing information about a queue family.",
  "VkQueueFamilyProperties.minImageTransferGranularity": "pname:minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family.",
  "VkQueueFamilyProperties.queueCount": "pname:queueCount is the unsigned integer count of queues in this queue family.",
  "VkQueueFamilyProperties.queueFlags": "pname:queueFlags contains flags indicating the capabilities of the queues in this queue family.",
  "VkQueueFamilyProperties.timestampValidBits": "pname:timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via fname:vkCmdWriteTimestamp. The valid range for the count is 36..64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros.",
  "VkQueueFamilyProperties2KHR": "Structure providing information about a queue family.",
  "VkQueueFamilyProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkQueueFamilyProperties2KHR.queueFamilyProperties": "pname:queueFamilyProperties is a structure of type slink:VkQueueFamilyProperties which is populated with the same values as in flink:vkGetPhysicalDeviceQueueFamilyProperties.",
  "VkQueueFamilyProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkQueueFlagBits": "Bitmask specifying capabilities of queues in a queue family.",
  "VkQueueFlags": "",
  "VkQueueFlags.__none": "",
  "VkQueueFlags.VK_QUEUE_COMPUTE_BIT": "",
  "VkQueueFlags.VK_QUEUE_GRAPHICS_BIT": "",
  "VkQueueFlags.VK_QUEUE_SPARSE_BINDING_BIT": "",
  "VkQueueFlags.VK_QUEUE_TRANSFER_BIT": "",
  "vkQueuePresentKHR": "Queue an image for presentation.",
  "vkQueuePresentKHR.pPresentInfo": "",
  "vkQueuePresentKHR.queue": "",
  "vkQueueSubmit": "Submits a sequence of semaphores or command buffers to a queue.",
  "vkQueueSubmit.fence": "",
  "vkQueueSubmit.pSubmits": "",
  "vkQueueSubmit.queue": "",
  "vkQueueSubmit.submitCount": "",
  "vkQueueWaitIdle": "Wait for a queue to become idle.",
  "vkQueueWaitIdle.queue": "",
  "VkRasterizationOrderAMD": "",
  "VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_RELAXED_AMD": "",
  "VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_STRICT_AMD": "",
  "VkRect2D": "Structure specifying a two-dimensional subregion.",
  "VkRect2D.extent": "",
  "VkRect2D.offset": "",
  "VkRect3D": "",
  "VkRect3D.extent": "",
  "VkRect3D.offset": "",
  "VkRectLayerKHR": "",
  "VkRectLayerKHR.extent": "",
  "VkRectLayerKHR.layer": "",
  "VkRectLayerKHR.offset": "",
  "VkRefreshCycleDurationGOOGLE": "",
  "VkRefreshCycleDurationGOOGLE.refreshDuration": "",
  "vkRegisterDeviceEventEXT": "Signal a fence when a device event occurs.",
  "vkRegisterDeviceEventEXT.device": "",
  "vkRegisterDeviceEventEXT.pAllocator": "",
  "vkRegisterDeviceEventEXT.pDeviceEventInfo": "",
  "vkRegisterDeviceEventEXT.pFence": "",
  "vkRegisterDisplayEventEXT": "Signal a fence when a display event occurs.",
  "vkRegisterDisplayEventEXT.device": "",
  "vkRegisterDisplayEventEXT.display": "",
  "vkRegisterDisplayEventEXT.pAllocator": "",
  "vkRegisterDisplayEventEXT.pDisplayEventInfo": "",
  "vkRegisterDisplayEventEXT.pFence": "",
  "vkRegisterObjectsNVX": "",
  "vkRegisterObjectsNVX.device": "",
  "vkRegisterObjectsNVX.objectCount": "",
  "vkRegisterObjectsNVX.objectTable": "",
  "vkRegisterObjectsNVX.pObjectIndices": "",
  "vkRegisterObjectsNVX.ppObjectTableEntries": "",
  "vkReleaseDisplayEXT": "Release access to an acquired VkDisplayKHR.",
  "vkReleaseDisplayEXT.display": "",
  "vkReleaseDisplayEXT.physicalDevice": "",
  "VkRenderPass": "Opaque handle to a render pass object.",
  "VkRenderPassBeginInfo": "Structure specifying render pass begin info.",
  "VkRenderPassBeginInfo.clearValueCount": "pname:clearValueCount is the number of elements in pname:pClearValues.",
  "VkRenderPassBeginInfo.framebuffer": "pname:framebuffer is the framebuffer containing the attachments that are used with the render pass.",
  "VkRenderPassBeginInfo.pClearValues": "pname:pClearValues is an array of slink:VkClearValue structures that contains clear values for each attachment, if the attachment uses a pname:loadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a pname:stencilLoadOp value of ename:VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pname:pClearValues are ignored.",
  "VkRenderPassBeginInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkRenderPassBeginInfo.renderArea": "pname:renderArea is the render area that is affected by the render pass instance, and is described in more detail below.",
  "VkRenderPassBeginInfo.renderPass": "pname:renderPass is the render pass to begin an instance of.",
  "VkRenderPassBeginInfo.sType": "pname:sType is the type of this structure.",
  "VkRenderPassCreateFlagBits": "",
  "VkRenderPassCreateFlags": "",
  "VkRenderPassCreateFlags.__none": "",
  "VkRenderPassCreateInfo": "Structure specifying parameters of a newly created render pass.",
  "VkRenderPassCreateInfo.attachmentCount": "pname:attachmentCount is the number of attachments used by this render pass, or zero indicating no attachments. Attachments are referred to by zero-based indices in the range [0,pname:attachmentCount).",
  "VkRenderPassCreateInfo.dependencyCount": "pname:dependencyCount is the number of dependencies between pairs of subpasses, or zero indicating no dependencies.",
  "VkRenderPassCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkRenderPassCreateInfo.pAttachments": "pname:pAttachments points to an array of pname:attachmentCount number of slink:VkAttachmentDescription structures describing properties of the attachments, or `NULL` if pname:attachmentCount is zero.",
  "VkRenderPassCreateInfo.pDependencies": "pname:pDependencies points to an array of pname:dependencyCount number of slink:VkSubpassDependency structures describing dependencies between pairs of subpasses, or `NULL` if pname:dependencyCount is zero.",
  "VkRenderPassCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkRenderPassCreateInfo.pSubpasses": "pname:pSubpasses points to an array of pname:subpassCount number of slink:VkSubpassDescription structures describing properties of the subpasses.",
  "VkRenderPassCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkRenderPassCreateInfo.subpassCount": "pname:subpassCount is the number of subpasses to create for this render pass. Subpasses are referred to by zero-based indices in the range [0,pname:subpassCount). A render pass must: have at least one subpass.",
  "VkRenderPassMultiviewCreateInfoKHX": "Structure containing multiview info for all subpasses.",
  "VkRenderPassMultiviewCreateInfoKHX.correlationMaskCount": "pname:correlationMaskCount is zero or a number of correlation masks.",
  "VkRenderPassMultiviewCreateInfoKHX.dependencyCount": "pname:dependencyCount is zero or the number of dependencies in the render pass.",
  "VkRenderPassMultiviewCreateInfoKHX.pCorrelationMasks": "pname:pCorrelationMasks is an array of view masks indicating sets of views that may: be more efficient to render concurrently.",
  "VkRenderPassMultiviewCreateInfoKHX.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkRenderPassMultiviewCreateInfoKHX.pViewMasks": "pname:pViewMasks points to an array of pname:subpassCount number of view masks, where each mask is a bitfield of view indices describing which views rendering is broadcast to in each subpass, when multiview is enabled. If pname:subpassCount is zero, each view mask is treated as zero.",
  "VkRenderPassMultiviewCreateInfoKHX.pViewOffsets": "pname:pViewOffsets points to an array of pname:dependencyCount view offsets, one for each dependency. If pname:dependencyCount is zero, each dependency's view offset is treated as zero. Each view offset controls which views in the source subpass the views in the destination subpass depend on.",
  "VkRenderPassMultiviewCreateInfoKHX.sType": "pname:sType is the type of this structure.",
  "VkRenderPassMultiviewCreateInfoKHX.subpassCount": "pname:subpassCount is zero or is the number of subpasses in the render pass.",
  "vkResetCommandBuffer": "Reset a command buffer.",
  "vkResetCommandBuffer.commandBuffer": "",
  "vkResetCommandBuffer.flags": "",
  "vkResetCommandPool": "Reset a command pool.",
  "vkResetCommandPool.commandPool": "",
  "vkResetCommandPool.device": "",
  "vkResetCommandPool.flags": "",
  "vkResetDescriptorPool": "Resets a descriptor pool object.",
  "vkResetDescriptorPool.descriptorPool": "",
  "vkResetDescriptorPool.device": "",
  "vkResetDescriptorPool.flags": "",
  "vkResetEvent": "Reset an event to non-signaled state.",
  "vkResetEvent.device": "",
  "vkResetEvent.event": "",
  "vkResetFences": "Resets one or more fence objects.",
  "vkResetFences.device": "",
  "vkResetFences.fenceCount": "",
  "vkResetFences.pFences": "",
  "VkResult": "Vulkan command return codes.",
  "VkResult.VK_ERROR_DEVICE_LOST": "",
  "VkResult.VK_ERROR_EXTENSION_NOT_PRESENT": "",
  "VkResult.VK_ERROR_FEATURE_NOT_PRESENT": "",
  "VkResult.VK_ERROR_FORMAT_NOT_SUPPORTED": "",
  "VkResult.VK_ERROR_FRAGMENTED_POOL": "",
  "VkResult.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR": "",
  "VkResult.VK_ERROR_INCOMPATIBLE_DRIVER": "",
  "VkResult.VK_ERROR_INITIALIZATION_FAILED": "",
  "VkResult.VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR": "",
  "VkResult.VK_ERROR_INVALID_SHADER_NV": "",
  "VkResult.VK_ERROR_LAYER_NOT_PRESENT": "",
  "VkResult.VK_ERROR_MEMORY_MAP_FAILED": "",
  "VkResult.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR": "",
  "VkResult.VK_ERROR_OUT_OF_DATE_KHR": "",
  "VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY": "",
  "VkResult.VK_ERROR_OUT_OF_HOST_MEMORY": "",
  "VkResult.VK_ERROR_OUT_OF_POOL_MEMORY_KHR": "",
  "VkResult.VK_ERROR_SURFACE_LOST_KHR": "",
  "VkResult.VK_ERROR_TOO_MANY_OBJECTS": "",
  "VkResult.VK_ERROR_VALIDATION_FAILED_EXT": "",
  "VkResult.VK_EVENT_RESET": "",
  "VkResult.VK_EVENT_SET": "",
  "VkResult.VK_INCOMPLETE": "",
  "VkResult.VK_NOT_READY": "",
  "VkResult.VK_NV_EXTENSION_1_ERROR": "",
  "VkResult.VK_SUBOPTIMAL_KHR": "",
  "VkResult.VK_SUCCESS": "",
  "VkResult.VK_TIMEOUT": "",
  "VkSampleCountFlagBits": "Bitmask specifying sample counts supported for an image used for storage operations.",
  "VkSampleCountFlags": "",
  "VkSampleCountFlags.__none": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_1_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_16_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_2_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_32_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_4_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_64_BIT": "",
  "VkSampleCountFlags.VK_SAMPLE_COUNT_8_BIT": "",
  "VkSampleMask": "Mask of sample coverage information.",
  "VkSampler": "Opaque handle to a sampler object.",
  "VkSamplerAddressMode": "Specify behavior of sampling with texture coordinates outside an image.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER": "ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER indicates that the clamp to border wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE": "ename:VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE indicates that the clamp to edge wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE": "ename:VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE indicates that the mirror clamp to edge wrap mode will be used. This is only valid if the +VK_KHR_mirror_clamp_to_edge+ extension is enabled.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT": "ename:VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT indicates that the mirrored repeat wrap mode will be used.",
  "VkSamplerAddressMode.VK_SAMPLER_ADDRESS_MODE_REPEAT": "ename:VK_SAMPLER_ADDRESS_MODE_REPEAT indicates that the repeat wrap mode will be used.",
  "VkSamplerCreateFlagBits": "",
  "VkSamplerCreateFlags": "",
  "VkSamplerCreateFlags.__none": "",
  "VkSamplerCreateInfo": "Structure specifying parameters of a newly created sampler.",
  "VkSamplerCreateInfo.addressModeU": "",
  "VkSamplerCreateInfo.addressModeV": "",
  "VkSamplerCreateInfo.addressModeW": "",
  "VkSamplerCreateInfo.anisotropyEnable": "",
  "VkSamplerCreateInfo.borderColor": "",
  "VkSamplerCreateInfo.compareEnable": "",
  "VkSamplerCreateInfo.compareOp": "",
  "VkSamplerCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkSamplerCreateInfo.magFilter": "pname:magFilter is the magnification filter to apply to lookups, and is of type: + --",
  "VkSamplerCreateInfo.maxAnisotropy": "",
  "VkSamplerCreateInfo.maxLod": "",
  "VkSamplerCreateInfo.minFilter": "",
  "VkSamplerCreateInfo.minLod": "",
  "VkSamplerCreateInfo.mipLodBias": "",
  "VkSamplerCreateInfo.mipmapMode": "",
  "VkSamplerCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSamplerCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkSamplerCreateInfo.unnormalizedCoordinates": "",
  "VkSamplerMipmapMode": "Specify mipmap mode used for texture lookups.",
  "VkSamplerMipmapMode.VK_SAMPLER_MIPMAP_MODE_LINEAR": "",
  "VkSamplerMipmapMode.VK_SAMPLER_MIPMAP_MODE_NEAREST": "",
  "VkSamplerReductionModeCreateInfoEXT": "",
  "VkSamplerReductionModeCreateInfoEXT.pNext": "",
  "VkSamplerReductionModeCreateInfoEXT.reductionMode": "",
  "VkSamplerReductionModeCreateInfoEXT.sType": "",
  "VkSamplerReductionModeEXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_MAX_EXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_MIN_EXT": "",
  "VkSamplerReductionModeEXT.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT": "",
  "VkSemaphore": "Opaque handle to a semaphore object.",
  "VkSemaphoreCreateFlags": "",
  "VkSemaphoreCreateFlags.__none": "",
  "VkSemaphoreCreateInfo": "Structure specifying parameters of a newly created semaphore.",
  "VkSemaphoreCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkSemaphoreCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSemaphoreCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkSemaphoreGetFdInfoKHR": "",
  "VkSemaphoreGetFdInfoKHR.handleType": "",
  "VkSemaphoreGetFdInfoKHR.pNext": "",
  "VkSemaphoreGetFdInfoKHR.semaphore": "",
  "VkSemaphoreGetFdInfoKHR.sType": "",
  "VkSemaphoreGetWin32HandleInfoKHR": "",
  "VkSemaphoreGetWin32HandleInfoKHR.handleType": "",
  "VkSemaphoreGetWin32HandleInfoKHR.pNext": "",
  "VkSemaphoreGetWin32HandleInfoKHR.semaphore": "",
  "VkSemaphoreGetWin32HandleInfoKHR.sType": "",
  "VkSemaphoreImportFlagBitsKHR": "",
  "VkSemaphoreImportFlagsKHR": "",
  "VkSemaphoreImportFlagsKHR.__none": "",
  "VkSemaphoreImportFlagsKHR.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR": "",
  "vkSetEvent": "Set an event to signaled state.",
  "vkSetEvent.device": "",
  "vkSetEvent.event": "",
  "vkSetHdrMetadataEXT": "",
  "vkSetHdrMetadataEXT.device": "",
  "vkSetHdrMetadataEXT.pMetadata": "",
  "vkSetHdrMetadataEXT.pSwapchains": "",
  "vkSetHdrMetadataEXT.swapchainCount": "",
  "VkShaderModule": "Opaque handle to a shader module object.",
  "VkShaderModuleCreateFlags": "",
  "VkShaderModuleCreateFlags.__none": "",
  "VkShaderModuleCreateInfo": "Structure specifying parameters of a newly created shader module.",
  "VkShaderModuleCreateInfo.codeSize": "pname:codeSize is the size, in bytes, of the code pointed to by pname:pCode.",
  "VkShaderModuleCreateInfo.flags": "pname:flags is reserved for future use.",
  "VkShaderModuleCreateInfo.pCode": "pname:pCode points to code that is used to create the shader module. The type and format of the code is determined from the content of the memory addressed by pname:pCode.",
  "VkShaderModuleCreateInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkShaderModuleCreateInfo.sType": "pname:sType is the type of this structure.",
  "VkShaderStageFlagBits": "Bitmask specifying a pipeline stage.",
  "VkShaderStageFlags": "",
  "VkShaderStageFlags.__none": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_ALL": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_ALL_GRAPHICS": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_COMPUTE_BIT": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_FRAGMENT_BIT": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_GEOMETRY_BIT": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT": "",
  "VkShaderStageFlags.VK_SHADER_STAGE_VERTEX_BIT": "",
  "VkSharedPresentSurfaceCapabilitiesKHR": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.pNext": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.sharedPresentSupportedUsageFlags": "",
  "VkSharedPresentSurfaceCapabilitiesKHR.sType": "",
  "VkSharingMode": "Buffer and image sharing modes.",
  "VkSharingMode.VK_SHARING_MODE_CONCURRENT": "ename:VK_SHARING_MODE_CONCURRENT specifies that concurrent access to any range or image subresource of the object from multiple queue families is supported.",
  "VkSharingMode.VK_SHARING_MODE_EXCLUSIVE": "ename:VK_SHARING_MODE_EXCLUSIVE specifies that access to any range or image subresource of the object will be exclusive to a single queue family at a time.",
  "VkSparseBufferMemoryBindInfo": "Structure specifying a sparse buffer memory bind operation.",
  "VkSparseBufferMemoryBindInfo.bindCount": "pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.",
  "VkSparseBufferMemoryBindInfo.buffer": "pname:buffer is the sname:VkBuffer object to be bound.",
  "VkSparseBufferMemoryBindInfo.pBinds": "pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.",
  "VkSparseImageFormatFlagBits": "Bitmask specifying additional information about a sparse image resource.",
  "VkSparseImageFormatFlags": "",
  "VkSparseImageFormatFlags.__none": "",
  "VkSparseImageFormatFlags.VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT": "",
  "VkSparseImageFormatFlags.VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT": "",
  "VkSparseImageFormatFlags.VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT": "",
  "VkSparseImageFormatProperties": "Structure specifying sparse image format properties.",
  "VkSparseImageFormatProperties.aspectMask": "pname:aspectMask is a bitmask of elink:VkImageAspectFlagBits specifying which aspects of the image the properties apply to.",
  "VkSparseImageFormatProperties.flags": "pname:flags is a bitmask specifying additional information about the sparse resource. Bits which can: be set include: + --",
  "VkSparseImageFormatProperties.imageGranularity": "pname:imageGranularity is the width, height, and depth of the sparse image block in texels or compressed texel blocks.",
  "VkSparseImageFormatProperties2KHR": "Structure specifying sparse image format properties.",
  "VkSparseImageFormatProperties2KHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSparseImageFormatProperties2KHR.properties": "pname:properties is a structure of type slink:VkSparseImageFormatProperties which is populated with the same values as in flink:vkGetPhysicalDeviceSparseImageFormatProperties.",
  "VkSparseImageFormatProperties2KHR.sType": "pname:sType is the type of this structure.",
  "VkSparseImageMemoryBind": "Structure specifying sparse image memory bind.",
  "VkSparseImageMemoryBind.extent": "pname:extent is the size in texels of the region within the image subresource to bind. The extent must: be a multiple of the sparse image block dimensions, except when binding sparse image blocks along the edge of an image subresource it can: instead be such that any coordinate of [eq]#pname:offset + pname:extent# equals the corresponding dimensions of the image subresource.",
  "VkSparseImageMemoryBind.flags": "pname:flags are sparse memory binding flags.",
  "VkSparseImageMemoryBind.memory": "pname:memory is the sname:VkDeviceMemory object that the sparse image blocks of the image are bound to. If pname:memory is dlink:VK_NULL_HANDLE, the sparse image blocks are unbound.",
  "VkSparseImageMemoryBind.memoryOffset": "pname:memoryOffset is an offset into sname:VkDeviceMemory object. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.",
  "VkSparseImageMemoryBind.offset": "pname:offset are the coordinates of the first texel within the image subresource to bind.",
  "VkSparseImageMemoryBind.subresource": "pname:subresource is the aspectMask and region of interest in the image.",
  "VkSparseImageMemoryBindInfo": "Structure specifying sparse image memory bind info.",
  "VkSparseImageMemoryBindInfo.bindCount": "pname:bindCount is the number of sname:VkSparseImageMemoryBind structures in pBinds array",
  "VkSparseImageMemoryBindInfo.image": "pname:image is the sname:VkImage object to be bound",
  "VkSparseImageMemoryBindInfo.pBinds": "pname:pBinds is a pointer to array of sname:VkSparseImageMemoryBind structures",
  "VkSparseImageMemoryRequirements": "Structure specifying sparse image memory requirements.",
  "VkSparseImageMemoryRequirements.formatProperties": "",
  "VkSparseImageMemoryRequirements.imageMipTailFirstLod": "pname:imageMipTailFirstLod is the first mip level at which image subresources are included in the mip tail region.",
  "VkSparseImageMemoryRequirements.imageMipTailOffset": "pname:imageMipTailOffset is the opaque memory offset used with slink:VkSparseImageOpaqueMemoryBindInfo to bind the mip tail region(s).",
  "VkSparseImageMemoryRequirements.imageMipTailSize": "pname:imageMipTailSize is the memory size (in bytes) of the mip tail region. If pname:formatProperties.flags contains ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT, this is the size of the whole mip tail, otherwise this is the size of the mip tail of a single array layer. This value is guaranteed to be a multiple of the sparse block size in bytes.",
  "VkSparseImageMemoryRequirements.imageMipTailStride": "pname:imageMipTailStride is the offset stride between each array-layer's mip tail, if pname:formatProperties.flags does not contain ename:VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT (otherwise the value is undefined).",
  "VkSparseImageMemoryRequirements2KHR": "",
  "VkSparseImageMemoryRequirements2KHR.memoryRequirements": "",
  "VkSparseImageMemoryRequirements2KHR.pNext": "",
  "VkSparseImageMemoryRequirements2KHR.sType": "",
  "VkSparseImageOpaqueMemoryBindInfo": "Structure specifying sparse image opaque memory bind info.",
  "VkSparseImageOpaqueMemoryBindInfo.bindCount": "pname:bindCount is the number of sname:VkSparseMemoryBind structures in the pname:pBinds array.",
  "VkSparseImageOpaqueMemoryBindInfo.image": "pname:image is the sname:VkImage object to be bound.",
  "VkSparseImageOpaqueMemoryBindInfo.pBinds": "pname:pBinds is a pointer to array of sname:VkSparseMemoryBind structures.",
  "VkSparseMemoryBind": "Structure specifying a sparse memory bind operation.",
  "VkSparseMemoryBind.flags": "pname:flags is a bitmask specifying usage of the binding operation. Bits which can: be set include: + --",
  "VkSparseMemoryBind.memory": "pname:memory is the sname:VkDeviceMemory object that the range of the resource is bound to. If pname:memory is dlink:VK_NULL_HANDLE, the range is unbound.",
  "VkSparseMemoryBind.memoryOffset": "pname:memoryOffset is the offset into the sname:VkDeviceMemory object to bind the resource range to. If pname:memory is dlink:VK_NULL_HANDLE, this value is ignored.",
  "VkSparseMemoryBind.resourceOffset": "pname:resourceOffset is the offset into the resource.",
  "VkSparseMemoryBind.size": "pname:size is the size of the memory region to be bound.",
  "VkSparseMemoryBindFlagBits": "Bitmask specifying usage of a sparse memory binding operation.",
  "VkSparseMemoryBindFlags": "",
  "VkSparseMemoryBindFlags.__none": "",
  "VkSparseMemoryBindFlags.VK_SPARSE_MEMORY_BIND_METADATA_BIT": "",
  "VkSpecializationInfo": "Structure specifying specialization info.",
  "VkSpecializationInfo.dataSize": "pname:dataSize is the byte size of the pname:pData buffer.",
  "VkSpecializationInfo.mapEntryCount": "pname:mapEntryCount is the number of entries in the pname:pMapEntries array.",
  "VkSpecializationInfo.pData": "pname:pData contains the actual constant values to specialize with.",
  "VkSpecializationInfo.pMapEntries": "pname:pMapEntries is a pointer to an array of sname:VkSpecializationMapEntry which maps constant IDs to offsets in pname:pData.",
  "VkSpecializationMapEntry": "Structure specifying a specialization map entry.",
  "VkSpecializationMapEntry.constantID": "pname:constantID is the ID of the specialization constant in SPIR-V.",
  "VkSpecializationMapEntry.offset": "pname:offset is the byte offset of the specialization constant value within the supplied data buffer.",
  "VkSpecializationMapEntry.size": "pname:size is the byte size of the specialization constant value within the supplied data buffer.",
  "VkStencilFaceFlagBits": "Bitmask specifying sets of stencil state for which to update the compare mask.",
  "VkStencilFaceFlags": "",
  "VkStencilFaceFlags.__none": "",
  "VkStencilFaceFlags.VK_STENCIL_FACE_BACK_BIT": "",
  "VkStencilFaceFlags.VK_STENCIL_FACE_FRONT_BIT": "",
  "VkStencilFaceFlags.VK_STENCIL_FRONT_AND_BACK": "",
  "VkStencilOp": "Stencil comparison function.",
  "VkStencilOp.VK_STENCIL_OP_DECREMENT_AND_CLAMP": "ename:VK_STENCIL_OP_DECREMENT_AND_CLAMP decrements the current value and clamps to 0.",
  "VkStencilOp.VK_STENCIL_OP_DECREMENT_AND_WRAP": "ename:VK_STENCIL_OP_DECREMENT_AND_WRAP decrements the current value and wraps to the maximum possible value when the value would go below 0.",
  "VkStencilOp.VK_STENCIL_OP_INCREMENT_AND_CLAMP": "ename:VK_STENCIL_OP_INCREMENT_AND_CLAMP increments the current value and clamps to the maximum representable unsigned value.",
  "VkStencilOp.VK_STENCIL_OP_INCREMENT_AND_WRAP": "ename:VK_STENCIL_OP_INCREMENT_AND_WRAP increments the current value and wraps to 0 when the maximum value would have been exceeded.",
  "VkStencilOp.VK_STENCIL_OP_INVERT": "ename:VK_STENCIL_OP_INVERT bitwise-inverts the current value.",
  "VkStencilOp.VK_STENCIL_OP_KEEP": "ename:VK_STENCIL_OP_KEEP keeps the current value.",
  "VkStencilOp.VK_STENCIL_OP_REPLACE": "ename:VK_STENCIL_OP_REPLACE sets the value to pname:reference.",
  "VkStencilOp.VK_STENCIL_OP_ZERO": "ename:VK_STENCIL_OP_ZERO sets the value to 0.",
  "VkStencilOpState": "Structure specifying stencil operation state.",
  "VkStencilOpState.compareMask": "pname:compareMask selects the bits of the unsigned integer stencil values participating in the stencil test.",
  "VkStencilOpState.compareOp": "pname:compareOp is the comparison operator used in the stencil test.",
  "VkStencilOpState.depthFailOp": "pname:depthFailOp is the action performed on samples that pass the stencil test and fail the depth test.",
  "VkStencilOpState.failOp": "pname:failOp is the action performed on samples that fail the stencil test.",
  "VkStencilOpState.passOp": "pname:passOp is the action performed on samples that pass both the depth and stencil tests.",
  "VkStencilOpState.reference": "pname:reference is an integer reference value that is used in the unsigned stencil comparison.",
  "VkStencilOpState.writeMask": "pname:writeMask selects the bits of the unsigned integer stencil values updated by the stencil test in the stencil framebuffer attachment.",
  "VkStructureType": "",
  "VkStructureType.VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_APPLICATION_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BIND_SPARSE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET": "",
  "VkStructureType.VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EVENT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_HDR_METADATA_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK": "",
  "VkStructureType.VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_BARRIER": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE": "",
  "VkStructureType.VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SUBMIT_INFO": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD": "",
  "VkStructureType.VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT": "",
  "VkStructureType.VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET": "",
  "VkStructureType.VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR": "",
  "VkStructureType.VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR": "",
  "VkSubmitInfo": "Structure specifying a queue submit operation.",
  "VkSubmitInfo.commandBufferCount": "pname:commandBufferCount is the number of command buffers to execute in the batch.",
  "VkSubmitInfo.pCommandBuffers": "pname:pCommandBuffers is a pointer to an array of command buffers to execute in the batch.",
  "VkSubmitInfo.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSubmitInfo.pSignalSemaphores": "pname:pSignalSemaphores is a pointer to an array of semaphores which will be signaled when the command buffers for this batch have completed execution. If semaphores to be signaled are provided, they define a <<synchronization-semaphores-signaling, semaphore signal operation>>.",
  "VkSubmitInfo.pWaitDstStageMask": "pname:pWaitDstStageMask is a pointer to an array of pipeline stages at which each corresponding semaphore wait will occur.",
  "VkSubmitInfo.pWaitSemaphores": "pname:pWaitSemaphores is a pointer to an array of semaphores upon which to wait before the command buffers for this batch begin execution. If semaphores to wait on are provided, they define a <<synchronization-semaphores-waiting, semaphore wait operation>>.",
  "VkSubmitInfo.signalSemaphoreCount": "pname:signalSemaphoreCount is the number of semaphores to be signaled once the commands specified in pname:pCommandBuffers have completed execution.",
  "VkSubmitInfo.sType": "pname:sType is the type of this structure.",
  "VkSubmitInfo.waitSemaphoreCount": "pname:waitSemaphoreCount is the number of semaphores upon which to wait before executing the command buffers for the batch.",
  "VkSubpassContents": "Specify how commands in the first subpass of a render pass are provided.",
  "VkSubpassContents.VK_SUBPASS_CONTENTS_INLINE": "",
  "VkSubpassContents.VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS": "",
  "VkSubpassDependency": "Structure specifying a subpass dependency.",
  "VkSubpassDependency.dependencyFlags": "pname:dependencyFlags is a bitmask of elink:VkDependencyFlagBits.",
  "VkSubpassDependency.dstAccessMask": "pname:dstAccessMask defines a <<synchronization-access-masks, destination access mask>>.",
  "VkSubpassDependency.dstStageMask": "pname:dstStageMask defines a <<synchronization-pipeline-stages-masks, destination stage mask>>.",
  "VkSubpassDependency.dstSubpass": "pname:dstSubpass is the subpass index of the second subpass in the dependency, or ename:VK_SUBPASS_EXTERNAL.",
  "VkSubpassDependency.srcAccessMask": "pname:srcAccessMask defines a <<synchronization-access-masks, source access mask>>.",
  "VkSubpassDependency.srcStageMask": "pname:srcStageMask defines a <<synchronization-pipeline-stages-masks, source stage mask>>.",
  "VkSubpassDependency.srcSubpass": "pname:srcSubpass is the subpass index of the first subpass in the dependency, or ename:VK_SUBPASS_EXTERNAL.",
  "VkSubpassDescription": "Structure specifying a subpass description.",
  "VkSubpassDescription.colorAttachmentCount": "",
  "VkSubpassDescription.flags": "pname:flags is a bitmask indicating usage of the subpass. Bits which can: be set include: + --",
  "VkSubpassDescription.inputAttachmentCount": "",
  "VkSubpassDescription.pColorAttachments": "",
  "VkSubpassDescription.pDepthStencilAttachment": "",
  "VkSubpassDescription.pInputAttachments": "",
  "VkSubpassDescription.pipelineBindPoint": "",
  "VkSubpassDescription.pPreserveAttachments": "",
  "VkSubpassDescription.preserveAttachmentCount": "",
  "VkSubpassDescription.pResolveAttachments": "",
  "VkSubpassDescriptionFlagBits": "Bitmask specifying usage of a subpass.",
  "VkSubpassDescriptionFlags": "",
  "VkSubpassDescriptionFlags.__none": "",
  "VkSubpassDescriptionFlags.VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX": "",
  "VkSubpassDescriptionFlags.VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX": "",
  "VkSubresourceLayout": "Structure specifying subresource layout.",
  "VkSubresourceLayout.arrayPitch": "pname:arrayPitch describes the number of bytes between each array layer of an image.",
  "VkSubresourceLayout.depthPitch": "pname:depthPitch describes the number of bytes between each slice of 3D image.",
  "VkSubresourceLayout.offset": "pname:offset is the byte offset from the start of the image where the image subresource begins.",
  "VkSubresourceLayout.rowPitch": "pname:rowPitch describes the number of bytes between each row of texels in an image.",
  "VkSubresourceLayout.size": "pname:size is the size in bytes of the image subresource. pname:size includes any extra memory that is required based on pname:rowPitch.",
  "VkSurfaceCapabilities2EXT": "Structure describing capabilities of a surface.",
  "VkSurfaceCapabilities2EXT.currentExtent": "",
  "VkSurfaceCapabilities2EXT.currentTransform": "",
  "VkSurfaceCapabilities2EXT.maxImageArrayLayers": "",
  "VkSurfaceCapabilities2EXT.maxImageCount": "",
  "VkSurfaceCapabilities2EXT.maxImageExtent": "",
  "VkSurfaceCapabilities2EXT.minImageCount": "",
  "VkSurfaceCapabilities2EXT.minImageExtent": "",
  "VkSurfaceCapabilities2EXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSurfaceCapabilities2EXT.sType": "pname:sType is the type of this structure.",
  "VkSurfaceCapabilities2EXT.supportedCompositeAlpha": "",
  "VkSurfaceCapabilities2EXT.supportedSurfaceCounters": "pname:supportedSurfaceCounters is a bitfield containing one bit set for each surface counter type supported.",
  "VkSurfaceCapabilities2EXT.supportedTransforms": "",
  "VkSurfaceCapabilities2EXT.supportedUsageFlags": "",
  "VkSurfaceCapabilities2KHR": "",
  "VkSurfaceCapabilities2KHR.pNext": "",
  "VkSurfaceCapabilities2KHR.sType": "",
  "VkSurfaceCapabilities2KHR.surfaceCapabilities": "",
  "VkSurfaceCapabilitiesKHR": "Structure describing capabilities of a surface.",
  "VkSurfaceCapabilitiesKHR.currentExtent": "pname:currentExtent is the current width and height of the surface, or the special value [eq]#(0xFFFFFFFF, 0xFFFFFFFF)# indicating that the surface size will be determined by the extent of a swapchain targeting the surface.",
  "VkSurfaceCapabilitiesKHR.currentTransform": "pname:currentTransform is the surface's current transform relative to the presentation engine's natural orientation, as described by elink:VkSurfaceTransformFlagBitsKHR.",
  "VkSurfaceCapabilitiesKHR.maxImageArrayLayers": "pname:maxImageArrayLayers is the maximum number of layers presentable images can: have for a swapchain created for this device and surface, and will be at least one.",
  "VkSurfaceCapabilitiesKHR.maxImageCount": "pname:maxImageCount is the maximum number of images the specified device supports for a swapchain created for the surface, and will be either 0, or greater than or equal to pname:minImageCount. A value of 0 means that there is no limit on the number of images, though there may: be limits related to the total amount of memory used by presentable images.",
  "VkSurfaceCapabilitiesKHR.maxImageExtent": "pname:maxImageExtent contains the largest valid swapchain extent for the surface on the specified device. The pname:width and pname:height of the extent will each be greater than or equal to the corresponding pname:width and pname:height of pname:minImageExtent. The pname:width and pname:height of the extent will each be greater than or equal to the corresponding pname:width and pname:height of pname:currentExtent, unless pname:currentExtent has the special value described above.",
  "VkSurfaceCapabilitiesKHR.minImageCount": "pname:minImageCount is the minimum number of images the specified device supports for a swapchain created for the surface, and will be at least one.",
  "VkSurfaceCapabilitiesKHR.minImageExtent": "pname:minImageExtent contains the smallest valid swapchain extent for the surface on the specified device. The pname:width and pname:height of the extent will each be less than or equal to the corresponding pname:width and pname:height of pname:currentExtent, unless pname:currentExtent has the special value described above.",
  "VkSurfaceCapabilitiesKHR.supportedCompositeAlpha": "pname:supportedCompositeAlpha is a bitmask of elink:VkCompositeAlphaFlagBitsKHR, representing the alpha compositing modes supported by the presentation engine for the surface on the specified device, and at least one bit will be set. Opaque composition can: be achieved in any alpha compositing mode by either using an image format that has no alpha component, or by ensuring that all pixels in the presentable images have an alpha value of 1.0.",
  "VkSurfaceCapabilitiesKHR.supportedTransforms": "pname:supportedTransforms is a bitmask of elink:VkSurfaceTransformFlagBitsKHR, describing the presentation transforms supported for the surface on the specified device, and at least one bit will be set.",
  "VkSurfaceCapabilitiesKHR.supportedUsageFlags": "pname:supportedUsageFlags is a bitmask of elink:VkImageUsageFlagBits representing the ways the application can: use the presentable images of a swapchain created for the surface on the specified device. ename:VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT must: be included in the set but implementations may: support additional usages.",
  "VkSurfaceCounterFlagBitsEXT": "Surface-relative counter types.",
  "VkSurfaceCounterFlagsEXT": "",
  "VkSurfaceCounterFlagsEXT.__none": "",
  "VkSurfaceCounterFlagsEXT.VK_SURFACE_COUNTER_VBLANK_EXT": "",
  "VkSurfaceFormat2KHR": "",
  "VkSurfaceFormat2KHR.pNext": "",
  "VkSurfaceFormat2KHR.sType": "",
  "VkSurfaceFormat2KHR.surfaceFormat": "",
  "VkSurfaceFormatKHR": "Structure describing a supported swapchain format-color space pair.",
  "VkSurfaceFormatKHR.colorSpace": "pname:colorSpace is a presentation ename:VkColorSpaceKHR that is compatible with the surface.",
  "VkSurfaceFormatKHR.format": "pname:format is a ename:VkFormat that is compatible with the specified surface.",
  "VkSurfaceKHR": "",
  "VkSurfaceTransformFlagBitsKHR": "Presentation transforms supported on a device.",
  "VkSurfaceTransformFlagsKHR": "",
  "VkSurfaceTransformFlagsKHR.__none": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR": "",
  "VkSurfaceTransformFlagsKHR.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR": "",
  "VkSwapchainCounterCreateInfoEXT": "Specify the surface counters desired.",
  "VkSwapchainCounterCreateInfoEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSwapchainCounterCreateInfoEXT.sType": "pname:sType is the type of this structure.",
  "VkSwapchainCounterCreateInfoEXT.surfaceCounters": "pname:surfaceCounters is a bitmask containing a bit set for each surface counter to enable for the swapchain.",
  "VkSwapchainCreateFlagBitsKHR": "Bitmask controlling swapchain creation.",
  "VkSwapchainCreateFlagsKHR": "",
  "VkSwapchainCreateFlagsKHR.__none": "",
  "VkSwapchainCreateFlagsKHR.VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX": "",
  "VkSwapchainCreateInfoKHR": "Structure specifying parameters of a newly created swapchain object.",
  "VkSwapchainCreateInfoKHR.clipped": "",
  "VkSwapchainCreateInfoKHR.compositeAlpha": "",
  "VkSwapchainCreateInfoKHR.flags": "pname:flags is a bitmask indicating parameters of swapchain creation. Bits which can: be set include: + --",
  "VkSwapchainCreateInfoKHR.imageArrayLayers": "",
  "VkSwapchainCreateInfoKHR.imageColorSpace": "",
  "VkSwapchainCreateInfoKHR.imageExtent": "",
  "VkSwapchainCreateInfoKHR.imageFormat": "",
  "VkSwapchainCreateInfoKHR.imageSharingMode": "",
  "VkSwapchainCreateInfoKHR.imageUsage": "",
  "VkSwapchainCreateInfoKHR.minImageCount": "",
  "VkSwapchainCreateInfoKHR.oldSwapchain": "",
  "VkSwapchainCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkSwapchainCreateInfoKHR.pQueueFamilyIndices": "",
  "VkSwapchainCreateInfoKHR.presentMode": "",
  "VkSwapchainCreateInfoKHR.preTransform": "",
  "VkSwapchainCreateInfoKHR.queueFamilyIndexCount": "",
  "VkSwapchainCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkSwapchainCreateInfoKHR.surface": "",
  "VkSwapchainKHR": "",
  "VkSystemAllocationScope": "Allocation scope.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_CACHE": "ename:VK_SYSTEM_ALLOCATION_SCOPE_CACHE - The allocation is scoped to the lifetime of a sname:VkPipelineCache object.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_COMMAND": "ename:VK_SYSTEM_ALLOCATION_SCOPE_COMMAND - The allocation is scoped to the duration of the Vulkan command.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_DEVICE": "ename:VK_SYSTEM_ALLOCATION_SCOPE_DEVICE - The allocation is scoped to the lifetime of the Vulkan device.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE": "ename:VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - The allocation is scoped to the lifetime of the Vulkan instance.",
  "VkSystemAllocationScope.VK_SYSTEM_ALLOCATION_SCOPE_OBJECT": "ename:VK_SYSTEM_ALLOCATION_SCOPE_OBJECT - The allocation is scoped to the lifetime of the Vulkan object that is being created or used.",
  "VkTextureLODGatherFormatPropertiesAMD": "",
  "VkTextureLODGatherFormatPropertiesAMD.pNext": "",
  "VkTextureLODGatherFormatPropertiesAMD.sType": "",
  "VkTextureLODGatherFormatPropertiesAMD.supportsTextureGatherLODBiasAMD": "",
  "vkTrimCommandPoolKHR": "Trim a command pool.",
  "vkTrimCommandPoolKHR.commandPool": "",
  "vkTrimCommandPoolKHR.device": "",
  "vkTrimCommandPoolKHR.flags": "",
  "vkUnmapMemory": "Unmap a previously mapped memory object.",
  "vkUnmapMemory.device": "",
  "vkUnmapMemory.memory": "",
  "vkUnregisterObjectsNVX": "",
  "vkUnregisterObjectsNVX.device": "",
  "vkUnregisterObjectsNVX.objectCount": "",
  "vkUnregisterObjectsNVX.objectTable": "",
  "vkUnregisterObjectsNVX.pObjectEntryTypes": "",
  "vkUnregisterObjectsNVX.pObjectIndices": "",
  "vkUpdateDescriptorSets": "Update the contents of a descriptor set object.",
  "vkUpdateDescriptorSets.descriptorCopyCount": "",
  "vkUpdateDescriptorSets.descriptorWriteCount": "",
  "vkUpdateDescriptorSets.device": "",
  "vkUpdateDescriptorSets.pDescriptorCopies": "",
  "vkUpdateDescriptorSets.pDescriptorWrites": "",
  "vkUpdateDescriptorSetWithTemplateKHR": "",
  "vkUpdateDescriptorSetWithTemplateKHR.descriptorSet": "",
  "vkUpdateDescriptorSetWithTemplateKHR.descriptorUpdateTemplate": "",
  "vkUpdateDescriptorSetWithTemplateKHR.device": "",
  "vkUpdateDescriptorSetWithTemplateKHR.pData": "",
  "VkValidationCheckEXT": "Specify validation checks to disable.",
  "VkValidationCheckEXT.VK_VALIDATION_CHECK_ALL_EXT": "",
  "VkValidationCheckEXT.VK_VALIDATION_CHECK_SHADERS_EXT": "",
  "VkValidationFlagsEXT": "Specify validation checks to disable for a Vulkan instance.",
  "VkValidationFlagsEXT.disabledValidationCheckCount": "pname:disabledValidationCheckCount is the number of checks to disable.",
  "VkValidationFlagsEXT.pDisabledValidationChecks": "pname:pDisabledValidationChecks is a pointer to an array of values specifying the validation checks to be disabled. Checks which may: be specified include: + --",
  "VkValidationFlagsEXT.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkValidationFlagsEXT.sType": "pname:sType is the type of this structure.",
  "VkVertexInputAttributeDescription": "Structure specifying vertex input attribute description.",
  "VkVertexInputAttributeDescription.binding": "pname:binding is the binding number which this attribute takes its data from.",
  "VkVertexInputAttributeDescription.format": "pname:format is the size and type of the vertex attribute data.",
  "VkVertexInputAttributeDescription.location": "pname:location is the shader binding location number for this attribute.",
  "VkVertexInputAttributeDescription.offset": "pname:offset is a byte offset of this attribute relative to the start of an element in the vertex input binding.",
  "VkVertexInputBindingDescription": "Structure specifying vertex input binding description.",
  "VkVertexInputBindingDescription.binding": "pname:binding is the binding number that this structure describes.",
  "VkVertexInputBindingDescription.inputRate": "pname:inputRate specifies whether vertex attribute addressing is a function of the vertex index or of the instance index. Possible values include: + --",
  "VkVertexInputBindingDescription.stride": "pname:stride is the distance in bytes between two consecutive elements within the buffer.",
  "VkVertexInputRate": "Specify rate at which vertex attributes are pulled from buffers.",
  "VkVertexInputRate.VK_VERTEX_INPUT_RATE_INSTANCE": "",
  "VkVertexInputRate.VK_VERTEX_INPUT_RATE_VERTEX": "",
  "VkViewport": "Structure specifying a viewport.",
  "VkViewport.height": "",
  "VkViewport.maxDepth": "",
  "VkViewport.minDepth": "pname:minDepth and pname:maxDepth are the depth range for the viewport. It is valid for pname:minDepth to be greater than or equal to pname:maxDepth.",
  "VkViewport.width": "pname:width and pname:height are the viewport's width and height, respectively.",
  "VkViewport.x": "pname:x and pname:y are the viewport's upper left corner [eq]#(x,y)#.",
  "VkViewport.y": "",
  "VkViewportCoordinateSwizzleNV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV": "",
  "VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV": "",
  "VkViewportSwizzleNV": "Structure specifying a viewport swizzle.",
  "VkViewportSwizzleNV.w": "pname:w is the swizzle operation to apply to the w component of the primitive",
  "VkViewportSwizzleNV.x": "pname:x is the swizzle operation to apply to the x component of the primitive",
  "VkViewportSwizzleNV.y": "pname:y is the swizzle operation to apply to the y component of the primitive",
  "VkViewportSwizzleNV.z": "pname:z is the swizzle operation to apply to the z component of the primitive",
  "VkViewportWScalingNV": "Structure specifying a viewport.",
  "VkViewportWScalingNV.xcoeff": "pname:xcoeff and pname:ycoeff are the viewport's W scaling factor for x and y respectively.",
  "VkViewportWScalingNV.ycoeff": "",
  "VkViSurfaceCreateFlagsNN": "",
  "VkViSurfaceCreateFlagsNN.__none": "",
  "VkViSurfaceCreateInfoNN": "Structure specifying parameters of a newly created VI surface object.",
  "VkViSurfaceCreateInfoNN.flags": "pname:flags is reserved for future use.",
  "VkViSurfaceCreateInfoNN.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkViSurfaceCreateInfoNN.sType": "pname:sType is the type of this structure.",
  "VkViSurfaceCreateInfoNN.window": "pname:window is the code:nn::code:vi::code:NativeWindowHandle for the code:nn::code:vi::code:Layer with which to associate the surface.",
  "vkWaitForFences": "Wait for one or more fences to become signaled.",
  "vkWaitForFences.device": "",
  "vkWaitForFences.fenceCount": "",
  "vkWaitForFences.pFences": "",
  "vkWaitForFences.timeout": "",
  "vkWaitForFences.waitAll": "",
  "VkWaylandSurfaceCreateFlagsKHR": "",
  "VkWaylandSurfaceCreateFlagsKHR.__none": "",
  "VkWaylandSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Wayland surface object.",
  "VkWaylandSurfaceCreateInfoKHR.display": "pname:display and pname:surface are pointers to the Wayland code:wl_display and code:wl_surface to associate the surface with.",
  "VkWaylandSurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkWaylandSurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkWaylandSurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkWaylandSurfaceCreateInfoKHR.surface": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pNext": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoKHR.sType": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV": "Use Windows keyex mutex mechanism to synchronize work.",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pNext": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount": "",
  "VkWin32KeyedMutexAcquireReleaseInfoNV.sType": "",
  "VkWin32SurfaceCreateFlagsKHR": "",
  "VkWin32SurfaceCreateFlagsKHR.__none": "",
  "VkWin32SurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Win32 surface object.",
  "VkWin32SurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkWin32SurfaceCreateInfoKHR.hinstance": "pname:hinstance and pname:hwnd are the Win32 code:HINSTANCE and code:HWND for the window to associate the surface with.",
  "VkWin32SurfaceCreateInfoKHR.hwnd": "",
  "VkWin32SurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkWin32SurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkWriteDescriptorSet": "Structure specifying the parameters of a descriptor set write operation.",
  "VkWriteDescriptorSet.descriptorCount": "pname:descriptorCount is the number of descriptors to update (the number of elements in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView).",
  "VkWriteDescriptorSet.descriptorType": "pname:descriptorType is a elink:VkDescriptorType specifying the type of each descriptor in pname:pImageInfo, pname:pBufferInfo, or pname:pTexelBufferView, as described below. It must: be the same type as that specified in sname:VkDescriptorSetLayoutBinding for pname:dstSet at pname:dstBinding. The type of the descriptor also controls which array the descriptors are taken from.",
  "VkWriteDescriptorSet.dstArrayElement": "pname:dstArrayElement is the starting element in that array.",
  "VkWriteDescriptorSet.dstBinding": "pname:dstBinding is the descriptor binding within that set.",
  "VkWriteDescriptorSet.dstSet": "pname:dstSet is the destination descriptor set to update.",
  "VkWriteDescriptorSet.pBufferInfo": "pname:pBufferInfo points to an array of slink:VkDescriptorBufferInfo structures or is ignored, as described below.",
  "VkWriteDescriptorSet.pImageInfo": "pname:pImageInfo points to an array of slink:VkDescriptorImageInfo structures or is ignored, as described below.",
  "VkWriteDescriptorSet.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkWriteDescriptorSet.pTexelBufferView": "pname:pTexelBufferView points to an array of slink:VkBufferView handles as described in the <<resources-buffer-views,Buffer Views>> section or is ignored, as described below.",
  "VkWriteDescriptorSet.sType": "pname:sType is the type of this structure.",
  "VkXcbSurfaceCreateFlagsKHR": "",
  "VkXcbSurfaceCreateFlagsKHR.__none": "",
  "VkXcbSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Xcb surface object.",
  "VkXcbSurfaceCreateInfoKHR.connection": "pname:connection is a pointer to an code:xcb_connection_t to the X server.",
  "VkXcbSurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkXcbSurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkXcbSurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkXcbSurfaceCreateInfoKHR.window": "pname:window is the code:xcb_window_t for the X11 window to associate the surface with.",
  "VkXlibSurfaceCreateFlagsKHR": "",
  "VkXlibSurfaceCreateFlagsKHR.__none": "",
  "VkXlibSurfaceCreateInfoKHR": "Structure specifying parameters of a newly created Xlib surface object.",
  "VkXlibSurfaceCreateInfoKHR.dpy": "pname:dpy is a pointer to an Xlib code:Display connection to the X server.",
  "VkXlibSurfaceCreateInfoKHR.flags": "pname:flags is reserved for future use.",
  "VkXlibSurfaceCreateInfoKHR.pNext": "pname:pNext is `NULL` or a pointer to an extension-specific structure.",
  "VkXlibSurfaceCreateInfoKHR.sType": "pname:sType is the type of this structure.",
  "VkXlibSurfaceCreateInfoKHR.window": "pname:window is an Xlib code:Window to associate the surface with.",
  "VkXYColorEXT": "Structure to specify X,Y chromaticity coordinates.",
  "VkXYColorEXT.x": "",
  "VkXYColorEXT.y": "",
  "void": "",
  "Window": "",
  "wl_display": "",
  "wl_surface": "",
  "xcb_connection_t": "",
  "xcb_visualid_t": "",
  "xcb_window_t": ""
}