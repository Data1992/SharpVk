<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file=".\License.tt" #>
<#@ include file=".\Vk.ttinclude" #>
using System;

namespace SharpVk
{
<#
	var structs = GetStructs();

	foreach(var structType in structs.Where(x => !x.IsSimpleStruct))
	{
		string structName = structType.Name;
		var members = new List<MemberInfo>();

		var lenMembers = new List<string>();

		var memberNameMap = new Dictionary<string, string>();

		foreach(var member in structType.Members)
        {
			string memberName = member.Name;

			if(member.Len != null)
			{
				lenMembers.Add(member.Len.First());
			}

			var memberType = member.Type;
		
			if(member.Size == 0 || member.Type.IsPrimitive)
            {
				members.Add(new MemberInfo
				{
					Type = memberType,
					Name = memberName,
					PointerCount = member.PointerCount,
					Size = member.Size
				});

				memberNameMap.Add(memberName, member.VkName);
            }
			else
            {
				for(int fieldIndex = 0;fieldIndex < member.Size;fieldIndex++)
                {
					members.Add(new MemberInfo
					{
						Type = memberType,
						Name = memberName + "_" + fieldIndex,
						PointerCount = member.PointerCount
					});

					memberNameMap.Add(memberName + "_" + fieldIndex, member.VkName);
                }
            }
        }
#>

	public class <#=structName#>
	{
<#
		if(!structType.IsReturnedOnly)
		{
#>

		internal unsafe Interop.<#=structName#> MarshalTo()
		{
			var result = new Interop.<#=structName#>();
<#
			if(structType.Xml.Elements("member").Any(x => x.Element("name").Value == "sType"))
			{
#>

			result.SType = StructureType.<#=structName#>;

<#
			}

			members = members.Where(member => member.Type.Category != Category.handle
											&& member.Name != "SType"
											&& !lenMembers.Contains(memberNameMap[member.Name]))
							.ToList();
			
			foreach(var member in members)
			{
				string memberTypeName = member.Type.Name;
				bool isFixedArray = false;
				int pointerCount = member.PointerCount;
						
				if(member.Type.Category == Category.basetype)
				{
					memberTypeName = MapBaseTypeName(memberTypeName);
				}
				else if(memberTypeName == "char" && member.Size > 0)
				{
					memberTypeName = "string";
				}
				else if(member.Type.IsPrimitive && member.Size > 0)
				{
					isFixedArray = true;
				}
				else if(memberTypeName == "char" && pointerCount > 0)
				{
					memberTypeName = "string";
					pointerCount--;
				}
			
				if(pointerCount > 0)
				{
					continue;
				}
			
				if(isFixedArray)
				{
#>
			Interop.HeapUtil.MarshalArrayToPointer(this.<#=member.Name#>, <#=member.Size#>, result.<#=member.Name#>);
<#
				}
				else
				{
					string valueString = "this." + member.Name;
					if(memberTypeName == "string")
					{
						valueString = string.Format("Interop.HeapUtil.MarshalStringToPointer({0})", valueString);
					}
					else if(member.Type.Category == Category.@struct && !member.Type.IsSimpleStruct)
					{
						valueString = string.Format("{0}.MarshalTo()", valueString);
					}
#>
			result.<#=member.Name#> = <#=valueString#>;
<#
				}
			}
#>

			return result;
		}

<#
		}

		foreach(var member in members)
        {
			string memberTypeName = member.Type.Name;
			bool isFixedArray = false;
			int pointerCount = member.PointerCount;
						
			if(member.Type.Category == Category.basetype)
            {
				memberTypeName = MapBaseTypeName(memberTypeName);
            }
			else if(memberTypeName == "char" && member.Size > 0)
			{
				memberTypeName = "string";
				isFixedArray = true;
			}
			else if(member.Type.IsPrimitive && member.Size > 0)
			{
				isFixedArray = true;
			}
			else if(memberTypeName == "char" && pointerCount > 0)
			{
				memberTypeName = "string";
				pointerCount--;
			}
			
			if(member.Type.Category != Category.@struct && pointerCount > 0)
            {
				continue;
            }
#>

		public <#=memberTypeName#><#=isFixedArray?"[]":""#> <#=member.Name#>
		{
			get;
			<#=structType.IsReturnedOnly?"private ":""#>set;
		}
<#
        }
#>
	}
<#
	}
#>
}
<#+
class MemberInfo
{
	public TypeDef Type;
	public string Name;
	public int PointerCount;
	public int Size;
}
#>