<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file=".\License.tt" #>
<#@ include file=".\Vk.ttinclude" #>
using System;
using System.Runtime.InteropServices;

namespace SharpVk
{
<#
	var structs = GetStructs();

	foreach(var structType in structs.Where(x => !x.IsSimpleStruct))
	{
		string structName = structType.Name;
		var members = new List<MemberInfo>();

		var lenMembers = new List<string>();

		var memberNameMap = new Dictionary<string, string>();

		foreach(var member in structType.Members)
        {
			string memberName = member.Name;
			string memberLen = null;

			if(member.Len != null && member.Len.First() != "null-terminated")
			{
				memberLen = member.Len.First();
				if(memberLen.IndexOf(' ') > 0)
				{
					lenMembers.Add(memberLen.Substring(0, memberLen.IndexOf(' ')));
				}
				else
				{
					lenMembers.Add(memberLen);
				}
			}

			if(member.Type.Name != "void")
			{
				members.Add(new MemberInfo
				{
					Type = member.Type,
					Name = memberName,
					PointerCount = member.PointerCount,
					Size = member.Size,
					Len = memberLen
				});
			}

			memberNameMap.Add(memberName, member.VkName);
        }
#>

	public class <#=structName#>
	{
<#
		if(!structType.IsReturnedOnly)
		{
#>

		internal unsafe Interop.<#=structName#> MarshalTo()
		{
			var result = new Interop.<#=structName#>();
<#
			if(structType.Xml.Elements("member").Any(x => x.Element("name").Value == "sType"))
			{
#>

			result.SType = StructureType.<#=structName#>;

<#
			}

			members = members.Where(member => member.Type.Category != Category.handle
											&& member.Name != "SType"
											&& !lenMembers.Contains(memberNameMap[member.Name]))
							.ToList();
			
			foreach(var member in members)
			{
				string memberTypeName = member.Type.Name;
				bool isFixedArray = false;
				int pointerCount = member.PointerCount;
						
				if(member.Type.Category == Category.basetype)
				{
					memberTypeName = MapBaseTypeName(memberTypeName);
				}
				else if(memberTypeName == "char" && pointerCount > 0)
				{
					memberTypeName = "string";
					pointerCount--;
				}
				else if(memberTypeName == "char" && member.Size > 0)
				{
					memberTypeName = "string";
				}
				else if(member.Type.IsPrimitive && member.Size > 0)
				{
					isFixedArray = true;
				}
				
				if(member.Type.IsPrimitive && member.Len != null)
				{
					pointerCount--;
				}
			
				if(pointerCount > 0)
				{
					continue;
				}
			
				if(isFixedArray)
				{
#>
			Interop.HeapUtil.MarshalArrayToPointer(this.<#=member.Name#>, <#=member.Size#>, result.<#=member.Name#>);
<#
				}
				else if(member.Len != null)
				{
					string pointers = new string('*', member.PointerCount);
                    string lenName = char.ToUpper(member.Len[0]) + member.Len.Substring(1);

					string factor = "";
					string castName = "uint";

					if(lenName.EndsWith(" / 4"))
					{
						factor = " * 4";
						lenName = lenName.Substring(0, lenName.Length - 4);
						castName = "UIntPtr";
					}
#>
			if(this.<#=member.Name#> != null)
			{
				result.<#=member.Name#> = (<#=member.Type.Name#><#=pointers#>)Marshal.AllocHGlobal(Marshal.SizeOf<<#=memberTypeName#>>() * this.<#=member.Name#>.Length).ToPointer();
				Interop.HeapUtil.MarshalArrayToPointer(this.<#=member.Name#>, this.<#=member.Name#>.Length, result.<#=member.Name#>);
				result.<#=lenName#> = (<#=castName#>)(this.<#=member.Name#>.Length<#=factor#>);
			}
<#
				}
				else
				{
					string valueString = "this." + member.Name;
					if(memberTypeName == "string")
					{
						valueString = string.Format("Interop.HeapUtil.MarshalStringToPointer({0})", valueString);
					}
					else if(member.Type.Category == Category.@struct && !member.Type.IsSimpleStruct && member.Len == null)
					{
						valueString = string.Format("{0}.MarshalTo()", valueString);
					}
#>
			result.<#=member.Name#> = <#=valueString#>;
<#
				}
			}
#>

			return result;
		}

<#
		}

		foreach(var member in members)
        {
			string memberTypeName = member.Type.Name;
			bool isFixedArray = false;
			int pointerCount = member.PointerCount;
						
			if(member.Type.Category == Category.basetype)
            {
				memberTypeName = MapBaseTypeName(memberTypeName);
            }
			else if(memberTypeName == "char" && member.Size > 0)
			{
				memberTypeName = "string";
			}
			else if(member.Type.IsPrimitive && member.Size > 0)
			{
				isFixedArray = true;
			}
			else if(memberTypeName == "char" && pointerCount > 0)
			{
				memberTypeName = "string";
				pointerCount--;
			}
			
			if(member.Len != null)
			{
				pointerCount--;
				memberTypeName += "[]";
			}
			
			if(member.Type.Category != Category.@struct && pointerCount > 0)
            {
				continue;
            }
#>

		public <#=memberTypeName#><#=isFixedArray?"[]":""#> <#=member.Name#>
		{
			get;
			<#=structType.IsReturnedOnly?"private ":""#>set;
		}
<#
        }
#>
	}
<#
	}
#>
}
<#+
class MemberInfo
{
	public TypeDef Type;
	public string Name;
	public int PointerCount;
	public int Size;
	public string Len;
}
#>