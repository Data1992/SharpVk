<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file=".\License.tt" #>
<#@ include file=".\Vk.ttinclude" #>
using System;

namespace SharpVk
{
<#
var parser = GetParser();
var generator = new TypeGenerator();

var types = generator.Generate(parser.Run());

foreach(var handle in types.Handles)
{
	var interfaces = new List<string>();

	if(handle.IsDisposable)
    {
		interfaces.Add("IDisposable");
    }
	
	if(handle.IsProcLookup)
    {
		interfaces.Add("IProcLookup");
    }
#>
    /// <summary>
<#
	foreach(var line in handle.Comment)
    {
#>
	/// <para>
    /// <#=line#>
	/// </para>
<#
	}
#>
    /// </summary>
	public class <#=handle.Name#>
<#
	if(interfaces.Any())
	{
#>
		: <#= string.Join(", ", interfaces) #>
<#
    }
#>
	{
		internal readonly Interop.<#=handle.Name#> handle;

		internal readonly CommandCache commandCache;

<#
	string commandCacheParam = "";
	string parentCache = handle.ParentHandle == null
							? "null"
							: "parent.commandCache";

	string commandCacheAssignment = $"new CommandCache(this, \"{handle.ProcCacheType}\", {parentCache})";

	if(!handle.IsProcLookup)
    {
		commandCacheParam = ", CommandCache commandCache";
		commandCacheAssignment = "commandCache";
    }

	if(handle.ParentHandle != null)
    {
#>
		private readonly <#=handle.ParentHandle#> parent;

		internal AllocationCallbacks? Allocator
		{
			get
			{
				return this.parent.Allocator;
			}
		}

<#
		if(handle.AssociatedHandle != null)
        {
#>
		private readonly <#=handle.AssociatedHandle#> associated;

		internal <#=handle.Name#>(Interop.<#=handle.Name#> handle, <#=handle.ParentHandle#> parent, <#=handle.AssociatedHandle#> associated<#=commandCacheParam#>)
		{
			this.handle = handle;
			this.parent = parent;
			this.associated = associated;
			this.commandCache = <#=commandCacheAssignment#>;
		}
<#
        }
		else
        {
#>

		internal <#=handle.Name#>(Interop.<#=handle.Name#> handle, <#=handle.ParentHandle#> parent<#=commandCacheParam#>)
		{
			this.handle = handle;
			this.parent = parent;
			this.commandCache = <#=commandCacheAssignment#>;
		}
<#
        }
    }
	else
    {
#>
		private AllocationCallbacks? allocator;

		internal AllocationCallbacks? Allocator
		{
			get
			{
				return this.allocator;
			}
		}

		internal <#=handle.Name#>(Interop.<#=handle.Name#> handle, AllocationCallbacks? allocator<#=commandCacheParam#>)
		{
			this.handle = handle;
			this.allocator = allocator;
			this.commandCache = <#=commandCacheAssignment#>;
		}
<#
    }
#>
<#
	foreach(var method in handle.Methods)
    {
#>

		/// <summary>
<#
		foreach(var line in method.Comment)
		{
#>
		/// <para>
		/// <#=line#>
		/// </para>
<#
        }
#>
		/// </summary>
		public <#if(method.IsStatic)#>static <#;#><#=method.ReturnTypeName#> <#=method.Name#>(<#
		bool previousParamSet = false;

		foreach(var param in method.Parameters)
		{
			if(previousParamSet && param.Name != null)
			{
				#>, <#
			}

			if(param.Name != null)
			{
				#><#=param.TypeName#> <#=param.Name#><#

				previousParamSet = true;
			}
		}
				#>)
		{
			unsafe
			{
<#
		string invocation = $"Interop.Commands.{method.CommandName}";
		if(method.ShouldGetFromCache)
        {
#>
				var commandDelegate = this.commandCache.GetCommandDelegate<Interop.<#=method.CacheLookupName#>>("<#=method.CacheLookupName#>", "<#=method.CacheLookupType#>");
<#
			invocation = "commandDelegate";
        }
#>

<#
		if(method.ReturnTypeName != "void")
		{
#>				<#=method.ReturnTypeName#> result = default(<#=method.ReturnTypeName#>);

<#
		}

		if(method.HasVkResult)
        {
#>				Result commandResult;

<#
        }
#>
<#
		foreach(var statement in method.MarshalToStatements)
		{
#>				<#=statement#>
<#
		}

		bool isFirst;

		if(method.IsDoubleInvoke)
		{
#>
				<#if(method.HasVkResult){#>commandResult = <#}#><#=invocation#>(<#
			isFirst = true;

			foreach(var param in method.Parameters)
			{
				if(isFirst)
				{
					isFirst = false;
				}
				else
				{
#>, <#
				}
#><#=param.PreInvokeArgumentName ?? param.ArgumentName#><#
			}
				#>);

<#
			if(method.HasVkResult)
			{
#>				if (SharpVkException.IsError(commandResult))
				{
					throw SharpVkException.Create(commandResult);
				}
<#
			}
		}

		foreach(var statement in method.MarshalMidStatements)
		{
#>				<#=statement#>
<#
		}

		foreach(var fixedParam in method.Parameters.Where(x => !string.IsNullOrEmpty(x.FixedName)))
		{
#>				fixed(<#=fixedParam.FixedType#> <#=fixedParam.FixedName#> = <#=fixedParam.Name#>)
<#
		}
#>
				<#if(method.HasVkResult){#>commandResult = <#}#><#if(method.IsPassthroughResult){#>result = <#}#><#=invocation#>(<#
		isFirst = true;

		foreach(var param in method.Parameters)
		{
			if(isFirst)
			{
				isFirst = false;
			}
			else
			{
#>, <#
			}
#><#=param.ArgumentName#><#
		}
				#>);

<#
		if(method.HasVkResult)
		{
#>				if (SharpVkException.IsError(commandResult))
				{
					throw SharpVkException.Create(commandResult);
				}
<#
		}

		foreach(var statement in method.MarshalFromStatements)
		{
#>				<#=statement#>
<#
		}
#>

				Interop.HeapUtil.FreeLog();

<#
		if(method.ReturnTypeName != "void")
		{
#>

				return result;
<#
		}
#>
			}
		}
<#
    }
#>

		internal Interop.<#=handle.Name#> Pack()
		{
			return this.handle;
		}
<#
	if(handle.IsDisposable)
    {
#>

		/// <summary>
		/// Releases the unmanaged resources associated with this instance and
		/// destroys the underlying Vulkan handle.
		/// </summary>
		public void Dispose()
		{
			this.Destroy();
		}
<#
    }
#>
	}

<#
}
#>
}