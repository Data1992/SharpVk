<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file=".\License.tt" #>
<#@ include file=".\Vk.ttinclude" #>
<#
	var parser = GetParser();
	var generator = new TypeGenerator();

	var types = generator.Generate(parser.Run());
#>
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace SharpVk
{
	public struct SampleMask
	{
		private uint value;

		public static implicit operator SampleMask(uint value)
		{
			return new SampleMask { value = value };
		}

		public static implicit operator uint(SampleMask size)
		{
			return size.value;
		}

		public override string ToString()
		{
			return this.value.ToString();
		}
	}

	public struct Bool32
	{
		private uint value;

		public Bool32(bool value)
		{
			this.value = value
							? Constants.True
							: Constants.False;
		}

		public static implicit operator Bool32(bool value)
		{
			return new Bool32(value);
		}

		public static implicit operator bool(Bool32 value)
		{
			return value.value != Constants.False;
		}

		public override string ToString()
		{
			return ((bool)this).ToString();
		}
	}

	public struct DeviceSize
	{
		private ulong value;

		public static implicit operator DeviceSize(int value)
		{
			return new DeviceSize { value = (ulong)value };
		}

		public static implicit operator DeviceSize(ulong value)
		{
			return new DeviceSize { value = value };
		}

		public static implicit operator ulong(DeviceSize size)
		{
			return size.value;
		}

		public override string ToString()
		{
			return this.value.ToString();
		}
	}

	public partial struct ComponentMapping
	{
		public static ComponentMapping Identity
		{
			get
			{
				return new ComponentMapping
					{
						R = ComponentSwizzle.Identity,
						G = ComponentSwizzle.Identity,
						B = ComponentSwizzle.Identity,
						A = ComponentSwizzle.Identity
					};
			}
		}
	}
<#
	foreach(var structType in types.Structs)
	{
#>

    /// <summary>
<#
	foreach(var line in (structType.Comment ?? "").Split('\n'))
    {
#>
    /// <#=line#>
<#
	}
#>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
	public partial struct <#=structType.Name#>
	{
<#
		foreach(var member in structType.Members)
        {
#>
		public <#=member.TypeName#> <#=member.Name#>;

<#
        }
#>
		public override string ToString()
		{
			var builder = new StringBuilder();
			
            builder.AppendLine("<#=structType.Name#>");
            builder.AppendLine("{");
<#
		foreach(var member in structType.Members)
        {
#>
            builder.AppendLine($"<#=member.Name#>: {this.<#=member.Name#>}");
<#
        }
#>
            builder.Append("}");

			return builder.ToString();
		}
	}
<#
	}
#>
}