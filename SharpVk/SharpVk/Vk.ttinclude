<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="$(SolutionDir)Lib\SharpVk.VkXml.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Xml.Linq" #>
<#+

Dictionary<string, string> primitiveTypes = new Dictionary<string, string>()
{
    {"void", "void"},
	{"char", "char"},
	{"float", "float"},
	{"uint8_t", "byte"},
	{"uint32_t", "uint"},
	{"uint64_t", "ulong"},
	{"int32_t", "int"},
	{"size_t", "UIntPtr"}
};

Dictionary<string, string> baseTypes = new Dictionary<string, string>()
{
    {"Bool32", "bool"},
	{"DeviceSize", "ulong"},
	{"SampleMask", "uint"}
};

string[] extensionSuffixes = new[]{"KHR", "EXT"};

enum Category
{
	None,
	vk_platform,
	other_platform,
	@struct,
	@enum,
	funcpointer,
	bitmask,
	basetype,
	handle,
	union
}

class TypeDef
{
	public Category Category;
	public string Name;
	public XElement Xml;
}
 
XDocument GetVkXml()
{
	string tempFile = Path.Combine(Host.ResolvePath("."), "obj\\VkTemplates\\vk.xml");

    if (!File.Exists(tempFile) || File.GetLastWriteTimeUtc(tempFile) + TimeSpan.FromDays(1) < DateTime.UtcNow)
    {
		try
        {
			Directory.CreateDirectory(Path.GetDirectoryName(tempFile));

			var vkXmlRequest = WebRequest.Create("https://raw.githubusercontent.com/KhronosGroup/Vulkan-Docs/1.0/src/spec/vk.xml");

			using(var vkXmlResponse = vkXmlRequest.GetResponse())
			using(var fileStream = File.OpenWrite(tempFile))
			{
				vkXmlResponse.GetResponseStream().CopyTo(fileStream);
			}
        }
		catch
        {
        }
    }
	
    return XDocument.Load(tempFile);
}

static Dictionary<string, TypeDef> typeDefCache = null;

Dictionary<string, TypeDef> GetAllTypes()
{
	if(typeDefCache == null)
    {
		var vkXml = GetVkXml();

		Category typeCategory = Category.None;

		var result = new Dictionary<string, TypeDef>();

		foreach(var vkType in vkXml.Element("registry").Element("types").Elements("type"))
		{
			var additionalTypeNames = new List<string>();

			if(vkType.Attribute("category") == null || !Enum.TryParse<Category>(vkType.Attribute("category").Value, out typeCategory))
            {
				if(vkType.Attribute("requires") != null && vkType.Attribute("requires").Value == "vk_platform")
                {
					typeCategory = Category.vk_platform;
                }
				else
                {
					typeCategory = Category.other_platform;
                }
            }

			string vkTypeName = null;

			if(vkType.Attribute("name") !=null)
			{
				vkTypeName = vkType.Attribute("name").Value;
			}
			else
			{
				vkTypeName = vkType.Element("name").Value;
			}

			if(vkTypeName.Contains("SurfaceCreateInfo"))
            {
				// Skip these for now...

				continue;
            }

			string typeName = vkTypeName;

			if(primitiveTypes.ContainsKey(typeName))
			{
				typeName = primitiveTypes[vkTypeName];
			}
			else if(typeCategory == Category.bitmask)
            {
				if(vkType.Attribute("requires") == null)
				{
					typeName = "uint";
				}
				else
				{
					additionalTypeNames.Add(vkType.Attribute("requires").Value);
				}
            }
			else if(typeCategory == Category.funcpointer)
            {
				typeName = "IntPtr";
            }
			
			if(typeName.StartsWith("vk", true, null))
			{
				typeName = typeName.Substring(2);
			}

			if(!result.ContainsKey(vkTypeName))
			{
				result.Add(vkTypeName, new TypeDef
					{
						Category = typeCategory,
						Name = typeName,
						Xml = vkType
					});
			}

			foreach(var additionalTypeName in additionalTypeNames)
			{
				result.Add(additionalTypeName, new TypeDef
					{
						Category = typeCategory,
						Name = typeName,
						Xml = vkType
					});
			}
		}

		typeDefCache = result;
    }

	return typeDefCache;
}

TypeDef GetTypeDef(string vkTypeName)
{
	var types = GetAllTypes();

	if(!types.ContainsKey(vkTypeName))
    {
		throw new Exception(string.Format("Unrecognised VK Type {0}", vkTypeName));
    }

	return types[vkTypeName];
}

IEnumerable<TypeDef> GetStructs()
{
	return GetAllTypes().Select(x => x.Value).Where(x => x.Category == Category.@struct && !extensionSuffixes.Any(y => x.Name.EndsWith(y)));
}

IEnumerable<TypeDef> GetHandles()
{
	return GetAllTypes().Select(x => x.Value).Where(x => x.Category == Category.handle);
}

IEnumerable<TypeDef> GetUnions()
{
	return GetAllTypes().Select(x => x.Value).Where(x => x.Category == Category.union);
}

IEnumerable<XElement> GetCommands()
{
	return GetVkXml().Element("registry").Element("commands").Elements("command").Where(x => !extensionSuffixes.Any(y => x.Element("proto").Value.EndsWith(y)));
}

string MapTypeName(string vkTypeName)
{
	return GetTypeDef(vkTypeName).Name;
}

string MapBaseTypeName(string baseTypeName)
{
	return baseTypes[baseTypeName];
}
#>